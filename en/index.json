[{"content":" Bi-RRT 原理 基本名词 状态空间：系统全部可能状态的集合 RRT原理 RRT(Rapidly exploring Random Tree 快速随机搜索树)是一种全局规划算法\n已知：\n初始状态（起点位置）$q_{start}$ 目标状态（终点位置）$q_{goal}$ 搜索步长 ${\\rho}$ 系统状态空间 $C$ 自由状态空间 $C_{free}$ $C_{free}{\\subset}C$，是 $C$ 中不会发生碰撞的状态集合 目标状态空间 $C_{goal}$ 有 $k$ 个节点的快速随机搜索树 $T_k$ 过程：\n生成随机点：在自由状态空间 $C_{free}$ 中随机采一个状态点 $q_{rand}$，同时保证 $q_{rand}{\\notin}T_k$ 查找最近点：遍历现有的随机搜索树 $T_k$ 寻找与 $q_{rand}$ 最近的节点 $q_{near}$ 计算新节点：从 $q_{near}$ 向 $q_{rand}$ 方向拓展距离 ${\\rho}$ 得到 $q_{new}$，检查该路径是否会发生碰撞。 若会发生碰撞，返回1. 不会发生碰撞，则将 $q_{new}$ 添加到 $T_k$ 中 计算公式： $$q_{\\text {new }}=q_{\\text {near }}+\\varepsilon \\frac{q_{\\text {rand }}-q_{\\text {near }}}{\\left|q_{\\text {rand }}-q_{\\text {near }}\\right|}$$ 到达检查：若节点 $q_{new}$ 实现 $DIS(q_{new},q_{goal})\u0026lt;{\\rho}$，证明已经到达终点，添加 $q_{goal}$ 到 $T_k$ ，搜索结束。若 $DIS(q_{new},q_{goal})\u0026gt;{\\rho}$，返回1. 得到路径：从 $q_{goal}$ 开始反向回溯亲节点直到 $q_{start}$，形成完整路径 $L$ graph LR 生成随机点--\u0026gt;生成新节点 生成新节点--\u0026gt;碰撞检查 生成新节点--\u0026gt;到达检查 到达检查--\u0026gt;|不成功|重新生成随机点 碰撞检查---\u0026gt;|不成功|重新生成随机点 碰撞检查--\u0026gt;|成功|扩展树 扩展树--\u0026gt;重新生成随机点 到达检查---\u0026gt;|成功|结束 Bi-RRT原理 从起点、终点同时开始随机搜索树的构建\n另外已知：\n从起点开始构建的随机搜索树的新节点为 $q_{new-start}$ 从终点开始构建的随机搜索树的新节点为 $q_{new-goal}$ 从起点开始构建的随机搜索树为 $T_{k-start}$ 从终点开始构建的随机搜索树为 $T_{k-goal}$ 将上文RRT构建过程的4.到达检查修改为如下检查:\n若节点 $q_{new-start}$ 实现 $DIS(q_{new-start},q_{new-goal})\u0026lt;{\\rho}$， 证明已经到达终点，添加 $q_{new-goal}$ 到 $T_{k-goal}$ ，搜索结束。若 $DIS(q_{new-start},q_{new-goal})\u0026gt;{\\rho}$，返回1. 将上文RRT构建过程的5.得到路径修改为如下过程:\n从 $q_{new-goal}$ 开始同时向起点、终点回溯亲节点直到 $q_{start}$ 与 $q_{goal}$，形成完整路径 RRT-Connect原理 与Bi-RRT大致相同\n相对于Bi-RRT，RRT-Connect虽然也是起终点同时开始两条路径，但是从起点方向生成随机点， 用终点的随机搜索树向其进行拓展，反之亦然 分析 出入 （生成随机点）程序实际在 $C$ 中随机采样，也未避免其在 $T_k$ 中；可能造成冗余，在狭窄复杂环境中可能会导致收敛速度减慢 其他问题 （生成随机点）在整个自由状态空间任何位置以相同概率生成随机点，缺少对目标点的指向性 （计算新节点）任何节点的拓展距离都相同，缺少空间敏感性 eg.在空旷位置可以适当增长拓展距离 （计算新节点）遇到障碍时回退到1.生成随机点，可以考虑不回退，通过更换方向避障 （到达检查）用 $DIS(q_{new},q_{goal})\u0026lt;{\\rho}$ 进行到达检查，可能在终点 附近需要不同的标准 改进点 （生成随机点）引入人工势场/其他方法提高随机点指向性 \u0026amp; 在自由状态空间中生成随机点 （查找最近点）最近点的度量方式在基础算法中是最基础的几何距离，可以更改度量方式 剪枝处理——生成的路径有较多折角与累赘路径，可进行剪枝处理 对得到的路径 $L$，从 $q_{goal}$（视为当前起始点 $q_{now}$）开始分别与其后的节点连接并进行碰撞检查 若在连接 $q_{now}$ 与某节点 $q_{collision}$ 时发生碰撞，回退到 $q_{collision}$ 的亲节点 $q_{no-collision-near}$， 并连接 $q_{now}$ 与 $q_{no-collision-near}$ 形成新路径的一部分 从 $q_{no-collision}$ 开始重复3.1.，直到某个 $q_{now}$ 连接到 $q_{goal}$ （到达检查）根据实例对到达检查精度进行修改 路径折角多，可通过样条曲线对路径进行光顺 \u0026amp; 生成路径时进行转角优化 源码中转角通过角度常量进行简单约束，可考虑结合运动方程 实现 生成随机点 def get_random_node(x_min, x_max, y_min, y_max, goal_point=None): # 此处在目标点方向增加生成概率 if goal_point is not None and random.random() \u0026lt;= 0.2: x = goal_point[0] y = goal_point[1] else: x = random.uniform(x_min, x_max) y = random.uniform(y_min, y_max) rnd_node = Node(x, y) return rnd_node 查找最近点 def get_nearest_node_index(node_list, rnd_node): dlist = [] # 遍历随机搜索树 for node in node_list: dis = calc_p2p_dis(node, rnd_node) dlist.append(dis) minind = dlist.index(min(dlist)) # 返回距离最近的点 return minind 计算新节点 def generate_new_node(nearest_node, random_node, extend_length): new_node = Node(nearest_node.x, nearest_node.y) d = math.sqrt((random_node.x - nearest_node.x) ** 2 + (random_node.y - nearest_node.y) ** 2) if extend_length \u0026gt; d: extend_length = d dx = random_node.x - nearest_node.x dy = random_node.y - nearest_node.y if dx * dx + dy * dy == 0: return random_node # 新节点计算公式 new_node.x += extend_length / math.sqrt(dx * dx + dy * dy) * dx new_node.y += extend_length / math.sqrt(dx * dx + dy * dy) * dy # 建立节点的连接（亲节点） new_node.parent = nearest_node return new_node 碰撞检查（圆形/矩形障碍物） def check_collision(node1, node2, obstacleList): for [ox, oy, size] in obstacleList: round = Node(ox, oy) # 增加障碍物的半径为size_new 避免实际情况下的碰撞 size_new = size if node2 is None: return False if calc_p2p_dis(node1, round) \u0026lt;= size_new: return True # 发生碰撞 if calc_p2p_dis(node2, round) \u0026lt;= size_new: return True # 若点线距小于“半径”且该线段可能出现在圆内 if calc_p2l_dis(node1, node2, round) \u0026lt;= size_new and calc_triangle_deg(node1, round, node2) \u0026lt;= 90 and \\ calc_triangle_deg(node2, round, node1) \u0026lt;= 90: return True elif len(obstacle) == 4: # 矩形障碍物用内置函数判断 rect_shape = box(obstacle[0], obstacle[1], obstacle[2], obstacle[3]) if not isinstance(node1, list): line = LineString([(node1.x, node1.y), (node2.x, node2.y)]) else: line = LineString([(node1[0], node1[1]), (node2[0], node2[1])]) if line.intersects(rect_shape): return True return False # 不碰撞 Bi-RRT到达检查与路径生成 # 每次生成一轮（两个）新节点后都对整个路径进行遍历，检查两个路径中可否各有一个点相连生成路径 for node1 in node_list1: for node2 in node_list2: if calc_p2p_dis(node1, node2) \u0026lt;= extend_length and \\ check_collision(node1, node2, obs_list) == False: # 生成从起点到相交点的路径 path1 = [] node = node1 while node is not None: path1.append([node.x, node.y]) node = node.parent path1.reverse() # 反转路径，使其从起点开始 # 生成从终点到相交点的路径 path2 = [] node = node2 while node is not None: path2.append([node.x, node.y]) node = node.parent # 合并两条路径 path = path1 + path2 此处可以优化为只用新生成的点来试验能否连上（已完成 与上文程序类似 省略）\n剪枝 def prune_path(path, obs_list): pruned_path = [path[0]] i = 0 while i \u0026lt; len(path) - 1: found = False # 从终点开始验证 找到第一个不碰撞的（反之有漏洞 for j in range(len(path) - 1, i, -1): if not check_collision(path[i], path[j], obs_list): pruned_path.append(path[j]) # 更新起点 i = j found = True break if not found: # 确保路径前进 i += 1 if pruned_path[-1] != path[-1]: pruned_path.append(path[-1]) return pruned_path 效果 单向RRT\u0026amp;不剪枝 单向RRT\u0026amp;剪枝 双向RRT\u0026amp;剪枝 Bi-RRT* 填坑中…\nDQN-RRT-Connect 填坑中…\n","permalink":"https://Sattiluvcat.github.io/en/posts/else/bi-rrt/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"bi-rrt\"\u003eBi-RRT\u003c/h2\u003e\n\u003ch3 id=\"原理\"\u003e原理\u003c/h3\u003e\n\u003ch4 id=\"基本名词\"\u003e基本名词\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e状态空间：系统全部可能状态的集合\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"rrt原理\"\u003eRRT原理\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRRT(Rapidly exploring Random Tree 快速随机搜索树)是一种全局规划算法\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e已知：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e初始状态（起点位置）$q_{start}$\u003c/li\u003e\n\u003cli\u003e目标状态（终点位置）$q_{goal}$\u003c/li\u003e\n\u003cli\u003e搜索步长 ${\\rho}$\u003c/li\u003e\n\u003cli\u003e系统状态空间 $C$\u003c/li\u003e\n\u003cli\u003e自由状态空间 $C_{free}$\n\u003cul\u003e\n\u003cli\u003e$C_{free}{\\subset}C$，是 $C$ 中\u003cem\u003e不会发生碰撞\u003c/em\u003e的状态集合\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e目标状态空间 $C_{goal}$\u003c/li\u003e\n\u003cli\u003e有 $k$ 个节点的快速随机搜索树 $T_k$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e过程：\u003c/p\u003e","title":"Bi-RRT及改良"},{"content":" 概要 产品原型：展示项目的业务功能\n技术选型： 前端已完成 知识点 JavaScript 三种变量：var——全局\u0026amp;可变 let——局部\u0026amp;唯一 const——全局\u0026amp;不可变 特殊运算符：==不同类型进行类型转换后再比较 ===（全等）不进行类型转换即比较（不同类型必报错） 类型转换： 除0与NaN转换为false外其它全为true 除空字符串转为false外均为true parseInt转换为int类型 JSON格式：先属性后函数 else——XHR xml http request SpringBoot 自动进行请求响应：@RequestMapping即可 保证形参与在PostMan中的定义名称相同 不可保证的变量前添加@RequestParam(name=\u0026quot;\u0026quot;,require=false)前缀 require=false表示不一定需要此变量 传递参数过多时可将其封装到某实体类中——形参为该类 自动进行类型转换 Maven java项目管理与构建 基于项目对象模型POM\n作用 依赖管理：管理项目依赖的资源——jar包 避免版本冲突 pom.xml中配置依赖信息dependency（会指明存储地址） maven_repo作为本地仓库可查看已有的依赖信息 中央仓库 统一项目结构：不同IDE下项目结构都标准统一 项目构建：跨平台eg.Linux-Windows自动化项目构建 编译、测试等功能在maven中已集成为插件 流程 创建maven模块\n坐标：组织名groupId-模块名artifactId-版本号version ——唯一定义资源位置 组织名：通常域名反写 模块名：通常项目名称 编译后产生target文件夹 存放字节码 导入Maven项目——右侧栏Maven项添加对应项目的pom.xml 依赖管理 依赖配置——dependency指明组织名 模块名 版本 依赖传递——直接/间接依赖 可通过exclusion排除被传递来的依赖 依赖范围——默认在主程序main、测试程序test、参与打包运行package范围内均有效 可通过scope指定范围（与坐标并列）eg.test/provided（主+测）/runtime（测+包） 生命周期——三套 同一套生命周期中 有先后顺序 在前的先运行 clean 清理 default 核心工作（调试 测试等） site 生成报告 发布站点 分模块开发 将工具类、实体类等拆分为单独的模块——需要调用时引入该模块 继承与聚合 继承：定义parent工程——引入公共依赖 子工程使用parent parent工程设置打包方式（使用）packaging为pom 只能单继承 但可以多层继承 继承——版本锁定：parent工程中锁定依赖的版本（但并不引入） 需要引入依赖的子工程无需指定版本号 运用dependencyManagement进行版本指定（确定坐标） parent工程中可以用：(方便在统一位置查看) \u0026lt;something.version\u0026gt;*.*.**\u0026lt;/something.version\u0026gt; 定义版本 something下\u0026lt;version\u0026gt;${something.version}\u0026lt;/version\u0026gt;调用 聚合：问题——拆分出来的类在main打包前需要全部先install到本地 解决：创建聚合工程（= parent工程）——不包含业务功能 只有一个pom modules \u0026amp; module关键字指定所有需要一起打包的模块 指定顺序无影响 格式：\u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; 私服 局域网内的仓库\n步骤：maven——conf——settings.xml\nsevers标签配置私服访问用户\u0026amp;密码 \u0026lt;server\u0026gt; \u0026lt;!-- 还有maven-snapshots也需要配置 --\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;satti\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;something\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; mirrors\u0026amp;profiles标签配置连接私服访问地址 \u0026lt;mirror\u0026gt; \u0026lt;!-- 若配置过aliyun镜像 需先将其去掉 --\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;allow-snapshots\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; pom文件中配置上传url地址 \u0026lt;distributionManagement\u0026gt; \u0026lt;!-- release版本的发布地址--\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-releases/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!-- snapshot领本的发布地址: --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 通过生命周期deploy上传到私服 之后可以直接从私服中下载依赖（之前上传的模块） SpringBoot SpringBootWeb 基本内容 SpringBootApplicaton启动类——通过其运行整个程序 配置文件：main——resource——application.properties 实现 请求处理类 类前注明@RestController 处理请求的方法前注明@RequestMapping(\u0026quot;/something\u0026quot;) http协议 Hyper Text Transfer Protocol超文本传输协议 规定浏览器vs服务器的数据传输规则\n特点： 基于TCP协议——安全 基于请求-响应模型——一次请求得一次响应 无状态协议——每次请求相互独立（多次请求不能共享数据 but 快） 请求协议：请求行 + 请求头（+ 请求体） 请求行（第一行） = 请求方式 + 资源路径 + 协议 请求头：(格式key: value) 常用：Host（主机名）User-Agent（浏览器版本） 请求参数（JSON格式）——GET存放在请求行中 POST在请求体中 响应协议：响应行 + 响应头（+ 响应体） 响应行：协议 + 响应状态码 + 描述 状态码：1**——响应中 2**——成功 3**——重定向 4**——客户端错误 5**——服务器错误 客户端错误——eg.请求不存在的资源404/未被授权403/语法错误400 服务器错误——eg.程序抛出异常 响应头：(格式key: value) eg.Content-Encoding响应压缩算法 如gzip 响应体：存放请求参数 协议解析 TomCat 轻量级web服务器\nweb服务器：对http协议操作进行封装 \u0026amp; 部署web项目 对外提供网上信息浏览服务 安装目录： bin——可执行文件 work——工作目录 lib——依赖的jar包 webapps——部署项目 程序简单解析 starter——起步依赖 springboot有内嵌tomcat 请求响应 架构： BS Browser/Server 浏览器/服务器架构 CS Client/Server 客户端/服务器架构（需安装） postman——接口测试 统一接口（返回值） 对所有类型都适配 主题内容包括code（响应码）+msg+data（返回数据） public static Result success(Object data){ //外部定义code msg data（Object类型） return new Result(1,\u0026#34;success\u0026#34;,data); } 分层解耦 web开发三层架构 controller控制层——接收前端请求并处理响应 service业务逻辑层——具体逻辑 dao数据访问层（data access object持久层）——数据增删改查 内聚——模块内部功能联系 耦合——模块间依赖/关联（高内聚低耦合） IOC\u0026amp;DI——类上添加注解@Component（注册Bean） 控制器类改为@Controller 业务类前改为@Service 数据访问类改为@Repository IOC容器提供该类的bean对象并赋值 DI：在类内部对象前添加@Autowired依赖注入——使用Bean 会话 用户访问web：会话开始 某方断连：会话结束 一次会话可以包括多次请求响应 会话跟踪：追踪请求来自同一浏览器（以便在同一会话的多次请求间共享数据）\n会话跟踪方案：客户端Cookie 服务端Session 令牌 Cookie（HTTP协议支持）移动端无法用 \u0026amp; 用户可禁用 \u0026amp; 不能跨域 跨域——协议 IP 端口 Session 服务器集群时无法直接用 \u0026amp; Cookie的缺点 令牌——反上述缺点 but 需要自己实现 JSON Web Token(JWT)——json格式传输 Header + Payload有效载荷（自定义内容） + Signature数字签名（防止Token被篡改） Header\u0026amp;Payload：Base64编码（A-Z a-z 0-9 + /）——表示二进制 Signature：登录成功后生成令牌 后续请求都须携带 可设定有效期 Filter过滤器 拦截资源请求 一般完成登录校验 统一编码处理 敏感字符处理等\n实现： 创建Filter类（immport javax.servlet.*）添加注解@WebFilter(urlPatterns=\u0026quot;/bal\u0026quot;) init（调用一次） doFilter destroy（调用一次）方法 需要开启：添加注解@ServletComponentScan doFilter添加放行功能 chain.doFilter(request,response)——放行到下一个过滤器 其后添加放行后的逻辑 Bean 声明Bean对象未指定名称——默认为类的首字母小写（获得Object对象） 作用域：单例——singleton（启动时创建一个） 非单例——prototype（同名只创建一次实例） Mybatis 持久层框架（数据库操作） 简化JDBC（对数据库进行操作的规范）开发\n使用： 定义接口类 添加注解@Mapper 内部实现Mysql操作（使用注解@Delete/Select等） 使用时需要注入 运行时会自动生成接口的实现类对象（代理对象） 并交给IOC容器 通过#{balabal}传递方法中的参数 若需拼接（eg.模糊匹配）用concat('%','balabal','%') 调用（定义该类型变量）时添加注解@Autowired @Autowired private EmpDao empDao; JDBC——使用Java操作关系型数据库 数据库连接池——分配管理数据库连接（SpringBoot默认Hikari） 允许重复使用现有的数据库连接（不重新建立）——资源重用 提升系统响应速度 释放空闲时间过长（被占用但未与数据库连接）的连接——避免连接泄露 lombok——通过注解自动生成构造器等方法、日志变量 @Data=@Getter/Setter/ToString/EqualsAndHashCode @NoArgsConstructor无参 @AllArgsConstructor除static修饰的字段外带各参构造方法 增删改查：定义public int delete/insert等返回此操作会影响的记录数（用void则忽略） 增（主键返回）添加注解@Options(keyProperty=\u0026quot;id\u0026quot;,useGeneratedKeys=true)将生成的主键赋值给emp（定义的类的对象）的id 查 实体类属性名与SQL字段名相同时 mybatis会自动封装 可给字段名起别名/mybatis驼峰命名映射开关 配置日志信息：application.properties中添加mybatis.configuration.log-impl=StdOutImpl 预编译SQL——缓存语法检查、优化SQL、编译SQL过程，（条件一定时）直接执行 用占位符定义（之后传参） 避免SQL注入——通过输入影响预定的SQL语句 xml映射文件——定义比较复杂的SQL语句（让代码更简洁） 映射配置文件名与Mapper接口名一致，且放在相同的包下(同包同名) 映射配置文件的namespace属性与Mapper接口的全类名一致 XML映射文件中sql语句的id与Mapper接口中的方法名一致 SDK Software Development Kit软件开发工具包 SpringBoot 起步依赖 自动配置\n起步依赖——依靠maven的依赖传递 自动配置（某些配置类、bean对象自动存入IOC容器（不需要声明对象）） SpringBootApplication扫描当前包与子包检查类的调用（不同包下自定义类不能注入） @ComponentScan(balabal)组件扫描 @Immport导入 自动配置原理：（源码跟踪AutoConfiguration.Imports）添加Conditional注解（有多个子注解） SpringBoot进行条件装配 Ctrl点方法查看源码 后端 项目结构Base sky-pojo中存放Entity（实体 与数据库中的表对应）、DTO（数据传输对象 各层间传输数据）、 VO（视图对象 前端展示数据）、POJO（普通java对象 仅属性\u0026amp;对应的getter setter） sky-common——com.sky——exception下存放异常类 报错集锦 初始版本编译：“找不到符号” jdk版本不匹配：设置中修改为jdk18 \u0026amp; 将maven——运行程序——JRE版本更新 \u0026amp; 项目结构SDK版本更新 点击登录没反应 nginx启动 知识点 前后端联调 前端请求如何传输到后端？ Nginx反向代理——前端发出动态请求Nginx转发到后端服务器Tomcat 优点：提高访问速度\u0026amp;负载均衡（大量的请求按指定方式均衡分配给每台服务器）\u0026amp;保证后端服务安全 负载均衡策略：weight/ip_hash/least_conn/… # 处理管理端发送的请求 location /api/ { proxy_pass http://localhost:8080/admin/; # 反向代理 #proxy_pass http://webservers/admin/; # 负载均衡 } Swagger 生成接口文档\u0026amp;在线接口调试——Knife4j封装\n功能完善 登录功能 MD5加密——密码散列函数 不能解密（只能加密后比较结果）\n数据库保存加密后的密码，用户登录时将输入的密码进行加密后比较 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/%E5%A4%96%E5%8D%96proj/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"概要\"\u003e概要\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e产品原型：展示项目的业务功能\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e技术选型：\n\u003cimg loading=\"lazy\" src=\"img.png\" alt=\"alt text\"  /\u003e\n\n\u003cul\u003e\n\u003cli\u003e前端已完成\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"知识点\"\u003e知识点\u003c/h2\u003e\n\u003ch3 id=\"javascript\"\u003eJavaScript\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e三种变量：\u003ccode\u003evar\u003c/code\u003e——全局\u0026amp;可变 \u003ccode\u003elet\u003c/code\u003e——局部\u0026amp;唯一 \u003ccode\u003econst\u003c/code\u003e——全局\u0026amp;不可变\u003c/li\u003e\n\u003cli\u003e特殊运算符：==不同类型进行类型转换后再比较 ===（全等）不进行类型转换即比较（不同类型必报错）\u003c/li\u003e\n\u003cli\u003e类型转换：\n\u003cul\u003e\n\u003cli\u003e除0与NaN转换为false外其它全为true 除空字符串转为false外均为true\u003c/li\u003e\n\u003cli\u003eparseInt转换为int类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eJSON格式：先属性后函数\u003c/li\u003e\n\u003cli\u003eelse——XHR xml http request\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"springboot\"\u003eSpringBoot\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e自动进行请求响应：\u003ccode\u003e@RequestMapping\u003c/code\u003e即可\n\u003cul\u003e\n\u003cli\u003e保证形参与在PostMan中的定义名称相同\n\u003cul\u003e\n\u003cli\u003e不可保证的\u003cstrong\u003e变量前添加\u003c/strong\u003e\u003ccode\u003e@RequestParam(name=\u0026quot;\u0026quot;,require=false)\u003c/code\u003e前缀\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequire=false\u003c/code\u003e表示不一定需要此变量\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e传递参数过多时可将其封装到某实体类中——\u003cstrong\u003e形参为该类\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e自动进行类型转换\n\u003cimg loading=\"lazy\" src=\"image.png\" alt=\"alt text\"  /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"maven\"\u003eMaven\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003ejava项目管理与构建 基于项目对象模型POM\u003c/p\u003e","title":"外卖Proj"},{"content":" 操作系统 定义 系统资源的管理者\u0026amp;提供方便的接口与环境\u0026amp;最接近硬件的软件\n功能：处理机(CPU)管理\u0026amp;存储器管理\u0026amp;文件管理\u0026amp;设备管理 程序运行 将相关数据从磁盘放入内存 = 存储器 进程被CPU管理 = 处理机 接口\u0026amp;环境 flowchart LR 接口--\u0026gt;GUI 接口--\u0026gt;程序接口 用户接口--\u0026gt;程序接口 用户接口--\u0026gt;脱机命令接口 接口--\u0026gt;命令接口 命令接口--\u0026gt;脱机命令接口 命令接口--\u0026gt;联机命令接口 联机命令接口---交互式命令接口 交互式命令接口--\u0026gt;cmd 批处理--\u0026gt;.bat 脱机命令接口---批处理 GUI 图形化用户接口 硬件拓展 无软件支持的计算机 = 裸机 覆盖了软件 = 扩充机器（虚拟机） 四个特征 并发 共享 是最基本的特征 互为存在条件\n并发 宏观上同时发生 微观上交替（= 同时段发生）\n单核CPU同一时刻只能执行一个程序=并发 多核可以实现并行（同一时刻进行多个程序） 共享 资源共享 系统资源可供内存中多个并发进程共同使用 两种资源共享方式：\n互斥共享 一时段一进程 eg.摄像头 同时共享 一时段多进程 虚拟 物理实体变为逻辑上的对应物\nflowchart LR 虚拟技术--\u0026gt;空分复用技术 虚拟技术--\u0026gt;时分复用技术 空分复用技术--\u0026gt;eg.虚拟存储器 时分复用技术--\u0026gt;eg.虚拟处理器 没有并发性 虚拟性 = 不存在 异步性 多个程序并发 资源有限时进程执行以未知速度推进\n没有并发性 异步性 = 不存在 发展与分类 flowchart TB subgraph 手工操作 缺点1--\u0026gt;独占全机 缺点1--\u0026gt;资源利用率低 资源利用率低--\u0026gt;计算机快\u0026amp;人工慢 end 手工操作--\u0026gt;批处理阶段 subgraph 批处理阶段 subgraph 单道批处理系统 主要结构--\u0026gt;磁带\u0026amp;监督程序 缺点2--\u0026gt;内存中仅能运行一道程序 end 单道批处理系统--\u0026gt;多道批处理系统 subgraph 多道批处理系统 输入计算输出错峰运行 缺点3--\u0026gt;运行过程时不能调试 end end 批处理阶段--\u0026gt;分时操作系统 subgraph 分时操作系统 特点--\u0026gt;以时间片为单位轮流服务用户 优点--\u0026gt;及时响应解决人机交互问题 缺点4--\u0026gt;不能优先处理紧急任务 end 分时操作系统--\u0026gt;实时操作系统 subgraph 实时操作系统 在严格时限内处理事件---可以优先响应 特点1--\u0026gt;及时性\u0026amp;可靠性 分类--\u0026gt;硬实时系统 硬实时系统---严格时限 分类--\u0026gt;软实时系统 软实时系统---偶尔接受迟滞 end 实时操作系统--\u0026gt;网络操作系统 实时操作系统--\u0026gt;分布式操作系统 实时操作系统--\u0026gt;个人计算机操作系统 subgraph 不重要 网络操作系统 分布式操作系统 个人计算机操作系统 end 运行机制 指令 = 机器指令 非cmd\n两种 flowchart LR 内核程序Kernal--\u0026gt;特权指令 应用程序--\u0026gt;非特权指令 特权指令--\u0026gt;内核态 非特权指令--\u0026gt;用户态 内核程序 = 最接近硬件的部分 特权指令 = 管理者操作 内核态/用户态 = CPU状态（用PSW存储状态） PSW 程序状态字寄存器 内核态=核心态=管态 用户态=目态 切换状态：\n内核到用户：特权指令修改PSW 用户到内核：触发中断 硬件自动完成 中断与异常 中断作用 唯一让CPU从用户态变为内核态的途径 = 保障并发\n中断类型 内中断（异常）：中断信号来自CPU内部 当前执行指令\n指令自身非法/遇到特权指令 eg.trap程序引发/fault错误条件 Kernal可能修补/abort致命错误 外中断（中断）：与当前指令无关 eg.时钟中断 eg.I/O中断 基本原理 CPU检测到中断后查询中断向量表 找到中断处理程序的内存位置\n系统调用 一组系统调用组成程序接口\n应用程序通常通过库函数进行系统调用 有些库函数不调用 有些语言直接进行系统调用 eg.汇编语言 向系统内核提出请求对共享资源进行操作 即系统调用 发出trap指令提出请求（用户态） 执行trap后引发内中断进入核心态 体系结构 大/宏内核操作系统：所有内核功能（Linux UNIX等）\neg.进程 存储 设备 + 微内核部分 性能高 内核代码庞大 结构混乱 微内核操作系统：与硬件关系最紧密的功能（Windows NT） eg.时钟管理 中断处理 原语（设备驱动 CPU切换） 优缺点反之 引导 过程 1\nCPU从主存（ = RAM + ROM（BIOS））执行ROM引导程序 将磁盘中主引导记录（MBR）读入内存 执行磁盘引导程序 扫描分区表 从活动分区（主分区）读入分区引导记录（PBR） 执行程序 主分区即安装了操作系统的分区 从根目录找到启动管理器并执行 完成开机🥳 虚拟机 Virtual Machine (VMware \u0026amp; Virtual Box)\n虚拟机管理程序（VMM monitor）\n第一类VMM 运行在硬件上（CPU 磁盘 内存进行划分） 用户空间分为虚拟用户态\u0026amp;虚拟内核态（但实际均为用户态） 若执行特权指令 由内核中的VMM进行虚拟执行 第二类VMM 运行在宿主操作系统（Host OS）上（如Vmware） VMM大部在用户态 VM驱动部分在内核态 对比：第一类性能更好 可容纳更多虚拟机 运行在最高特权级(Ring 0) 但可迁移性不强 第二类反之 进程管理 进程基础知识 基本 定义 程序：静态 = 指令集合 进程：动态 = 程序的执行过程\n进程组成 PCB（Process Control Block）进程控制块 For操作系统\n进程存在唯一标志 保存：PID UID \u0026amp; 进程控制与管理信息 \u0026amp; 资源分配清单 \u0026amp; 处理机信息 PID（进程ID 唯一不重复） 程序段：程序代码 For进程\n程序运行：程序-\u0026gt;硬盘（exe）-\u0026gt;内存PCB-\u0026gt;CPU取出指令 数据段：运行过程中产生的数据 For进程 进程实体（进程映像）=PCB+程序段+数据段 静态 进程 进程实体的运行过程 动态 特征 动态性：最基本的特征 并发性：内存中有多个进程实体 独立性：获得资源的基本单位 异步性 结构性：每个进程都有一个PCB\n状态与转换 创建态 就绪态 运行态 阻塞态 终止态\n就绪态——等待处理机调度 运行态——占用整个CPU运行 阻塞态——运行态进程请求等待某事件发生 下CPU（进程主动） 事件发生后改为就绪态（被动） 进程的组织 链式：队列指针 索引：索引表指针\n进程控制 实现进程状态转换\n原语实现——具原子性 = 不可中断\n特权指令 关中断指令\u0026amp;开中断指令实现原子性 关中断开启——不再检查中断信号 创建/撤销进程时使用的原语：PCB更新——资源分配——合适的队列\n申请空白PCB——找到对应PCB 为新进程分配资源——若运行 剥夺CPU并分配 初始化PCB——终止所有子进程 PCB插入就绪队列——资源归还并删除PCB 阻塞/唤醒原语——成对使用（因何阻塞必因何唤醒）\n切换进程的原语：将现行运行环境存入PCB\n进程通信IPC 两进程间的数据交互 不同进程的内存地址不重叠 通信需要操作系统支持\n共享存储 设定共享存储区 映射到进程的虚拟地址空间\n互斥访问 由进程自己实现 基于存储区：灵活性高 高级通信 基于数据结构：低级通信 消息传递 消息包括消息头\u0026amp;消息体 操作均由原语完成\n直接通信：两进程明确消息的接收方与发送方 在内存中存储发送了的消息 形成消息队列 间接通信：发到内存中的信箱 另一进程从信箱读取 信箱公用 管道通信 某时段内单向传输（半双工通信） I/O进程不固定数量\n一种共享文件pipe 内存中一个大小固定的内存缓冲区 队列 先进先出 线程与多线程 同个进程中可能有多个线程 程序执行的最小单位（相当于小进程）\n提升并发度 不用切换进程（同进程内线程切换）系统开销小 每个线程有自己的线程ID与TCB线程控制块 几乎不拥有系统资源（来自所属的进程） 通信方便 同进程内不需系统干预 线程实现方式 用户级线程（早期）——由线程库实现\u0026amp;管理 程序实现 与操作系统无关 并发程度很低（阻塞） 1 内核级线程（KTL） 进程与对应的内核级线程都在内核态的操作系统 内核级线程一一管理用户级线程 线程切换管理成本更高 多线程模型 一对一：一内核一用户 多对一：一内核多用户（退化） 多对多：多内核多用户（内核更少） 线程状态与转换 就绪——运行——阻塞 线程组织与控制 TCB(≈PCB)=线程标识符（TID）+程序计数器PC+其他寄存器+堆栈指针+线程运行状态+优先级 调度时保存PC+其他寄存器+堆栈指针 调度 处理机调度 确定处理任务的先后顺序\n三个层次 高级调度（作业调度）——从外存调入内存开始任务 低级调度（进程调度）——最基本 快速 内存到CPU 中级调度（内存调度）——从外存调到内存 从挂起队列调回内存（内存不足） 进程调度时机 不能调度的eg.处理中断 原语 处于内核程序临界区（操作系统内） 可调度eg包括主动与被动 方式： 非抢占方式——反之 抢占方式——更紧急的任务优先执行 当前任务中止 适用分时、实时操作系统 包括：选择进程+进程切换 调度器（调度程序）scheduler与闲逛进程idle 触发调度器eg.创建新进程+进程退出+进程阻塞+I/O中断（maybe唤醒阻塞进程） 抢占式调度：时钟中断触发 非抢占式：only阻塞/退出才触发 闲逛进程idle——优先级最低 占一个完整的指令周期（提醒作用） 调度算法评价指标 CPU利用率=利用时间/总时间 系统吞吐量=单位时间内完成作业的数量 周转时间=作业提交至系统-\u0026gt;作业完成的时间 平均周转时间=各作业周转时间和/作业数 带权周转时间=周转时间/实际运行时间（\u0026gt;=1） 平均带权周转时间=带权和/作业数 等待时间=等待处理机状态时间和 for进程：等待被服务的时间 for作业：建立进程后的等待时间+作业在外存后备队列的等待时间 响应时间=提交请求-\u0026gt;首次响应的时间 调度算法 先来先服务FCFS first come first serve 非抢占式 公平 but 长作业有利 短作业不利 不会饥饿（长期得不到服务） 短作业优先SJF shortest job first——当前已到达 运行时间最短 =短进程优先 非抢占（抢占版为最短剩余时间优先算法SRNT 新达到进程/进程完成时 剩余时间最短者抢占当前进程 SRNT平均等待时间、平均周转时间最少 若所有进程几乎同时到达 SJF平均等待时间、平均周转时间最少 时间短 but 不公平 长作业不利 会饥饿 maybe饿死 高响应比优先HRRN highest response ratio next——每次调度时先计算响应比 响应比同先来先服务 响应比=(等待时间+要求服务时间)/要求服务时间 非抢占式 考虑了要求服务时间 不会饥饿\n（适用于交互式系统的调度算法👇） 时间片轮转RR round-robin——根据到达顺序轮流执行一个时间片 only用于进程调度 可抢占式——时钟中断 公平 but 切换频繁\u0026amp;不区分紧急程度 时间片过大——增大进程响应时间 过小——进程切换过于频繁 不会饥饿 优先级——设置优先级：系统\u0026gt;用户 前台\u0026gt;后台 更偏好I/O型（I/O可以和CPU并行工作） 也可用于I/O 非抢占 有抢占式版本 考虑优先级 but 可能导致饥饿 多级反馈队列——设置多级就绪队列 优先级从高到低 时间片从小到大 规则： 新进程先进第1级队列 FCFS分配时间片 时间片用完还未结束 则进入下级队尾（最下级的就进入本级队尾） k级队列为空时 再为k+1级分配时间片 被抢占的进程进入此队队尾 用于进程调度 抢占式（有非抢占式版本） 相对公平 响应快 短进程完成较快 避免用户作假 灵活调整偏好程度 maybe饥饿 多级队列——按进程类型设置不同优先级 队列间可采取固定优先级/时间片划分 各队列可采用不同调度策略 进程同步 互斥等 进程同步与互斥 进程同步——进程的次序（对抗异步性——未知速度） 进程互斥——临界资源（一时段一程序访问）互斥 进入区（检查可否进入 设置正在访问标志）——临界区——退出区（解除标志）——剩余区 临界区空闲则让进 忙则等待 有限等待——能在有限时间内进入临界区 让权等待 进程互斥的软件实现 单标志法——一个flag=允许进入临界区的进程号 空闲让进不符 双标志先检查法——进程数个flag 表达本进程是否进入临界区 忙则等待不符（检查与上锁不是同时发生） 双标志后检查法——先上锁后检查 空闲让进 有限等待不符 Peterson——自己flag为true \u0026amp; 上其它锁 \u0026amp; 若其它flag为true且上锁则自己while空循环等待 进程互斥硬件实现 中断屏蔽——开/关中断指令实现 简单高效 but 不适用多处理机（only单处理机）\u0026amp;特权指令 TS指令 TestAndSetLock——执行过程不允许中断 1 让权等待不符——无法进入的程序会占用CPU并循环TSL指令 SWAP指令（即XCHG）——类TSL指令 1 互斥锁 主要缺点：忙等 需要连续循环忙等的互斥锁 = 自旋锁 适用多处理机系统 信号量机制 用户进程用一对原语对信号量操作\n信号量：变量（整数/记录型变量） 整型信号量——仅初始化、P、V操作 存在忙等 记录型信号量——灵活使用阻塞态 就绪态等 value表示资源的剩余数量 遵循让权等待 1 1 一对原语：wait(S) signal(S) 简称为P、V操作 必成对出现 信号量机制应用 实现进程互斥——value定为互斥信号量mutex（进入临界区的名额） 初值为1 进程同步——保证操作顺序——设置同步信号量S 初值0（反互斥之道而行之） 先V（进程一结束后）后P（进程二开始前）——V释放资源 P获取资源 前驱关系 PV例题 生产者消费者问题 bg：生产者生产一个产品放入缓冲区 消费者每次取出一个产品 缓冲区有大小限制且为临界资源 PV关系：缓冲区空否——同步信号量（初值为n） 满否——同步信号量（初值为0） 访问——互斥信号量 P操作：互斥信号always在同步信号后（不空/满才访问） V：whatever 多生产多消费者 bg：生产者A生产a 消费者C只要c BD同理 缓冲区仅能放有限数量 PV：互斥——访问 同步——几个a/b（For消费者） 同步——还可以放多少（For生产者） 共4个 若缓冲区大小为1 maybe可以不加互斥信号量 吸烟者 bg：3个抽烟者和1个供应者 卷烟需要3种材料 一抽烟者有1种 供应者每次供应2种 1对应抽烟者拿走 PV：互斥——访问 同步——1 2 3是否卷好 可以省略互斥 读者-写者 bg：共享一个文件 可以多个读 一个写则其它均不可 写时让已有的读与写全部退出 PV：互斥——记录读进程个数（互斥访问计数器） 互斥——写锁 读写锁等 哲学家进餐 bg：圆桌 每人两边各有一只筷子 哲学家要么思考要么进食（需要两只筷子） PV：对筷子设置互斥 无限制会死锁——限制最多四人进餐/… 管程 信号量机制——编写程序困难易出错 =\u0026gt; 引入管程替代PV\n组成≈类（过程≈Java中的方法） 特征：管城内的数据只能被其内部的过程访问 + 只有通过管程的过程才能访问内部的共享数据 + 每次仅有一个进程在管程内执行过程 Java中的类似机制：synchronized 被其 修饰的函数在同一时段内只能被一个线程调用 死锁 概述 概念 死锁：各进程互相等待对方的资源 = 都阻塞 管理者的问题 饥饿：长期得不到资源 某进程无法推进 管理者的问题 死循环：进程执行时跳不出循环 条件 互斥——资源使用互斥 不剥夺——其他进程不能强行夺走资源 请求和保持——已经保持了至少一个资源 但还有请求 循环等待——资源的循环等待链 循环等待时不一定会发生死锁 发生死锁的情况 资源竞争 进程推进顺序非法（请求与释放的顺序不当） 信号量使用不当 = 不可剥夺的资源分配不合理\n处理策略 预防（破坏形成条件） + 避免（防止进入不安全状态） + 检测与解除\n预防死锁（静态策略） 互斥条件破坏——改为共享资源 eg.SPOOLing技术 适用范围窄 不剥夺破坏——请求无法满足时释放所有资源/操作系统将资源强行剥夺 复杂+降低吞吐量+maybe饥饿+只适用易保存回复资源 请求保持破坏——静态分配方法（运行前申请所有资源 不满足则不运行 运行后不请求） 资源利用率低 maybe饥饿 循环等待破坏——顺序资源分配法（资源编号 每个进程按编号递增请求资源 同号一次申请完） 难新增资源+资源浪费+编程麻烦 避免死锁（动态策略） 安全序列：按此序列分配资源则每个进程都能完成 安全 = 一定不死锁 不安全 = 不一定死锁 银行家算法：进程申请时 预判分配会否导致不安全 会则阻塞该进程 安全性算法：根据资源分配循环找安全序列 n个进程 m种资源 = n*m矩阵 =\u0026gt;最大需求矩阵Max n*m的分配矩阵Allocation 最多还需要多少资源Need 长m的一维数组Available表示还有多少可用资源 长m的一维数组Request表示本次申请的各种资源\n不断重复上述步骤 检测与解除 检测：保存资源的请求与分配信息（数据结构）+检测是否死锁（算法） 两种边：请求与分配 最终能消除所有边 = “可完全简化” = 一定没有死锁 死锁定理：若不能消除 = 发生死锁 还连着的边 = 处于死锁[^2]: 暂时挂到外存 解除： 资源剥夺法：挂起[^2]某些死锁进程 并将其资源分给其它死锁进程 注意防止饥饿 撤销进程法：强制撤销部分/全部死锁进程 并剥夺资源 代价大 进程回退法：一个/多个死锁进程回退到避免死锁的地步 需设置还原点 进程选择考虑：进程优先级 已执行时间 还要多久完成 已使用多少资源 交互式or批处理式 内存 内存基础 内存中存储程序的最小单位——存储单元 按字节编址 = 每个存储单元大小为1B 1K=2^10^ 1M=2^20^ 1G=2^30^ 逻辑地址（编程时指定的相对地址）转换为物理地址（绝对地址）方法： 绝对装入——编译时指定绝对地址 不存在操作系统时应用 静态重定位（可重定位装入）——装入模块（exe）装入时转换 必分配要求的全部内存空间 运行期间位置不能移动 动态重定位（……）——程序要执行时再进行转换 需要重定位寄存器——寄存装入模块存放的起始位置 允许程序在内存中移动 链接方式 静态链接——运行前链接为装入模块 装入时动态链接——装入内存时 边装入边链接 运行时动态链接——执行时需要某模块才链接 内存管理 概念 功能：内存空间的分配与回收 + 内存空间的扩展 + 地址转换 + 内存保护 内存保护方法： CPU中设置上下限寄存器——限定进程可访问的空间 重定位寄存器（基址寄存器）+界地址寄存器（限长寄存器）=起始物理地址 + 最大逻辑地址 最大逻辑地址判定是否越界异常 起始物理地址确定被查询数据的具体位置 覆盖与交换（内存空间的扩展） 覆盖：不能同时进行的程序段共享同一片覆盖区 一个固定区（程序段不会被调入调出）+若干覆盖区 程序员提前声明 对用户不透明——已淘汰 交换：内存紧张时 内存中某进程暂时换出外存 外存中某进程换入内存 外存（磁盘）包括文件区\u0026amp;对换区——对换区IO速度比文件区更快（对换区主要追求效率） 可优先换出阻塞/优先级低进程/…… PCB常驻内存 不会被换出（储存进程换出在外存的位置） 连续分配管理方式 为进程分配连续的内存空间\n单一连续分配：内存 = 系统区 + 用户区 内存中只能有一个用户程序 无外部碎片 有内部碎片（分配的内存区域有部分没有用上） 固定分区分配——用户空间划分为固定大小的分区 每个分区运行一道作业（分区大小可相同/不相同） 分区说明表（数组/链表表示）：记录分区大小 起始地址 状态等 无外部碎片 but 用户程序过大只能覆盖 会产生内部碎片 动态分区分配（可变分区分配） 动态分区分配的几个问题 空闲分区表/链存储内存使用情况\n…链：空闲分区起始加前向指针 末尾加后向指针 多个空闲分区分配——动态分区分配算法\n分区的分配与回收——简单的修改表项操作\n特点：没有内存碎片 but 有外部碎片\n外部碎片：内存中某些空闲分区因太小而难以利用 可通过紧凑（拼凑Compaction）解决——换入换出 装入方式选择？ 动态重定位 紧凑之后？ 修改起始地址——PCB 也要放入CPU的基址寄存器 动态分区分配算法 首次适应算法：从低地址开始查找 找到第一个满足大小的空闲分区 空闲分区按地址递增的次序排列 算法开销小 性能最好 最佳适应算法：优先使用更小的空闲区 按容量递增次序排列 会产生很多外部碎片 + 算法开销大 最坏适应算法：优先使用最大的连续空闲区 容量递减次序 可能大进程无处安放 + 算法开销大 邻近适应算法：首次适应 + 每次从上次查找结束的位置开始检索 地址递增次序\u0026amp;上次查找结束 高地址的大分区可能被用完 基本分页存储管理（非连续分配管理方式） 分页存储： 内存空间分为大小相等的分区 每个分区就是一个页框 每个页框有编号 即页框号 页框=页帧=内存块=物理块=物理页面 页框号=页帧号=内存块号=物理块号=物理页号 页框号从0开始 进程的逻辑地址空间分为与页框大小相等的部分 每个部分即为页面 每个页面标号为页号 页面=页 页号从0开始 页面与页框一一对应 各页面不必连续存放 页表 通常保存在PCB中\n一进程对应一张页表 进程的每个页面对应一个页表项（=页号+块号） 记录进程页面和实际存放的内存块间的映射关系 问题：每个页表项占多少字节？ 从内存块号范围（如0~2^20^-1）确定（二进制表示至少需要20bit 即内存块号大小） 用B（字节）表示至少3B（1B=8bit） 即至少用3B表示块号 页号不占存储空间——页表项连续存放 问题：如何实现地址转换？ 确定页号+页内偏移量 基本地址变换机构 逻辑地址到物理地址的转换\n注意越界检查——从系统区的PCB调出数据 放到页表寄存器（页表始址 + 页表长度） 页表长度即页表中有多少页表项 实际会拓展页表项大小——最好一个页框能装下整数个页表项（跟进程存储相独立） 具有快表地地址变换机构 快表TLB（联想寄存器translation lookaside buffer）——访问速度比内存快很多的高速缓存（Cache） 非内存（内存中的页表被称为慢表） 存放最近访问的页表项的副本 普通Cache中存放其它内容的副本 在快表中查询是否有需查找的页表项 若未命中则访问内存中慢表——内存中最近访问过的页表项存放到快表中 两级页表 将页表拆分为很多小页表——页目录表存储小页表存放位置 二级页表存放进程页面的存放位置 二级页表可以离散存储 逻辑地址结构 = 一级页号 + 二级页号 + 页内偏移量 各级页表最多存储页表项数量 = 各页面可存放的最多页表项 基本分段存储管理（非连续分配管理方式） 分段：程序自身逻辑划分为若干段 每段有段名（低级语言——汇编语言 按段名编程） 每段从0开始编址 段号位数决定了每个进程最多分多少段 段内地址数决定了每段最大长度 段表：保存逻辑段存放位置 = 段号 + 段长 + 基址（段号隐含 不占内存） 各段表项长度相同 地址变换——段表寄存器（段表始址+段表长度）\u0026amp;段内地址与段长 进行越界中断检查 分页\u0026amp;分段 页是信息的物理单位 对用户不可见 进程地址空间为一维 段是信息的逻辑单位 对用户可见 进程地址空间为二维 更易实现信息共享与保护 不会被修改的代码（即纯代码）才可以共享 段页式管理方式（非连续分配管理方式） 分页分段优缺点：分页不会产生外部碎片 但不能按逻辑实现信息共享 分段反之 段页式 = 先分段 \u0026amp; 每段再分页 逻辑地址结构 = 段号 + 页号 + 页内偏移量 一个段表 + n个页表 页部分对用户不可见 只需指定段号与段内偏移量 检查段号 页号是否越界 虚拟内存（内存的扩充） 局部性原理 时间局部性——某指令/数据若被调用过 不久后很可能再次被调用 空间局部性——某存储单元若被访问过 不久后其附近存储单元很可能被访问 很多数据在内存中连续存放 程序指令也是顺序存放 虚拟内存——很快会用到的部分装入内存 剩下的在外存 + 若执行时某信息不在内存 操作系统将其调入 + 内存不够时将暂时不用的调出 特征： 多次性——无需一次性装入 对换性——作业运行时允许换入换出 虚拟性——逻辑上扩充内存容量 管理：请求分页管理方式\u0026amp;请求分段管理方式\u0026amp;请求段页式管理方式 实现：操作系统提供请求调页功能 + 页面置换功能（For分页 分段类似） 请求分页管理方式 页表机制：操作系统需知页面是否已调入内存/外存存放位置 内存空间不够时进行页面置换——修改过的页面调出覆盖外存中旧数据 未修改的不变 缺页中断：若页面不在内存则产生 缺页的进程阻塞 调页完成后唤醒就绪 中断处理程序需要保存CPU现场 中断信号来自CPU 为内中断 地址变换机构：新增请求调页 \u0026amp; 页面置换 \u0026amp; 修改请求页表中的新增表项 调入的页面对应的表项会直接加入快表 页面置换算法 选择哪个页面被换出\n最佳置换算法OPT：淘汰以后永不使用/最长时间不访问的页面 保证最低缺页率 不可能实现 先进先出FIFO：淘汰最早进入内存的页面 为进程分配的物理块数（内存块）增多时 缺页次数反而增加 = Belady异常 只有FIFO有Belady 性能差 最近最久未使用置换算法LRU：淘汰自上次访问至今时间最长的页面 性能好 but 实现困难开销大 时钟置换CLOCK/最近未用NRU：（简单版）内存中页面用指针链接为循环队列 被访问时访问位设为1 淘汰时遇1置0 遇0淘汰 最多经过两轮扫描进行淘汰页面 未考虑是否修改 改进版时钟置换：设置修改位 0表示未被修改 1表示被修改 优先淘汰(0,0)（访问位，修改位） 二轮淘汰(0,1) 并把扫描过的页面访问位置0 三轮淘汰(0,0)，四轮淘汰(0,1)（访问位均为0，故总有页面被淘汰） 算法开销小 \u0026amp; 性能可 页面分配策略 驻留集 请求分页存储管理中给进程分配的物理块集合\n虚拟存储技术的系统中 驻留集一般小于进程总大小 页面分配置换策略 固定分配 \u0026amp; 可变分配 驻留集大小在进程运行期间是否可变 局部置换 \u0026amp; 全局置换 缺页时 只能选进程自己的物理块进行置换 可选其他进程的物理块/操作系统保留的物理块 固定分配局部置换 难以在初期确定合理的物理块数目 可变分配全局置换——选择未锁定页面换出外存 将其分配（只要缺页就分配新物理块） 被选中的进程缺页率增加 可变分配局部置换——频繁缺页 系统会多分配物理块 调入页面时机 预调页策略——相邻页面调入 主要用于进程首次调入 请求调页策略——缺页时调入 抖动现象（颠簸） 刚换出的页面马上需换入内存\n原因：频繁访问的页面数目高于可用的物理块数（物理块不够） 工作集：某时间间隔里 进程实际访问页面的集合 一般驻留集\u0026lt;工作集 否则会频繁缺页 内存映射文件Memory-Mapped Files 将文件映射到进程的虚拟地址空间——以访问内存的方式访问文件 读入写出由操作系统负责 多个进程可以映射同个文件 实现共享 文件管理 在磁盘（外存）中\n文件的逻辑结构 逻辑结构 For用户（看来 内部数据如何组织） 物理结构 For操作系统（看来 文件数据如何存放在外存）\nflowchart LR 逻辑结构--\u0026gt;无结构文件 逻辑结构--\u0026gt;有结构文件 有结构文件--\u0026gt;顺序文件 有结构文件--\u0026gt;索引文件 有结构文件--\u0026gt;索引顺序文件 顺序文件--\u0026gt;顺序存储 顺序文件--\u0026gt;链式存储 无结构文件（流式文件）——内部数据为一系列二进制流/字符流 eg.txt 有结构文件（记录式文件） 每条记录有一个数据项可作为关键字 定长记录——各条记录长度相等 可变长记录——不等 有结构文件的逻辑结构 各记录排列的顺序\n顺序文件：记录按顺序排列（逻辑上的顺序） 定长/可变长记录 串结构——记录的顺序与关键词无关 顺序结构——记录顺序按关键词顺序 定长记录的顺序文件可实现随机存取 若采用顺序结构可快速找到关键字对应的记录（折半查找） 可变长记录的顺序文件不能随机存取 索引文件（加快文件检索速度）——可变长记录的顺序文件改进 索引表自身为定长记录的顺序文件 可能会占用很大的内存空间 索引顺序文件——索引表改进 将文件数据分组 索引顺序文件储存分组信息 查找：先在索引顺序文件中顺序找分组 后在分组中顺序找记录 多级索引顺序文件——索引顺序文件改进 文件目录 文件控制块FCB——包含文件基本信息 FCB有序集合即为文件目录 目录结构： 单极目录结构 不允许文件重名 两级目录结构 = 主文件目录 + 用户文件目录 允许不同用户的文件重名 多级目录结构（树形结构）——用文件路径名标识文件 eg./users/local/bin 树形结构不便于文件共享 无环图目录结构——增加一些指向同节点的有向边（相当于共享） 可设置共享计数器 索引结点：存放FCB中除文件名外的信息（用索引结点指针存放） 加快查找效率 文件物理结构 磁盘块：磁盘中分为many磁盘块 大小与内存块、页面大小相同 逻辑块号 + 块内地址 = 文件的逻辑地址 连续分配：要求每个文件在磁盘上占有一组连续的块 文件目录需记录文件存放在磁盘中的起始块号\u0026amp;长度（总共占用几块） 优点：支持顺序访问与直接访问 \u0026amp; 顺序读写时速度最快（距离近 磁头移动更快） 缺点：存储空间利用率低 会产生磁盘碎片 链接分配：离散分配 指针链接 隐式链接——必须从上一个逻辑块中读到下一个块的物理地址 只支持顺序读取 but 不会产生碎片 显式链接——链接各物理块的指针显式存放在一张表中（文件分配表FAT File Allocation Table） 一个磁盘仅一张FAT 开机时读入内存并常驻 FAT各表项在物理上连续存储 且长度相同 支持顺序/随机访问 不会产生外部碎片 but FAT需要占用一定存储空间 索引分配：离散分配 每个文件都有一张索引表（记录文件逻辑块对应的物理块） 索引表存放的磁盘块称为索引块（FCB中记录索引块位置） 文件数据存放的称为数据块 索引表过大 解决方案： 链接方案——顺序读取各索引块 多层索引——需多次读磁盘 混合索引——多种索引分配方式结合 eg.有的直接地址索引 有的一级间接（单层索引表） 有的二级间接索引 各级索引表不能超过一个块 文件存储空间管理 存储空间划分与初始化 将物理磁盘划分为文件卷（逻辑卷/逻辑盘） eg.C盘 文件卷包括目录区（存放FCB 存储空间管理的信息等）\u0026amp;文件区 空闲表法——建立空闲表（包括空闲盘块号\u0026amp;空闲盘块数） 分配回收与内存的动态分区分配类似 空闲链表法——空闲盘块链/空闲盘区链（连续的盘块组成盘区） OS保存链头链尾指针 盘区链适用于离散分配\u0026amp;连续分配 位示图法 每一格代表一个盘块 盘块号=ni+j（n为字长 i为字号 j为位号） 空闲标0 不空标1 成组链接法（UNIX采用） 空闲表/链表法不适用于大型文件系统 文件基本操作 创建文件：在外存中找到文件所需空间 + 创建该文件对应的目录项 删除文件：找到目录项 + 回收磁盘块 + 删除目录项 打开文件：找到目录项（检查权限） + 目录项复制到内存中的打开文件表 打开文件表 系统有一总表 各进程也有表（记录读写指针 访问权限 系统表索引号） 关闭文件：进程的打开文件表项删除 + 回收内存 + 系统打开文件总表计数器更改 读/写文件：读/写指针指向外存（文件数据存储处） OS将用户指定的数据读入内存 写回写指针指向的外存数据 文件共享 基于索引结点的共享方式——硬链接 不同用户的目录下索引结点指针指向同一个索引结点 索引结点中设置链接计数变量 基于符号链的共享方式——软链接 创建Link类型文件 根据其记录的路径查找目录 eg.快捷方式 文件保护 口令保护：为文件设置口令（保存在FCB中） 请求访问时验证 口令存放在系统内部 加密保护：对文件原始数据进行加密 eg.异或加密 访问控制：为文件的FCB/索引结点增加访问控制列表(Access-Control List,ACL) 记录各用户可执行的操作 设备管理 I/O设备分类 输入输出\n分类：人机交互类外部设备 + 存储设备 + 网络通信设备 eg.猫 人机…：数据传输速度慢 存储设备：数据传输速度快 分类：低速设备 + 中速设备 + 高速设备 分类：块设备 + 字符设备 以块为单位进行信息交换 eg.移动硬盘 字符设备常采用中断驱动方式 I/O控制器 CPU控制I/O控制器 I/O控制器控制设备的机械部件\n功能： 接收识别CPU命令——控制寄存器存放 向CPU报告设备状态——状态寄存器 数据交换——数据寄存器 地址识别——为寄存器设置地址 组成：CPU与控制器的接口 + I/O逻辑 + 控制器与设备的接口（多个） 各寄存器也可能有多个 寄存器地址分类：内存映像I/O——与内存地址统一编址 寄存器独立编址——使用单独的地址 都储存在内存中 I/O控制方式 程序直接控制方式：数据最后要存储到内存中 CPU干预频繁 每次传送一个字 实现简单 but CPU与I/O只能串行工作 CPU长期处于忙等 中断驱动方式：CPU发出命令后将等待I/O的进程阻塞 切换执行其它进程 I/O完成后发出中断信号 CPU检测到中断信号后处理中断（读一个字） 之后恢复进程运行环境（等待I/O或其它） CPU在每个指令周期末尾检查中断 中断时需要保存进程现有状态 频繁中断效率低 DMA直接存储器存取——主要用于块设备的I/O控制 数据从设备到内存 or 从内存到设备 不经过CPU CPU通过MAR内存地址寄存器等指明存放位置等信息 可读写一个或连续的多个块 CPU只在传送的开始或结束时介入 but 只能读写连续的数据块 通道控制 = 更弱的CPU（硬件） CPU只需发出I/O命令 完成后向CPU发出中断信号 可处理一组块 I/O软件层次结构 know某处理是在哪层完成的 用户层软件：与用户交互 提供库函数进行操作 \u0026amp; 将用户请求转为I/O请求 用系统调用请求内核服务 设备独立性软件（与硬件特性无关的功能） 如：向上层提供系统调用接口\u0026amp;设备保护（如访问权限）\u0026amp;差错处理\u0026amp;设备分配回收\u0026amp;数据缓冲区管理\u0026amp;逻辑、物理设备名映射 不同设备内部硬件特性不同——不同的设备驱动程序 设备驱动程序：对硬件设备的具体控制 将命令转化为特定设备的操作 中断处理程序：I/O任务完成时控制器发送中断信号 系统根据中断信号类型找到中断处理程序 输入输出管理 I/O程序接口： 字符设备接口 get/put系统调用 块设备 read/write seek——在读写指针处操作 网络设备 网络套接字socket接口 eg.localhost:1313 1313即为一个套接字 可与其它ip地址的socket绑定 实现信息传输 阻塞I/O 发出I/O系统调用进程需转为阻塞态 非阻塞I/O不需阻塞等待 设备驱动程序接口——设备独立软件层 I/O核心子系统 I/O调度——类其它调度策略 设备保护——UNIX将设备视为特殊的文件 假脱机技术SPOOLing 用户层软件 模拟脱机技术\n组成：缓冲区与井都暂存数据 位置不同 共享打印机原理——输出井为每个打印请求分配一个存储区（逻辑设备） 设备的分配与回收 设备独立性软件\n设备分配考虑：设备固有属性 设备分配算法 设备分配安全性 分配方法： 静态分配 运行前分配资源 动态分配 过程中分配 分配管理的数据结构 设备控制表DCT 指向COCT的指针 控制器控制表COCT 指向CHCT的指针 通道控制表CHCT 等待队列指针 系统设备表SDT 包括DCT 分配步骤：根据物理设备名找SDT 从SDT找到DCT 到COCT找到控制器 到CHCT分配通道 设备、控制器、通道都分配成功才成功 必须使用物理设备名——难换 \u0026amp; 若正忙进程必须阻塞等待 改进：用逻辑设备名申请 OS用LUT（逻辑设备表）实现名称映射 一张LUT中逻辑设备名不可重复 一般每个用户一张 缓冲区 作用：缓和CPU与I/O设备速度不匹配的矛盾 减少对CPU的中断频率 解决数据粒度不匹配问题（字符/块） 单缓冲：主存中分配缓冲区——非空时不能进数据 空时可以进数据但必须充满 双缓冲：分配2个缓冲区 循环缓冲区：多个大小相等的缓冲区链接为循环队列 缓冲池：系统中共用的缓冲区组成 可分为空缓冲队列 装满输入数据的缓冲队列（输入队列） 输出队列 缓冲区种类：收容输入hin 提取输入sin 收容输出sout 提取输出hout 磁盘 结构 磁盘上一圈为一个磁道 磁道被分为一个个扇区（即磁盘块） 可能有很多盘面 但所有盘面连轴转 每个磁头共进退 各扇区存放数据量相同 读写数据：移到指定磁道 磁盘转动使目标扇区从磁头下划过实现 柱面号-盘面号-扇区号定位磁盘块 柱面：所有盘面中相对位置相同的磁道（下图黄色部分） 分类：活动头磁盘（磁臂可移动） 固定头磁盘（不可动 但有很多磁臂） 也可按盘片可否更换分类 磁盘调度算法 一次读写操作时间： 寻找时间——读写数据前 磁臂移动到指定磁道 延迟时间——旋转磁盘 定位扇区 传输时间——从磁盘读出/写入数据 调度算法： 先来先服务FCFS：进程请求磁盘访问的先后顺序 最短寻找时间优先SSTF：优先处理离当前磁头最近的磁道 可能饥饿 扫描SCAN（电梯算法）：磁头移动到最外侧才能向内动 反之亦然 不会饥饿 but 不同磁道响应频率不平均 LOOK：若在移动方向上无其他请求 可以立即改变磁头移动方向 循环扫描C-SCAN：只有朝固定方向移动时才处理磁道访问请求 返回时直接到起始段 响应频率平均 but 平均寻道时间更长 C-LOOK：移动方向上若无其他请求立即返回 减少延迟时间的方法 读取一块后就需要处理——但磁盘转动不停——下一块要转圈\n交替编号——逻辑上相邻的扇区在物理上有间隔 磁盘地址结构设计： 为什么柱面号在前？ 面对连续的地址如000,00,000-000,01,111 柱面号在前时不用移动磁臂；盘面号在前需移动磁臂 错位命名——改变相邻盘面对应顺序（相邻地址读取时间问题） 磁盘管理（理解） 磁盘初始化： 低级格式化（物理格式化）——划分扇区 分为头、数据区域、尾 磁盘分区——每个分区由若干柱面组成eg.C盘 逻辑格式化——创建文件系统（创建根目录 初始化数据结构eg.位示图） 引导块（启动块/启动分区）——存放完整的自举程序 启动块位于磁盘的固定位置 拥有启动分区的磁盘 = 启动磁盘/系统磁盘eg.C盘 坏块（无法正确使用的扇区） 简单的磁盘可在逻辑格式化时检查并标明 复杂的用磁盘控制器维护坏块链 管理备用扇区 固态硬盘SSD 重点如下\n主要结构： 以页为单位读写 以块为单位进行数据擦除 方可重写每页 先把不需擦除的页复制到其它闪存芯片对应位置 在其它芯片上写后整体移入原芯片 映射的物理位置可以改变 读快写慢 SSD的一个块被多次擦除可能会损坏 磨损均衡技术：将擦除平均分布在各个块上 动态磨损均衡：写入数据时 优先选择累计擦除次数少的新闪存块 静态磨损均衡：SSD分配数据 让老旧闪存块承担以读为主任务 新的以写为主🥳🥳 来自王道408-操作系统\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"操作系统\"\u003e操作系统\u003c/h2\u003e\n\u003ch3 id=\"定义\"\u003e定义\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e系统资源的管理者\u0026amp;提供方便的接口与环境\u0026amp;最接近硬件的软件\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e功能：处理机(CPU)管理\u0026amp;存储器管理\u0026amp;文件管理\u0026amp;设备管理\n\u003cul\u003e\n\u003cli\u003e程序运行 将相关数据从磁盘放入\u003cstrong\u003e内存\u003c/strong\u003e = 存储器\u003c/li\u003e\n\u003cli\u003e进程被CPU管理 = 处理机\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e接口\u0026amp;环境\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart LR\n 接口--\u0026gt;GUI\n 接口--\u0026gt;程序接口\n 用户接口--\u0026gt;程序接口\n 用户接口--\u0026gt;脱机命令接口\n 接口--\u0026gt;命令接口\n 命令接口--\u0026gt;脱机命令接口\n 命令接口--\u0026gt;联机命令接口\n 联机命令接口---交互式命令接口\n 交互式命令接口--\u0026gt;cmd\n 批处理--\u0026gt;.bat\n 脱机命令接口---批处理\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eGUI 图形化用户接口\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e硬件拓展\n\u003cul\u003e\n\u003cli\u003e无软件支持的计算机 = 裸机\u003c/li\u003e\n\u003cli\u003e覆盖了软件 = 扩充机器（虚拟机）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"四个特征\"\u003e四个特征\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发 共享 是最基本的特征 互为存在条件\u003c/p\u003e","title":"操作系统OS"},{"content":" 基础 三要素 数据结构 = 逻辑结构 + 数据运算 + 物理结构 逻辑结构=集合+线性+树形+图状 运算=增删改查 物理结构=存储结构=顺序+链式+索引+散列 存储 时间复杂度排序：O(1) \u0026lt; O(log~2~n) \u0026lt; O(n) \u0026lt; O(nlog~2~n) \u0026lt; O(n^2^) \u0026lt; O(n^3^) \u0026lt; O(2^n^) \u0026lt; O(n!) \u0026lt; O(n^n^) 最坏\u0026amp;平均时间复杂度度量 最深层循环的循环次数与n的关系 乘法规则：相乘后度量 空间复杂度 内存中的变量存储大小 递归\u0026amp;动态规划 递归：选定递归基 + 认定该方法可以解决该问题\n空间复杂度较高 动态规划：部分或完全消除算法中的递归成分（用有限空间记录子问题的解 以避免重复访问子问题） 条件：\n最优子结构（可能适用贪心） 无后效性：已求解的子问题不受后续决策影响 子问题重叠 线性表 相同数据类型 有限序列（有次序） ai中i为位序\n基础 基本操作 InitList(\u0026amp;L) DestroyList(\u0026amp;L) 增删改查: ListInsert(\u0026amp;L,i,e) ListDelete(\u0026amp;L,i,\u0026amp;e) LocateElem(L,e)按值查找 GetElem(L,i)按位查找 Length(L) \u0026amp; PrintList(L) \u0026amp; Empty(L) 传入\u0026amp;：需要用到修改后的值 栈 后进先出 (last in first out,LIFO)\nCpp的STL中stack容器提供成员函数： st.top()返回栈顶 st.push()进栈到顶 st.pop()弹出栈 st.empty() st.size()栈容量 Python模拟栈 st=[1,2,3] st.append(2) # 入栈 st.append(3) # [1,2,3,2,3] st.pop() st.clear() 队列 先进先出 (first in first out,FIFO)\n数组模拟队列 标记队列首尾(ql,qr) 删除元素：ql++ 清空队列：ql=1,qr=0(ql\u0026gt;qr即可) 双栈模拟队列 F为队尾栈 S为队首栈 pop时若S为空 则将F元素弹出后插入S 再进行pop 双端队列 队首队尾均可插入删除元素 Python中容器为collections.deque 循环队列 下标为0的位置视为最后位的后继 队列向数组尾部移动 最终入队即使有空位也会溢出（假溢出） 单调栈与单调队列 保证元素单调性的栈/队列（递增or递减）\n维护一个单增/单减的数组 实现最小/最大值查找\\\n(以单减找最大为例) 新元素与队尾元素比较 若更小则进队 若更大 则从队尾开始将所有比之更小的元素踹出队 lc.239滑动窗口找最大\\ int head=0,tail=-1; int i=0; int[] win=new int[nums.length]; for(;i\u0026lt;k;i++){ while(head\u0026lt;=tail\u0026amp;\u0026amp;nums[win[tail]]\u0026lt;=nums[i]){ tail--; } win[++tail]=i; System.out.println(\u0026#34;now tail is \u0026#34;+tail); } System.out.println(nums[win[head]]); for(;i\u0026lt;nums.length;i++){ while(head\u0026lt;=tail\u0026amp;\u0026amp;nums[win[tail]]\u0026lt;=nums[i]){ tail--; } win[++tail]=i; while(win[head]\u0026lt;=i-k) head++; System.out.println(nums[win[head]]); } 类似还有lc.84/739/862/901/907等可用类似方法\n链表 增删 O(1) 查读 O(n)\n单向链表 指针 + 数据 双向链表 指针（左、右） + 数据 struct Node{ int value; Node *left; Node *right; }; 插入数据 单向链表 new node的next指向p的next node p的next node指向new node node-\u0026gt;value=i; node-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=node; 单向循环链表 首尾相连 插入时判断是否为空 若为空 new node的next指向自己 p指向new node if(p==NULL){ p=node; node-\u0026gt;next=node; } 双向循环链表 判断是否为空 \u0026amp; 修改左右两个指针 非空 node-\u0026gt;left = p; node-\u0026gt;right = p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left = node; p-\u0026gt;right = node; 删除数据 单向循环链表 删除p = p-\u0026gt;next的值给p \u0026amp; 跳过p-\u0026gt;next p-\u0026gt;value = p-\u0026gt;next-\u0026gt;value; Node *t = p-\u0026gt;next; p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; 双向循环链表 p-\u0026gt;left-\u0026gt;right = p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left = p-\u0026gt;left; Node *t = p; p = p-\u0026gt;right; delete t; 哈希表 key-\u0026gt;哈希函数-\u0026gt;索引≈内存位置-\u0026gt;value\n哈希冲突 = 不同key计算的索引相同 拉链法（开散列法）多键值索引到同一位置 在该位置建立链表 闭散列法 所有记录记录在散列表中 发生冲突则根据某方式继续探查 堆 树 每个节点的键值都大于等于/小于root节点的键值\n大于等于的为最小化堆 反之为最大化堆（左子大于右子）\n二叉堆 结构：完全二叉树（以下以最大化堆为例） 插入：最下层最右叶子插入 向上调整 复杂度O(logn) 删除（root）：root与最后的节点交换 向下调整 向下调整 = 子节点中最大的与新root交换 复杂度O(logn) 实现：在序列中 Hi的子节点为H2i与H2i+1 void up(int x) { while (x \u0026gt; 1 \u0026amp;\u0026amp; h[x] \u0026gt; h[x / 2]) { std::swap(h[x], h[x / 2]); x /= 2; } } void down(int x) { while (x * 2 \u0026lt;= n) { t = x * 2; if (t + 1 \u0026lt;= n \u0026amp;\u0026amp; h[t + 1] \u0026gt; h[t]) t++; if (h[t] \u0026lt;= h[x]) break; std::swap(h[x], h[t]); x = t; } } 建堆：向上/向下调整 向上调整 从叶子开始向堆上部移动 复杂度O(nlogn) 向下调整 从root开始向堆下部移动 复杂度O(n) 二叉树 二叉搜索树 左子\u0026lt;root\u0026lt;右子\n删除元素：若有两个非空子节点 用左子树的最大值/右子树的最小值代替它后删除\n平衡树 每个节点的左子树和右子树高度差最多为1\n调整过程 右旋 root左子成为新root root成为新root的右子 新root原右子成为root左子 TreeNode* newRoot = root-\u0026gt;left; root-\u0026gt;left = newRoot-\u0026gt;right; newRoot-\u0026gt;right = root; 四种平衡破坏情况 LL RR省略 LR 左子的右子树过长 RL 右子的左子树过长（类上） AVL树 平衡的二叉搜索树\n性质：\nAVL的左右子树也是AVL树 且左右子树高度相差不大于1（平衡因子 = 右子树高 - 左子树高） 树高logn 调整：若平衡因子=-2 == 左子左旋后root右旋 B树 每个节点可以拥有两个以上的子节点 增删改查在对数时间完成\n最下层的节点称为叶子节点 性质：（m阶）\n每个节点最多有m个子节点 非叶子节点（除root）最少有m/2个子节点 若root不是叶子节点 则至少有2个子节点 排序 冒泡排序 对序列逐个扫描 n次扫描后排序完毕\n最坏\u0026amp;平均情况下时间复杂度O(n^2^) 最好情况下时间复杂度O(n)\nbool flag = true; while (flag) { flag = false; for (int i = 1; i \u0026lt; n; ++i) { if (a[i] \u0026gt; a[i + 1]) { flag = true; int t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; } } } 插入排序 最坏\u0026amp;平均情况下时间复杂度O(n^2^) 最好情况下时间复杂度O(n)\\\n从头开始遍历每个需插入的数据 与其前已排序的数据的末尾向头逐一比较 for (int i = 1; i \u0026lt; len; ++i) { int key = arr[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } 折半插入 二分算法优化 时间复杂度不变 快速排序 将数列划分为2parts 递归到两子序列中进行快排 = 挖坑填数\n最优/平均时间复杂度O(nlogn) 最坏O(n^2^)\n若选第一个数为基准数 数组首尾两指针 i\u0026amp;j\n从j开始向前找小于或等于基准数的 放到原基准数的位置\n从i开始向后找大于基准数的 放到原j的位置\n以此循环 最后i=j放入基准数\n在前后两parts再继续进行以上步骤\n三数取中：前中后三个数先排序——中与后换——从 前 到 后的前一个 进行大小判断（前指针先动）——后和指针位置处数字交换——重复\n排序后再选pivot void quick_sort(int s[],int l,int r){ if(l\u0026lt;r) { int i=l,j=r,base=s[l]; while(i\u0026lt;j){ while(i\u0026lt;j\u0026amp;\u0026amp;s[j]\u0026gt;base) j--; if(i\u0026lt;j){ s[i++]=s[j]; } while(i\u0026lt;j\u0026amp;\u0026amp;s[i]\u0026lt;=base) i++; if(i\u0026lt;j){ s[j--]=s[i]; } } } s[i]=base; quick_sort(s,l,i-1); quick_sort(s,i+1,r); } 优化：\n三路快速排序 三路取中（首、中、尾三元素进行比较后选择base） 与base相等的元素聚集在其周边 短序列用插排 归并排序 时间复杂度O(nlogn) 空间复杂度O(n)\n特殊应用 康托展开 数学方法 详见wiki\n应用：LC.60排列排序permutation-sequence\n","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"三要素\"\u003e三要素\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e数据结构 = 逻辑结构 + 数据运算 + 物理结构\n\u003cul\u003e\n\u003cli\u003e逻辑结构=集合+线性+树形+图状\u003c/li\u003e\n\u003cli\u003e运算=增删改查\u003c/li\u003e\n\u003cli\u003e物理结构=存储结构=顺序+链式+索引+散列 存储\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e时间复杂度排序：\u003ccode\u003eO(1) \u0026lt; O(log~2~n) \u0026lt; O(n) \u0026lt; O(nlog~2~n) \u0026lt; O(n^2^) \u0026lt; O(n^3^) \u0026lt; O(2^n^) \u0026lt; O(n!) \u0026lt; O(n^n^)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e最坏\u0026amp;平均时间复杂度度量\u003c/li\u003e\n\u003cli\u003e最深层循环的循环次数与n的关系\u003c/li\u003e\n\u003cli\u003e乘法规则：相乘后度量\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e空间复杂度 内存中的变量存储大小\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"递归动态规划\"\u003e递归\u0026amp;动态规划\u003c/h3\u003e\n\u003cp\u003e递归：选定递归基 + 认定该方法可以解决该问题\u003c/p\u003e","title":"数据结构"},{"content":" 存储引擎 MySql体系结构 MySql服务器 flowchart LR 连接层--\u0026gt;服务层 服务层\u0026lt;--\u0026gt;SQL接口 服务层\u0026lt;--\u0026gt;解析器 服务层\u0026lt;--\u0026gt;查询优化器 服务层\u0026lt;--\u0026gt;缓存 SQL接口--\u0026gt;d((可插拔式存储引擎)) 解析器--\u0026gt;d 查询优化器--\u0026gt;d 缓存--\u0026gt;d d--\u0026gt;存储层 存储引擎包括InnoDB等，Index信息也存储在其中 存储层存储系统文件、文件和日志等 存储引擎 存储引擎简介 存数据、建索引、更新数据等的实现方式，基于表不基于库（被称为表类型）\n建表时指定存储引擎\nCREATE TABLE 表名( … \\)ENGINE=INNODB … SHOW ENGINES; 显示支持的存储引擎\n存储引擎特点 InnoDB DML操作遵循ACID模型 支持事务 行级锁 提高并发访问性能 支持外键 以.idb表空间文件存储该表的表结构(frm sdi)、数据与索引 用cmd打开 idb2sdi ***.idb 查看表结构 数据段即为B+树的叶子节点 索引段为非叶子节点 flowchart LR Tablespace--\u0026gt;Segment--\u0026gt;Extent--\u0026gt;Page--\u0026gt;row 表空间--\u0026gt;段--\u0026gt;区--\u0026gt;页--\u0026gt;行 MyISAM 不支持事务 外键 支持表锁 不支持行锁 访问速度快 ✕✕.sdi 存储表结构信息 ✕✕.MYD 存储数据 ✕✕.MYI 存储索引 Memory 存储在内存中 只做临时文件\n内存存放 hash索引 ✕✕.sdi 存储表结构 比较 特点 InnoDB MyISAM Memory 事务安全 支持 - - 锁机制 行锁 表锁 表锁 支持外键 支持 - - B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持 支持 - 空间使用 高 低 N/A 内存使用 高 低 中 批量插入速度 低 高 高 选择 InnoDB 事务完整性\u0026amp;并发条件 各种操作都很多 MyISAM 以读\u0026amp;插入操作为主 少更新\u0026amp;删除 对事务的完整性与并发性要求不高(被ControlDB取代) Memory 临时表的缓存 对表的大小有限制 安全性没有保障(被Redis取代) 索引 索引概述 帮MySql高效获取数据的数据结构（有序） 在存储引擎中实现 优点： 提高查询效率 降低IO成本 降低排序成本 降低CPU消耗 缺点： 占用磁盘空间 降低更新表的速度 索引结构 主要索引： 索引结构 描述 B+Tree索引 大部分引擎都支持 最常见 Hash索引 不支持范围查询 精确匹配索引列的查询才有效 R-Tree(空间索引) MyISAM的特殊索引 用于地理空间数据类型 Full-text(全文索引) 建立倒排索引 快速匹配文档 支持引擎： 索引 InnoDB MyISAM Memory B+Tree 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree 不支持 支持 不支持 Full-text 支持 支持 不支持 一般索引直接指B+Tree索引 B+Tree\u0026amp;其它Tree 二叉树：左子小于亲点 右子大于亲点 顺序插入时会形成链表 大数据量下 层级较深 效率低 红黑树：新数据会先与根节点判断大小 大数据量下 层级较深 B Tree(多路平衡查找树)： 最大度数为n，最多n个子节点，每个节点最多存储n-1个key(元素)，n个指针 中间节点向上分裂 B+Tree 所有元素都会出现在叶子节点(树只起到索引作用) 所有叶子节点形成单向链表 B+Tree in MySql 增加了指向相邻叶子节点的链表指针 形成带顺序指针的B+Tree 一页(一个磁盘块)只存放指针和key不存放数据，则一页上可以存放的指针与key相比BTree更多，故层级更少 Hash 键值换算成新的hash值 映射到对应槽位 存储在hash表中 hash冲突(多个键值映射到同个槽位)时用链表解决 特点： 只能用于对等比较 不支持范围查询 无法利用索引进行排序 查询效率高 通常只需一次检索 通常效率高于B+Tree 索引分类 分类： 索引 含义 特点 关键字 主键索引 针对主键创建的 默认自动创建 onlyone PRIMARY 唯一索引 避免同表中某列数据的值重复 可有多个 UNIQUE 常规索引 快速定位特定数据 可多个 全文索引 查找文本关键词 非比较索引中的值 可多 FULLTEXT 根据索引的存储形式分类： 聚集索引 将数据存储与索引放到一起 索引的叶子节点保存行数据(有且仅有1个) 聚集索引选取规则：主键\u0026gt;第一个唯一索引\u0026gt;innoDB生成rowid作为隐藏聚集索引 二级索引 将数据与索引分开存储 叶子节点关联对应主键(可有多个) 如建立name的索引 叶子节点即存储id 回表查询 eg.查询Satti的所有信息 先二级索引查主键 后聚集索引查row信息 索引语法 CREATE [UNIQUE/FULLTEXT] INDEX 索引名 ON 表名 (字段名,…); 创建索引 字段名后可指定升降序建立索引 索引名一般为 idx_表名_字段名1_字段名2 可以关联多个字段 SHOW INDEX FROM 表名[\\G]; 查看索引 \\G可以把以行显示的索引转换为列显示 DROP INDEX 索引名 ON 表名; 删除索引 SQL性能 性能分析 SHOW GLOBAL STATUS LIKE'Com____' 查询命令(Delete等)执行频次 SHOW GLOBAL STATUS提供服务器状态 7个下划线 慢查询日志 记录超过指定时间的SQL语句 SHOW VARIABLES LIKE'SLOW_QUERY_LOG‘; 检查慢查询日志是否开启 开启慢查询日志： 在MySql配置文件/etc/my.cnf中配置\n#开启慢查询 slow_query_log=1\n#设置慢日志时长\nlong_query_time=2 查看记录信息 /var/lib/mysql/localhost-slow.log profile详情 SELECT @@have_profiling; 是否支持profile操作 开启profile SET PROFILING=1 SHOW PROFILES; 查看所有指令耗时 SHOW PROFILES [CPU] FOR QUERY query号; 查看某个query的耗时(与cpu消耗) explain执行计划 在select语句前加 desc 或 explain id select查询的序列号（操作顺序） id相同 顺序从上到下 id不同 值越大越先执行 type 性能指标从好到差： NULL\u0026gt;system\u0026gt;const(以上较好)\u0026gt;eq_ref\u0026gt;ref\u0026gt;range\u0026gt;index\u0026gt;all 主键/唯一索引==const possible_key 可能用到的索引 key 实际用到的索引 key_len 索引字段最大可能长度 rows 预估执行查询的行数 filtered 返回结果行数占读取行数的比例(越大越好) 索引使用原则 最左前缀法则 联合索引时遵守\n查询从索引的最左列开始 且不跳过索引中的列（即从联合索引的第一个字段开始） 若跳过索引中某字段 则后面的字段失效 范围查询 联合索引时遵守\n即\u0026gt; \u0026lt;等范围限定 若出现 其右侧列索引失效 若使用\u0026gt;=或\u0026lt;=则不存在此问题 失效问题 索引列运算 若对索引中的字段进行运算 索引失效 包括substring等 字符串不加引号 字符串类型字段若不加引号 索引失效 模糊查询 尾部模糊查询 不失效 头部模糊查询 索引失效 or连接 or中一条件中的字段有索引 + 另一列无索引 = 索引失效 数据分布影响 如索引效率不如全表扫描时 启用全表扫描 SQL提示 EXPLAIN select语句 USE INDEX(索引名) 建议使用某索引 EXPLAIN select语句 IGNORE INDEX(索引名) 不用某索引 EXPLAIN select语句 USE INDEX(索引名) 必用某索引 覆盖索引 需要返回的列在索引中可全部找到 \u0026ldquo;using where;using index\u0026rdquo; 在列 \u0026ldquo;using index condition\u0026rdquo; 需回表查询 前缀索引 字段类型为varchar text等 需索引很长字符串——前缀索引 CREATE INDEX 索引名 ON 表名(COLUMN(N)); 创建前缀索引 N为前缀长度 选择性计算：COUNT(DEISTINCT SUBSTRING(字段名,m,n))/COUNT(\\)* 根据选择性取舍选择N的大小 单列与联合索引的选择 业务场景中存在多个查询条件 建议采用联合索引 单列易产生回表查询 索引设计原则 数据量较大（\u0026gt;几十万） 查询频繁 常作为where、order by、group by条件的字段 区分度高的列（相对唯一 如身份证号等） 若为字符串类型 字段长度较长——前缀索引 尽量使用联合索引 控制索引数量 若索引列不能有NULL 建表时即规定NOT NULL 便于优化器选用索引 SQL优化 插入优化 基本优化 批量插入(500-1000条) 手动提交事务 主键顺序插入 大批量插入数据\n# 客户端连接服务端时加\u0026ndash;LOCAL-INFILE\nMYSQL --LOCAL-INFILE -U ROOT -P;\n# 设置全局参数为1 允许从本地加载文件导入数据\nSET GLOBAL LOCAL_INFILE=1;\n# 执行load加载数据\nLOAD DATA LOCAL INFILE '数据地址' INTO TABLE '表名' FIELDS TERMINATED BY ',' LINES TERMINATED BY '\\n'; linux命令行：head 文件名查看文件前十行 主键优化 数据组织方式 InnoDB中 表数据按主键顺序组织存放 此种表即为索引组织表(IOT) 页分裂 （页中存放的是行数据）\n每个页包含2~n个数据（若1个 则相当于一个链表） 根据主键排列 若乱序插入 可能发生页分裂 前一页后50%部分与新数据挪至新页 新页插入前一页与后一页间 页合并 当页中删除的row达到MERGE-THRESHOLD（默认50%） InnoDB会寻找靠近的页进行合并 MERGE-THRESHOLD 合并页的阈值 可自定义 主键设计原则 尽量降低主键长度（占用的字节大小） 尽量顺序插入（自增主键） 尽量不用UUID（通用唯一识别码）或其它自然主键（如身份证号）为主键 因为无序 避免修改主键 order by优化 Extra显示 Using index 通过索引排序 Using filesort 不可通过索引直接返回排序结果 索引升序创建时 若倒序排序则需filesort 优化 根据排序字段建立合适索引 多字段排序时也遵循最左前缀 尽量使用覆盖索引\u0026amp;注意升降序设定 不可避免出现filesort大数据量排序时 适当增加排序缓冲区sort_buffer_size大小 group by优化 extra显示 Using temporary 使用临时表（性能低） Using index 使用索引 满足最左前缀 limit优化（分页） limit不能用在in/all/any/some子语句中==多表查询 将limit的结果视为新表 覆盖索引 + 子查询 原表与分页查到的主键id表联合查询name等索引覆盖的字段 count优化 MyISAM将表的总行存在磁盘中 效率高 InnoDB需将数据从引擎中读出后累计计数 优化思路 自己计数（设定计数器cnt） 用法 count(*) 不取值 直接累加 count(主键) 取主键id值 按行累加 主键不可能为NULL count(字段) 字段为NULL时 count不加1 字段有not null约束时 不需判断null count(1) 可以取-1等 服务层对返回的每一行放1（或-1）进去 后逐行累加 效率：字段 \u0026lt; 主键id \u0026lt; 1 \u0026lt; * update优化 update优先行锁（有索引字段时 锁住该行）若无索引 执行表锁 InnoDB的行锁针对索引 视图 虚拟存在的表 只保存查询的逻辑不保存结果\n视图语法 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED |LOCAL] CHECK OPTION]\n创建视图（OR REPLACE或替换视图） SHOW CREATE VIEW 视图名\n查看创建视图语句\nSELECT * FROM 视图名\n查看视图 类似表 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED/LOCAL] CHECK OPTION]\n修改视图（REPLACE为主要）\nALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED/LOCAL] CHECK OPTION]\n修改视图 DROP VIEW [IF EXISTS] 视图名称 删除视图 检查选项 WITH [CASCADED/LOCAL] CHECK OPTION 使之后对视图进行的增删改操作符合视图最初的定义 CASCADED/LOCAL 检查依赖视图的规则 保持一致性 二者限定的范围不同 CASCADED （若v1未指定视图检查 但为v2的依赖视图 也会检查v1）检查所有亲辈的限制 无论其是否指定 LOCAL 若v1未指定 则不检查v1 视图更新 可更新的视图：视图中的行与基础表的行一一对应 包含 聚合/DISTINCT/GROUP BY/HAVING/UNION/… 的视图不可更新 视图作用 简单 简化理解\u0026amp;操作（复杂且多次使用到的检索可以形成视图） 安全 可以只查看某表的部分内容（授权只能精确到表） 数据独立 屏蔽基表变化对查看信息带来的影响 存储过程 SQL语言的代码封装与重用\n特点 封装 复用 可以接收参数 返回数据 减少应用途径与数据库间的网络交互 提升效率 语法 创建存储过程 CREATE PROCEDURE 存储过程名([参数列表])* BEGIN ——SQL语句 END; 命令行中解决遇 ; 即停问题：用delimiter 某符号指定语句结束位置 在DataGrip中存储为routines 中文“例程”\nCALL 存储过程名([参数列表]) 调用存储过程 SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='表名';\n查询指定数据库的存储过程与状态\nSELECT CREATE PROCEDURE 存储过程名\n查询某存储过程的定义 DROP PROCEDURE 存储过程名 删除存储过程 变量 系统变量 由服务器提供 分为全局变量GLOBAL与会话变量SESSION（仅在当前会话 即当前控制台 生效） 默认SESSION 系统重启后全局参数失效 可在/etc/my.cnf中配置 SHOW [SESSION/GLOBAL] VARIABLES;\n查看所有系统变量\nSHOW [SESSION/GLOBAL] VARIABLES LIKE '…';\n模糊匹配\nSELECT @@[SESSION/GLOBAL] 系统变量名;\n查看指定变量的值 系统变量用@@ SET [SESSION/GLOBAL] 系统变量名=值\nSELECT @@[SESSION/GLOBAL] 系统变量名=值\n设置系统变量 SET SESSION AUTOCOMMIT =0 切换到手动提交 用户自定义变量 不用提前声明 通过“@变量名”使用(未定义时调用返回null) 作用域为当前\nSET @变量名=值;\nSET @变量名:=值;\nSELECT @变量名=值;\n赋值 可多个同时赋值\nSELECT 字段名 INTO @变量名 FROM 表名; 将字段名结果赋值给变量 SELECT @变量名 使用变量 局部变量 作用域在begin…end块之间 先声明后调用\nDECLARE 变量名 变量类型 [DEFAULT …]; 声明（有否默认值） SET 变量名 := 值\nSELECT 字段名 INTO 变量名 FROM 表名;\n为变量赋值 条件判断\u0026amp;循环 if IF 条件1 THEN …; ELSEIF 条件2 THEN …; ELSE …; END IF; 用SELECT语句显示返回值\n参数 类型 类型 含义 备注 IN 输入 调用时传入值 默认 OUT 输出 可为返回值 INOUT 输入\u0026amp;输出 CREATE PROCEDURE 存储过程名([IN/OUT/INOUT 参数名 参数类型]) case CASE [变量] WHEN … THEN …; … ELSE … END CASE; while WHILE 条件 DO SQL逻辑 END WHILE 条件为true时进行 repeat REPEAT SQL逻辑 UNTIL 条件 END REPEAT 先执行一次逻辑 若条件满足则停止循环 loop [begin_label:] LOOP … END LOOP [end_label]; 配合语句： LEAVE LABEL; 退出循环 ITERATE LABEL; 只可在循环中使用 跳过当前循环剩下的语句进入下一次循环 游标\u0026amp;条件处理程序 游标 暂时存储查询结果集的数据类型（集合）\nDECLARE 游标名 CURSOR FOR 查询语句; 声明游标 OPEN 游标名 打开游标 FETCH 游标名 INTO 变量; 获取游标记录（可以是多个变量） CLOSE 游标名 关闭游标 使用游标记录结果集 开启游标通过循环获取游标内的数据 条件处理程序 定义在流程控制结构执行过程中遇到问题的处理步骤\nDECLARE 处理动作 HANDLER FOR 状况值 … statement; 处理动作： CONTINUE 继续执行当前程序 EXIT 终止 状况值： SQLSTATE 状态码 可用下列替代 SQLWARNING（01开头的状态码） NOT FOUND（02开头的状态码） SQLEXCEPTION（除以上两种的其它） 存储函数 有返回值 参数必为IN类型（应用少）\nCREATE FUNCTION 存储函数名([参数列表]) RETURNS 数据类型 [characteristic] BEGIN ——SQL语句 END; characteristic：（二级日志开启 默认需加）\nDETERMINISTIC 相同输入产生相同结果 NO SQL 不包含SQL语句 READ SQL DATA 包含读取数据的语句 不包含写入数据的语句 触发器 触发器定义 与表有关的数据库对象。在insert/update/delete之前或之后，触发并执行其定义的语句（多为记录数据变更日志） OLD与NEW引用触发器中发生变化的记录内容 如insert用NEW；update用OLD（引用需修改的内容）与NEW（引用修改后的内容） 只支持行级触发器 不支持语句级触发 触发器语法 CREATE TRIGGER 触发器名 BEFORE/AFTER INSERT/… ON 表名 FOR EACH ROW——行级触发器 BEGIN 语句（将修改的内容放入新建的日志表中） END; 创建触发器 “语句”为将新操作记录插入日志表（自建） 可以记录插入的详细信息 用 concat() 拼接字符串 SHOW TRIGGERS; 查看触发器 DROP TRIGGER [数据库名.]触发器名; 删除触发器 锁 概述 协调多进程或线程并发访问某资源的机制 事务中进行 分类 全局锁 数据库中所有表 表级锁 行级锁 全局锁 通常用做全数据库的逻辑备份\n语法 FLUSH TABLES WITH READ LOCK 加全局锁 MYSQLDUMP -UROOT -P1234 数据库名\u0026gt;保存地点 备份数据库 在命令行中运行 非mysql语句 用户名root 密码1234 UNLOCK TABLES 释放锁 特点（不重要） 若主库备份 备份期间不能更新主库 若从库备份 备份期间从库不能执行主库同步来的二进制日志 导致主从延迟 MYSQLDUMP --SINGLE-TRANSACTION -UROOT -P1234 数据库名\u0026gt;保存地点 不需加全局锁的备份 表级锁 锁定粒度大 发生所冲突的概率最高 并发度最低\n分类： 表锁 元数据锁 意向锁 表锁 分类： 表共享读锁 表独占写锁 LOCK TABLES 表名… READ/WRITE 加锁 读锁 所有客户端都可读 不可写 写锁 当前客户端可读 / 写 其他客户端不可读 / 写 UNLOCK TABLES 释放锁 元数据锁(meta data lock,MDL) 系统自动控制\n维护表元数据的数据一致性==表上有活动事务时不可对元数据进行写入 避免DML与DDL冲突 MySql5.5后 DML增删改查加读锁 DDL对表结构变更加写锁 SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM PERFORMANCE_SCHEMA.METADATA_LOCKS; 查看元数据锁 意向锁 使表锁不用检查每行数据是否加行锁 避免DML执行时行锁与表锁冲突 分类： 意向共享锁(IS) 意向排他锁(IX) SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM PERFORMANCE_SCHEMA.DATA_LOCKS;\n查看锁 日志中RECORD锁类型代表行锁 意向锁间不互斥\nIS 意向共享锁 由SELECT语句 LOCK IN SHARE MODE添加 与表锁共享读锁(read)兼容 与表锁排它写锁(write)互斥 IX 意向排他锁 由增删改语句 FOR UPDATE添加 与表锁共享读锁(read)互斥 与表锁排它写锁(write)互斥 行级锁 锁定粒度最小 锁冲突改率最低 并发度最高 在InnoDB存储引擎中应用\n分类： 行锁 锁定单个行记录——在RC RR隔离级别下都支持（包括共享锁与排他锁） 间隙锁 确保索引记录间隙不变 防止insert产生幻读——在RR下支持 临键锁 行锁+间隙锁（该行之前的间隙）——RR下支持 行锁类型 SQL 行锁类型 说明 增删改 排他锁 自动加 SELECT语句 无锁 SELECT加共享锁 共享锁S 手动 SELECT…FOR UPDATE 排他锁X 手动 行锁 InnoDB使用next-key（临键锁）进行搜索与索引扫描 以防止幻读\n针对唯一索引检索时 对存在的记录进行等值匹配（通过 “=” 检索）时会自动将next-key锁优化为行锁 InnoDB中不通过索引检索数据会升级为表锁 间隙锁\u0026amp;临键锁 理解 唯一索引的等值查询 给不存在的记录加锁时 优化为间隙锁 普通索引的等值查询 向右遍历到最后一个值不满足查询需求时 临键锁退化为间隙锁 唯一索引的范围查询 访问到不满足条件的第一个值为止（加锁） 间隙锁可以共存（只为防止其它事务插入间隙so） InnoDB引擎 理解 整体架构 内存架构 直接操作\n缓冲池 Buffer Pool Change Buffer 对非唯一的二级索引进行修改 操作存储在此（先到缓冲池 后到磁盘） Adaptive Hash Index 优化对缓冲池数据的查询(自动生成) 用SHOW VARIABLES LIKE '%HASH_INDEX%';查看其是否启用（模糊匹配） Log Buffer 日志缓冲区 保存要写入磁盘的log INNODB_LOG_BUFFER_SIZE查看大小 INNODB_FLUSH_LOG_AT_TRX_COMMIT刷新到磁盘的时机（可设置0 1 2 具体含义略） 磁盘结构 System Tablespaces系统表空间 主要存放Change Buffer %DATA_FILE_PATH%模糊匹配 General Tablespaces通用表空间 需在创建表时指定 CREATE TABLESPACE创建该表空间 Undo Tablespaces撤销表空间 自动创建两个 Temporary Tablespaces临时表空间 DoubleWrite Buffer Files双写缓冲区（缓冲池刷新到磁盘前先写入此） Redo Log重做日志 实现事务持久性（包括重做日志缓冲 储存在内存中） 后台线程 将缓冲区数据刷新到磁盘中\nMaster Thread核心后台线程 调度其他线程 IO Thread 负责IO请求的回调 Purge Thread 回收事务已提交的undo log Page Cleaner Thread减轻主线程刷新脏页的压力 事务原理 redo log 刷新脏页到磁盘发生错误时进行数据恢复（物理日志） undo log 回滚日志（逻辑日志） 记录数据被修改前的信息 MVCC需要 MVCC⭐ 多版本并发控制 Multi-Version Concurrency Control\n基本概念 当前读 读取记录数据的最新版本并对记录加锁 共享锁/排他锁/增删改 快照读 读取记录数据的可见（历史）版本 不加锁 RC隔断下 每次select生成一个快照读 RR 开启事务后第一个select才是快照读 S 快照读退化为当前读 MVCC 维护一个数据的多个版本 使读写操作没有冲突 快照读为其提供非阻塞读功能 依赖于： 数据库记录中的三个隐式字段 undo log readView 实现原理 三个隐式字段 （InnoDB隐式生成）\n隐藏字段 含义 DB_TRX-ID 最近修改事务ID DB_ROLL_PTR 回滚指针 指向这条记录的上个版本 配合undo log DB_ROW_ID 隐藏主键 若无指定主键则生成此字段 undo log日志（增删改时产生便于数据回滚的日志）\ninsert 只在回滚时需要log 事务提交后可被删除 删改 在回滚与快照读时需要（不会被立即删除） 生成undo log版本链 头部是最新的历史记录 尾部是最旧的历史记录 ReadView 记录并维护系统当前活跃（未提交）的事务id（MVCC提取数据的依据）\n四个核心字段 字段 含义 m_ids 当前活跃事务ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID（当前最大事务ID+1 自增） creator_trx_id ReadView创建者的事务ID 版本链数据访问规则（当前事务ID为trx_id 即DB_TRX_ID）理解 只可符合下列四个条件 若都不符合 则换下一条undo log trx_id==creator_trx_id ✔ 说明数据由当前事务更改 trx_id\u0026lt;min_trx_id ✔ 说明数据已提交 trx_id\u0026gt;max_trx_id ✖ 事务在RV生成后才开始 min_trx_id\u0026lt;=trx_id\u0026lt;=max_trx_id 且trx_id不在m_ids中 ✔ 说明数据已提交 RC隔离级别 事务中每次执行快照读时生成ReadView RR隔离级别 事务中第一次执行快照读时生成 后复用 MySql管理 系统数据库 自带四个数据库 数据库 作用 mysql 服务器运行需要的信息（时区 主从 用户 权限等） information_schema 访问元数据的表、视图等 performance_schema 底层监控服务器运行状态 收集其性能参数 sys 方便DBA 便于性能调优与诊断的视图 常用工具 MySQL 数据库名 -e \u0026quot;执行语句\u0026quot; -e执行sql语句并退出 适用于shell脚本 mysqladmin -uroot -p****** … 查看帮助文档并进行相关操作 mysqlbinlog log1 查看二进制日志文件 mysqlshow … 查找数据库/表/列/索引等 mysqldump [options] db_name备份数据库 mysqllimport或source 客户端数据（mysqldump加-T参数导出的文本文件）导入 🎉🎉 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/mysql/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"存储引擎\"\u003e存储引擎\u003c/h2\u003e\n\u003ch3 id=\"mysql体系结构\"\u003eMySql体系结构\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eMySql服务器\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart LR\n连接层--\u0026gt;服务层\n服务层\u0026lt;--\u0026gt;SQL接口\n服务层\u0026lt;--\u0026gt;解析器\n服务层\u0026lt;--\u0026gt;查询优化器\n服务层\u0026lt;--\u0026gt;缓存\nSQL接口--\u0026gt;d((可插拔式存储引擎))\n解析器--\u0026gt;d\n查询优化器--\u0026gt;d\n缓存--\u0026gt;d\nd--\u0026gt;存储层\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e存储引擎包括InnoDB等，\u003c!-- raw HTML omitted --\u003eIndex\u003c!-- raw HTML omitted --\u003e信息也存储在其中\u003c/li\u003e\n\u003cli\u003e存储层存储系统文件、文件和日志等\n\u003cimg loading=\"lazy\" src=\"2.jpg\" alt=\"系统结构图\"  title=\"系统图\"  /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"存储引擎-1\"\u003e存储引擎\u003c/h3\u003e\n\u003ch4 id=\"存储引擎简介\"\u003e存储引擎简介\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e存数据、建索引、更新数据等的实现方式，基于表不基于库（被称为表类型）\u003c/p\u003e","title":"MySql"},{"content":" 简介 NoSql 非关系型数据库 No Structured Relational\n特点： 表型 JSON型 图型==非结构化 Redis为键值类型 JSON表==数据无关联 查询方式==非SQL（语法不统一） 事务ACID无法全部满足==BASE 存储==内存 使用场景： 数据结构不固定 对一致性 安全性要求不高 性能要求 Redis 特征： 键值型 key-value 支持多种数据结构 单线程 命令具原子性 低延迟 内存 IO多路复用 编码风格 支持数据持久化 支持主从集群 分片集群（主表\u0026amp;从表） 多语言客户端 redis-cli -h 192.168.211.129 -p 6379 -a 密码\n启动（不安全） systemctl stop redis关闭 连接虚拟机与图形化界面失败=检查防火墙\n基本语法 不区分大小写\n数据结构 value类型 基本类型：String Hash List（可重复） Set SortedSet（排序集合 不可重复） 特殊类型：GEO（地理坐标） BitMap HyperLog 帮助文档 or 命令行 help\n通用命令 用help 命令名查看命令的具体使用方法\nKEYS查看符合模板a**的所有key 慢 DEL删key 会返回删除的个数 EXISTS判断是否存在 EXPIRE设置key的有效期 TTL查看key的剩余有效期 类型\u0026amp;命令 String 分类 类型 数据结构 string 字符串 int 整型 float 浮点数 常见命令 命令 作用 SET 添加/修改键值对 GET 由key得value MSET/MGET 批量操作 INCR 整型key自增1 INCRBY 整型自增指定步长 INCRBYFLOAT 浮点类型自增指定步长 SETNX 添加String键值对 前提key不存在 SETEX 添加String键值对 指定有效期 SETNX==SET key value NX\n返回0表示键值已存在不会添加\n返回1表示不存在已添加 层级结构 key的层级结构：用:隔开\n若值为Java对象 可用JSON形式存储： eg.'{\u0026quot;id\u0026quot;:1, \u0026quot;name\u0026quot;:\u0026quot;Satti\u0026quot;, \u0026quot;age\u0026quot;:20}'单引 Hash类型 无序字典 类HashMap CRUD 增删改查\n相对String类型的JSON字符串 可以将每个字段独立存储 KEY保存键名 VALUE中field保存字段名 value保存值 常见命令 命令 作用 HSET 添加/修改hash类型一对field\u0026amp;value HGET hash类型由key得filed HMSET/HMGET 对一个key批量操作 HGETALL 由key得所有field value HKEYS key中所有field HVALS key中所有value HINCRBY 字段值按指定步长自增 HSETNX 添加field 前提field不存在 List类型 类似LinkedList 但双向链表\n特征：有序 可重复 插入删除快 查询速度一般 常见命令 命令 作用 LPUSH/RPUSH 列表左/右侧插入 LPOP/RPOP 移除左/右侧第一个 LRANGE 返回一段角标范围内的所有元素 BLPOP/BRPOP 没有元素时等待指定的时间 移除时无元素 返回nil 角标 = 序号 从0开始 Set类型 类HashSet==value为null的HashMap\n特征：无序 不可重复 查找快 支持交并差集 常见命令： 命令 作用 SADD 向set添加元素 可多个 SREM 移除指定元素 SCARD 返回元素个数 SISMEMBER 是否有某元素 SMEMBERS 返回所有value 命令 作用 SINTER 求两键交集 SDIFF key1相对于key2不同的值（差集） SUNION 并集 SDIFF中key有先后顺序 SortedSet 类TreeSet（可排序的set） 数据结构不同\n每个元素具有score属性 通过属性排序=SkipList+Hash 特性： 可排序 元素不重复 查询速度快 常见命令：ZADD ZREM ZCARD ZINCRBY ZDIFF ZINTER ZUNION 命令 作用 ZSORE 获取指定元素score ZRANK 获取指定元素排名 ZCOUNT score在某范围内的元素个数 ZRANGE 按score排序得指定排名范围内元素 ZRANGEBYSCORE 指定score范围内 默认升序排序 Z后加REV即为降序 Jedis 开启测试后通过new对象建立连接\njedis=new Jedis(ip,port);\n设置密码\njedis.auth(password)\n选择库\njedis.select(index) SpringDataRedis RedisTemplate工具类 redisTemplate.opsForValue()类似语句调用上述数据类型\n返回值类型如ValueOperations 步骤： 引入spring-boot-starter-data-redis依赖 application.yaml配置Redis test中Autowired定义RedisTemplate\u0026amp;进行Test试验 StringRedisTemplate手动序列化\u0026amp;反序列化 节省内存 以json形式存储、读取数据 以对象形式初始化、接收 故需要手动进行序列化转换 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/redis%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003ch3 id=\"nosql\"\u003eNoSql\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e非关系型数据库 No Structured Relational\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e特点：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e表型 JSON型 图型==非结构化\n\u003cul\u003e\n\u003cli\u003eRedis为键值类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eJSON表==数据无关联\u003c/li\u003e\n\u003cli\u003e查询方式==非SQL（语法不统一）\u003c/li\u003e\n\u003cli\u003e事务ACID无法全部满足==BASE\u003c/li\u003e\n\u003cli\u003e存储==内存\u003c/li\u003e\n\u003cli\u003e使用场景：\n\u003cul\u003e\n\u003cli\u003e数据结构不固定\u003c/li\u003e\n\u003cli\u003e对一致性 安全性要求不高\u003c/li\u003e\n\u003cli\u003e性能要求\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"redis\"\u003eRedis\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e特征：\n\u003cul\u003e\n\u003cli\u003e键值型 key-\u003c!-- raw HTML omitted --\u003evalue\u003c!-- raw HTML omitted --\u003e 支持多种数据结构\u003c/li\u003e\n\u003cli\u003e单线程 命令具原子性\u003c/li\u003e\n\u003cli\u003e低延迟\n\u003cul\u003e\n\u003cli\u003e内存\u003c/li\u003e\n\u003cli\u003eIO多路复用\u003c/li\u003e\n\u003cli\u003e编码风格\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e支持数据持久化\u003c/li\u003e\n\u003cli\u003e支持主从集群 分片集群（主表\u0026amp;从表）\u003c/li\u003e\n\u003cli\u003e多语言客户端\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eredis-cli -h 192.168.211.129 -p 6379 -a 密码\u003c/code\u003e\u003cbr\u003e\n启动（不安全）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esystemctl stop redis\u003c/code\u003e关闭\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e连接虚拟机与图形化界面失败=检查防火墙\u003c/p\u003e","title":"Redis_base"},{"content":" 基本概念 RDBMS 关系型数据库 based on关系模型，多张二维表相互连接 sql操作分类 分类 全称 说明 DDL Data Definition Language 定义数据库、表、字段等 DML Manipulation 对表中数据进行增删改 DQL Query 查询表的记录 DCL Control 创建库用户 控制权限 启动与停止 net start mysql80 \u0026amp; net stop mysql80\nMySql 开机自启，在cmd中可手动停止 mysql -u root -p\n-u 提示用户为 root，-p 提示将输入密码 SQL 基本 以分号结尾，行数不论，空格与缩进不论 不区分大小写，关键字最好大写 \u0026ndash; 或 # 注释内容 多行注释 /* 内容 */ DDL DDL数据库操作 SHOW DATABASES;\n查询所有数据库 SELECT DATABASE();\n查询当前（是在哪个）数据库 创建数据库（括号内容可以不加 采用默认规则） CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; charset utf8mb4 设定为容纳4个字节的utf8 在DataGrip中可以使用SCHEMA替代DATABASE DROP DATABASE [IF EXISTS] 数据库名;\n删除数据库 USE 数据库名;\n使用数据库 DDL表操作 查询 SHOW TABLES;\n查询当前数据库所有表 DESC 表名 查询表结构 SHOW CREATE TABLE 表名 查询指定表的建表语句 创建 CREATE TABLE 表名( 字段1 字段1类型[COMMENT '中文'], 字段2 字段2类型[COMMENT '……'], …… 字段3 字段3类型[COMMENT '……'] )[COMMENT '……']; 字段1 是表头名称，如name 字段1类型： 数值类型 tinyint,smallint,mediumint,int-4字节,bigint,float,double tinyint unsigned表示无符号 即正数范围 可指定double(m,n)，m表示最长位数，n表示小数点后最长位数 字符串 char(指定长度),varchar(指定长度), char为定长字符串，varchar变长(会计算所需空间是否需要变化) 日期 date,time,datetime,year,timestamp(截至2038年) 修改 ALTER TABLE 表名 ADD 字段名 字段类型 [COMMENT 注释] [约束]; 增加字段 ALTER TABLE 表名 MODIFY 字段名 新字段类型 [COMMENT 注释]; 修改字段类型 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段类型 [COMMENT 注释]; 修改字段名\u0026amp;字段类型 ALTER TABLE 表名 RENAME TO 新表名 修改表名 删除 ALTER TABLE 表名 DROP 字段名; 删除字段 DROP TABLE [IF EXISTS] 表名; 删除表 TRUNCATE TABLE 表名; 删除并重新创建该表 DataGrip中字段翻译为列\nDML 添加数据 INSERT INTO 表名(字段名1,字段名2,…) VALUES (值1,值2,…); 指定字段添加数据 INSERT INTO 表名 VALUES (值1,值2,…); 全部字段添加数据 此处括号为分隔符号，不可省略，[]表示可以忽略 Sql 以某数据库为原点，若需修改某表，在指令中需指明该表名 字符串与时间类型用 '…' 表示 修改删除 UPDATE 表名 SET 字段名1=值1,字段名2=值2,…[WHERE 条件]; 条件可以写为 id=1 等 DELETE FROM 表名 [WHERE 条件] 不能删除某个对象中特定字段的值（只能删除行） 没有被物理删除 被标记为删除使其空间可被♻ DQL 用*表示显示所有信息，放在其它特殊检索内容前\n基本查询 SELECT 字段1，字段2，… FROM 表名; SELECT * FROM 表名 查询多个字段 SELECT 字段1 [AS 别名1],字段2 [AS 别名2],… FROM 表名; 设置别名(显示在搜索结果的表头) SELECT DISTINCT 字段列表 FROM 表名; 显示查询到的非重复结果 条件查询 SELECT 字段列表 FROM 表名 WHERE 条件列表 条件类型： 比较运算 \u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;或!=表示不等于 所有数据类型适用（包括日期） BETWEEN … AND … 含最大最小值的范围 前小后大 数据有先后顺序 IN(…) 列表中的值 LIKE 占位符 模糊匹配 _表示单字符 %表示任意个字符 IS NULL 或 IS NOT NULL 逻辑运算 AND 或 \u0026amp;\u0026amp; OR 或 || NOT 或 ! 聚合函数\u0026amp;分组查询 SELECT 聚合函数(字段列表) FROM 表名;\n常见聚合函数： 函数 功能 count 统计数量 max 最大 min 最小 avg 平均 sum 求和 SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\n“字段列表”可以写聚合函数\u0026amp;搜索的字段名（可显示表头） 执行顺序：WHERE\u0026gt;聚合函数\u0026gt;HAVING 聚合函数(某) 别名 起别名方法 聚合函数多半可以直接写为 SUM(\\*) 排序查询 SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;\n排序方式： ASC 升序(默认) DESC 降序 字段1，字段2有先后顺序 分页查询 SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;\n起始索引从0开始，为查询页的起始id\n第一页可以写为 LIMIT 查询记录数 顺序 编写顺序： SELECT$\\rightarrow$FROM$\\rightarrow$WHERE$\\rightarrow$GROUP BY$\\rightarrow$HAVING$\\rightarrow$ORDER BY$\\rightarrow$LIMIT DCL 管理用户 USE mysql SELECT * FROM user 查询用户 CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 创建用户 主机名为 % 表示可在任意主机访问 ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 修改密码 DROP USER '用户名'@'主机名'; 删除用户 权限控制 常用权限类型： 权限 说明 ALL(PRIVILEGES) 所有权限 SELECT 查询 INSERT 插入 UPDATE 修改 DELETE 删除 ALTER 修改表 DROP 删除库/表/视图 CREATE 创建库/表 SHOW GRANTS FOR '用户名'@'主机名'; 查询权限 GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 授予权限 权限列表写 ALL 作通配 REVOKE 权限列表 ON 数据库名.表名FROM '用户名'@'主机名'; 撤销权限 数据库、表用\\*作通配 函数 使用 SELECT 函数 进行函数试验\n字符串函数 常用函数：\n函数 功能 CONCAT(S1,S2,…,Sn) 拼接字符串 LOWER(str) 全小写 UPPER(str) 全大写 LPAD(str,n,pad) pad从左填充str到n长度 RPAD(str,n,pad) pad从右填充str到n长度 TRIM(str) 去头尾空格 SUBSTRING(str,start,len) 返回str从start处起的len个字符 字符串从1开始 非0 主要结合前文语法进行应用 数值函数 常见函数：\n函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) x/y的模 RAND() 0~1内随机数 ROUND(x,y) x四舍五入 y位小数 日期函数 常见函数：\n函数 功能 CURDATE() 当前日期 CURTIME() 当前时间 NOW() 当前日期与时间 YEAR(date) 获得date的年份 MONTH(date) date的月份 DAY(date) date的日 DATE_ADD(date,INTERVAL expr type) date加上时间间隔expr后的时间 DATEDIFF(date1,date2) date1到date2的天数 DATE_ADD 中 expr 可为数字 type可为 DAY 流程控制函数 常用函数：\n函数 功能 IF(v,t,f) v为true返回t 否之为f IFNULL(value1,value2) v1不为空则返回v1 否之为v2 CASE WHEN [val1] THEN [res1] … ELSE [default] END v1真则返回res1 否之为d CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END expr等于v1返回res1 否之为d val1处不能并列多个val 用此类函数做筛选不用加where，格式为：==SELECT \\*,(CASE …) AS '别名' FROM 表名== 约束 约束概述 目的：保证数据库中数据的正确有效与完整\n约束分类 约束 描述 关键字 非空约束 该字段数据不为null NOT NULL 唯一约束 该字段所有数据不重复 UNIQUE 主键约束 一行数据的唯一标识 非空且唯一 PRIMARY KEY 默认约束 未指定则采用默认值 DEFAULT 某 检查约束 保证字段满足某条件 CHECK id int PRIMARY KEY AUTO_INCREMENT主键且自动增长(多个约束用空格隔开) 作用于表中字段 创建/修改表时添加 一般把序号设为主键 外键约束 让两表数据建立连接 保证数据完整一致\n具有外键的表=子表 被关联的表=亲表\n格式：\n创建时添加 [CONSTRAINT] [外键名] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) 修改时添加 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) 外键名是给外键自定义的新名字 注意数据类型需完全相同 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 删除外键\n[ON UPDATE 模式 ON DELETE 模式] 在添加语句后指定删除/更新模式\n模式 说明 NO ACTION 有外键则不允许更新 RESTRICT 同上 CASCADE 亲子表同时更新 SET NULL 亲表删除 子表设null SET DEFAULT 子表设为默认(Innodb不支持) 多表查询 多表关系 一对多：建立外键连接 eg.员工\u0026amp;部门 多对多：建立第三表 至少包含两外键 分别关联两方主键 eg.学生\u0026amp;课程 一对一：任意一方加外键 并设置为UNIQUE 多用于单表拆分 基础字段在一表 详情字段在另一表 UNIQUE 在定义id的时候添加 eg.用户\u0026amp;用户详情 多表查询概述 并列多表时需要消除无效的笛卡尔积情况(指A*B) 分类： flowchart LR; test((连接查询)) test--\u0026gt;内连接 test--\u0026gt;外连接 test--\u0026gt;自连接 多表查询--\u0026gt;test 多表查询--\u0026gt;子查询 外连接--\u0026gt;左外连接 外连接--\u0026gt;右外连接 内连接 返回A B表的交集\nSELECT 字段列表 FROM 表1,表2 WHERE 条件 …; 隐式内连接 条件类似employee.dept_id=dept\\.id SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件 …; 显式内连接 外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 …; 左外连接 查询左表与交集部分的数据 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 …; 左外连接 右表\u0026amp;交集 自连接 SELECT 字段列表 FROM 表1 别名1 JOIN 表1 别名2 ON 条件 …; 可内连接也可外连接 联合查询 SELECT 字段列表 FROM 表1 … UNION [ALL] SELECT 字段列表 FROM 表2 …; 有ALL结果直接合并 无ALL去重 字段列表与类型相同 子查询（嵌套查询） 外部可以是INSERT/UPDATE/DELETE/SELECT 根据子查询结果的不同分类： 名称 意义 标量子查询 结果为单个值 列子查询 结果为一列 行子查询 为一行 表子查询 多行多列 可在WHERE/FROM/SELECT之后进行 列子查询 返回一列结果 常用操作符： 操作符 用途 ==IN== 集合范围之内 多选一 NOT IN 不在集合范围内 ANY 任意一个满足 SOME 同ANY ALL 所有值都满足 行子查询 常用操作符 =、\u0026lt;\u0026gt;、IN、NOT IN 可以用 (1200,1)=(salary,manager) 表示一一对应 表子查询 常用操作符 IN 事务 操作 简介：一组操作的集合 整体提交 自动开始 SELECT @@AUTOCOMMIT; 开始事务(自动提交) SELECT @@AUTOCOMMIT=0; …… COMMIT; 手动提交事务 ROLLBACK; 事务回滚 手动开始 START TRANSACTION; 开启事务 COMMIT; 提交事务 ROLLBACK; 回滚事务 特性 原子性 不可分割的最小操作单元 一致性 事务完成时所有数据保持一致状态 隔离性 数据库的隔离机制，事务进行不受外部并发操作影响 持久性 提交或回滚后，数据的改变是永久的 ==ACID模型== 并发事务问题 脏读 一个事务读到另一个事务未提交的数据 不可重复读 先后读取同一记录但数据不同 幻读 按条件查询数据，无对应数据行，但插入数据时发现该行数据已存在 事务隔离级别 分类： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED ✔ ✔ ✔ READ COMMITTED ✖ ✔ ✔ REPEATABLE READ(默认) ✖ ✖ ✔ SERIALIZABLE ✖ ✖ ✖ ORACLE默认READ COMMITTED 性能递减 安全性递增 SELECT @@TRANSACTION_ISOLATION; 查看事务隔离级别 SET [SESSION或GLOBAL] TRANSACTION ISOLATION LEVEL {隔离级别}; 设定隔离级别 SESSION为当前连接 GLOBAL为全局，不包含当前连接 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/mysql_base/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"基本概念\"\u003e基本概念\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cem\u003eRDBMS\u003c/em\u003e 关系型数据库\nbased on关系模型，多张二维表\u003cstrong\u003e相互连接\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003esql操作分类\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e分类\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e全称\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDDL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eData Definition Language\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e定义数据库、表、字段等\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDML\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eManipulation\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e对表中数据进行增删改\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDQL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eQuery\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e查询表的记录\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDCL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eControl\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e创建库用户 控制权限\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"启动与停止\"\u003e启动与停止\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003enet start mysql80\u003c/code\u003e \u0026amp; \u003ccode\u003enet stop mysql80\u003c/code\u003e\u003cbr\u003e\nMySql 开机自启，在cmd中可手动停止\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emysql -u root -p\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e-u\u003c/code\u003e 提示用户为 root，\u003ccode\u003e-p\u003c/code\u003e 提示将输入密码\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"sql\"\u003eSQL\u003c/h2\u003e\n\u003ch3 id=\"基本\"\u003e基本\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e以分号结尾，行数不论，空格与缩进不论\u003c/li\u003e\n\u003cli\u003e不区分大小写，关键字最好大写\u003c/li\u003e\n\u003cli\u003e\u0026ndash; 或 # 注释内容\n多行注释 /* 内容 */\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"ddl\"\u003eDDL\u003c/h3\u003e\n\u003ch4 id=\"ddl数据库操作\"\u003eDDL数据库操作\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSHOW DATABASES;\u003c/code\u003e\u003cbr\u003e\n查询所有数据库\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSELECT DATABASE();\u003c/code\u003e\u003cbr\u003e\n查询当前（是在哪个）数据库\u003c/li\u003e\n\u003cli\u003e创建数据库（括号内容可以不加 采用默认规则）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003echarset utf8mb4\u003c/code\u003e 设定为容纳4个字节的utf8\u003c/li\u003e\n\u003cli\u003e在\u003c!-- raw HTML omitted --\u003eDataGrip\u003c!-- raw HTML omitted --\u003e中可以使用\u003cem\u003eSCHEMA\u003c/em\u003e替代\u003cem\u003eDATABASE\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\u003ccode\u003eDROP DATABASE [IF EXISTS] 数据库名;\u003c/code\u003e\u003cbr\u003e\n删除数据库\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUSE 数据库名;\u003c/code\u003e\u003cbr\u003e\n使用数据库\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"ddl表操作\"\u003eDDL表操作\u003c/h4\u003e\n\u003ch5 id=\"查询\"\u003e查询\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSHOW TABLES;\u003c/code\u003e\u003cbr\u003e\n查询当前数据库所有表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDESC 表名\u003c/code\u003e\n查询表结构\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSHOW CREATE TABLE 表名\u003c/code\u003e\n查询指定表的建表语句\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"创建\"\u003e创建\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eCREATE TABLE 表名( 字段1 字段1类型[COMMENT '中文'], 字段2 字段2类型[COMMENT '……'], …… 字段3 字段3类型[COMMENT '……'] )[COMMENT '……'];\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e字段1 是表头名称，如name\u003c/li\u003e\n\u003cli\u003e字段1类型：\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数值类型\u003c/strong\u003e\ntinyint,smallint,mediumint,int-4字节,bigint,float,double\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etinyint unsigned\u003c/code\u003e表示无符号 即\u003cstrong\u003e正数范围\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e可指定\u003ccode\u003edouble(m,n)\u003c/code\u003e，m表示最长位数，n表示小数点后最长位数\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字符串\u003c/strong\u003e\nchar(指定长度),varchar(指定长度),\n\u003cul\u003e\n\u003cli\u003echar为定长字符串，varchar变长(会计算所需空间是否需要变化)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e日期\u003c/strong\u003e\ndate,time,datetime,year,timestamp(截至2038年)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"修改\"\u003e修改\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 ADD 字段名 字段类型 [COMMENT 注释] [约束];\u003c/code\u003e\n增加字段\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 MODIFY 字段名 新字段类型 [COMMENT 注释];\u003c/code\u003e\n修改字段类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段类型 [COMMENT 注释];\u003c/code\u003e\n修改字段名\u0026amp;字段类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 RENAME TO 新表名\u003c/code\u003e\n修改表名\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"删除\"\u003e删除\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 DROP 字段名;\u003c/code\u003e\n删除字段\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDROP TABLE [IF EXISTS] 表名;\u003c/code\u003e\n删除表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTRUNCATE TABLE 表名;\u003c/code\u003e\n删除并重新创建该表\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDataGrip中字段翻译为列\u003c/p\u003e","title":"MySql基础"},{"content":" 我叫Lulu 是一只矮脚小猫😼\n请收集柠檬助力我进化成Lululemon！ 请关注 Lulu 主人的 Youtube 和 ins 好吗好的 OK(*^▽^*) 柠檬收集度：0/8848 我生活在韩国\n和 一个人类 小声告诉你 她叫 Claire 喔\n还有 十只猫猫 住在一起\n虽然我很可爱 可是矮脚猫有基因缺陷 请谨慎养宠!\n这就是我的世界 喜欢我的话就往下看看吧🥰\n我的人型抱枕🥰 Secret !\nlulu不是不喜欢 Claire 是她的食物和玩具太有吸引力了\nClaire 在 Youtube\n和 Instagram\n上发布我们的动态\n答应我 如果喜欢我们的话要去关注她\n认准 Claire _luvcat频道不迷路😋 Claire 是我们的管家！\n肾衰的TT姐姐 跟我一样折耳的ChuChu\nClaire 都带我们治病\n喜欢她🥰\n舔狗lulu😗 只是喜欢的真情流露\n盗窃小分队😋\n喜欢DD\nMoMo会长😗\n一口吃掉\n盗窃小分队Ⅱ\n也喜欢CoCo\n唯一的Queen——TT姐姐🤩\n勇敢lulu 不怕困难😼 lulu （和弟弟TOTO,DODO）是最 勇猛 的小猫😼\n因为基因 lulu可以 站 起来 lulu在看着你🥺\nClaire 在吃什么 可以给lulu尝一口吗\nlulu爱睡觉 lulu一天到晚睡觉\n属于折耳猫的病痛 短粗的尾巴 畸形的耳朵\n是 折耳 基因的影响😢\n软骨发育不全会带来 痛苦\n所以请不要养折耳猫！\nTo Be Continued\n","permalink":"https://Sattiluvcat.github.io/en/lulu/","summary":"lulu","title":"Lulu的一切"},{"content":" 一直很想在互联网上拥有属于自己的空间😸\n记录一些关于自己和最喜欢的小猫——Lulu！的故事\n🥰🥰\n喜欢电影和文字 如有同好请通过博文评论区跟我交流🎃🎉\n","permalink":"https://Sattiluvcat.github.io/en/about/","summary":"about","title":"关于我"}]