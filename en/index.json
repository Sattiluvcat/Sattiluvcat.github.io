[{"content":" 巴黎夜旅人 最喜欢的还是甘斯布迎着风披着夜色回家的片段 离婚之后她需要自己谋生，被迫走出依附别人的境地，但又怎么不算幸事？\n她在夜间电台刚刚找到工作，人生明明还在谷底，但是从这个瞬间开始一切都变得有希望 凌晨的风吹乱了她的风衣，但也不会再有什么影响 整部电影有一种复古又柔和的氛围，甘斯布独立自主自力更生的part感觉格外动容（大概因为当时对其它的背景也不是很熟悉… 其实看这部的时候还没听说过《圆月映花都》《德州巴黎》一众电影，只是完全被这种复古的情调冲击，之后开始慢慢补上其它的，但是那种冲击的感觉也很少出现了\n春天不是读书天 很喜欢这种自由又热烈的青春感觉，可能是因为自己从没有这么自由热烈过…当然也只是自己的原因\n\u0026ldquo;Life moves pretty fast.If you don\u0026rsquo;t stop and look around once in a while, you could miss it\u0026rdquo;\nLet\u0026rsquo;s look around✨\n落水狗 单纯是喜欢这种痛快以及很有趣的人心变换\n昆汀的电影都挺喜欢的，就算是饱受诟病的《子弹列车》其实也能看下去，看电影不就看一个感觉么？\n午夜狂奔 又是中国人民的老朋友罗伯特·德尼罗！ 很搞笑的一部，节奏非常好的公路片 德尼罗放会计走的时候，会计脸上的灰和憨厚的笑实在令人忍俊不禁（什么\n冬天的故事 来自又一位比较喜欢的导演——侯麦，应该是春夏秋冬四部曲，但实在欣赏不来其它的某些情节\n充斥着有点空洞又非常可爱的对白，节奏慢慢的，女主角看起来很有灵气 在很嘈杂的环境下看完，感觉格外清爽，侯麦的电影于我而言都是这样，虽然故事背景都是各种关系纠缠，但是很难注意到这种情感上的混乱\n","permalink":"https://Sattiluvcat.github.io/en/posts/hobbies/%E7%94%B5%E5%BD%B1top5/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://pic.imgdb.cn/item/6734d28cd29ded1a8ccc8f06.png/\" alt=\"alt text\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"hahahugoshortcode9s1hbhb\"\u003e\u003ca href=\"https://movie.douban.com/subject/35354759/\" style=\"font-weight: bold; color: black; \"\u003e巴黎夜旅人\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e最喜欢的还是甘斯布迎着风披着夜色回家的片段 \u003cbr\u003e\n离婚之后她需要自己谋生，被迫走出依附别人的境地，但又怎么不算幸事？\u003cbr\u003e\n她在夜间电台刚刚找到工作，人生明明还在谷底，但是从这个瞬间开始一切都变得有希望  \u003cbr\u003e\n凌晨的风吹乱了她的风衣，但也不会再有什么影响\n \u003c/p\u003e","title":"个人电影Top5"},{"content":" 功能完善 拦截器 Utils中实现添加拦截器Interceptor功能，在config中添加MVCConfig以添加拦截器并设置排除拦截的地址 session 存储用户基本信息即可\n多台Tomcat不共享session空间（存储当前用户信息）\u0026ndash;\u0026gt;切换不同Tomcat时数据丢失 需要数据共享 内存存储 键值 ==\u0026gt;Redis替代 Redis 保存用户时以随机token作为key 设置有效期 另外用户访问时持续更新时长\u0026ndash;\u0026gt;在拦截器中设置 取出Hash类型的所有字段\u0026ndash;\u0026gt;entries 缓存 数据交换缓冲区 临时存储数据 读写性能较高\n注意：添加缓存时根据Redis中类型转换变量类型 Redis使用String类型——以JSON形式存储，需转换 缓存更新策略 内存淘汰 Redis内存不足时自动淘汰部分数据 一致性差 无维护成本 超时剔除 为缓存数据添加TTL时间 下次查询时更新缓存 一致性一般 主动更新 Cache Aside \u0026amp; Read/Write Through \u0026amp; Write Back 一致性好 主动更新 Cache Aside Pattern 更新缓存无效写操作较多（若查询很少）——\u0026gt;删除缓存 查询时再更新缓存 保证缓存与数据库操作同时成功/失败——\u0026gt; 单体系统：缓存与数据库变一个事务 分布式系统：TCC等分布式事务方案 先删缓存再改数据库or先修改数据库（线程安全性）——\u0026gt;先改数据库后删缓存 封装成事务 缓存穿透 客户端请求的数据在缓存和数据库中都不存在\n缓存空对象：在Redis中缓存键值对null 造成额外的内存消耗——设置TTL解决 可能造成短期不一致 布隆过滤：客户端到Redis之间设置布隆过滤器 判断存在则放行 不存在则拒绝请求 ≈ 数据库中数据通过Hash转换后在过滤器中以二进制位形式存储 优点：内存占用较少 没有多余key 缺点：实现复杂 可能误判（判为存在） 选择缓存空对象\n其它解决方案：增加id复杂度 \u0026amp; 做好数据的基础格式校验 \u0026amp; 用户权限校验 \u0026amp; 热点参数限流 缓存雪崩 同一时段内大量缓存key同时失效/Redis服务宕机 导致大量请求到达数据库——\u0026gt;巨大压力\n给不同key的TTL设置随机值 利用Redis集群提高服务的可用性 缓存业务添加降级限流策略（牺牲部分服务） 给业务添加多级缓存（浏览器 nginx JVM…都设置缓存） 缓存击穿 “热点key问题” 被高并发访问\u0026amp;缓存重建业务（查询数据库并更新缓存）较复杂的key突然失效 无数请求访问会给数据库带来巨大冲击\n互斥锁——（查询缓存未命中后）获取互斥锁成功后才可进行缓存重建，若获取失败 休眠一会后重试 优点：无额外内存消耗 \u0026amp; 保证一致性 \u0026amp; 实现简单 缺点：线程需要等待 性能受影响 \u0026amp; 可能死锁 逻辑过期——存储热点key的value时在value中增加逻辑过期值expire（实际上不设置TTL） 手动回收 查询缓存 检查逻辑时间是否已过期 已过期，获取互斥锁成功，开启新线程来更新expire，本线程返回过期数据，新线程更新完毕释放锁 已过期，获取互斥锁失败，返回过期数据 优点：线程无需等待 性能较好 缺点：不保证一致性（返回旧数据） \u0026amp; 有额外内存消耗 \u0026amp; 实现复杂 使用逻辑过期 创建线程池 private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10); 秒杀 全局ID 针对优惠券\n订单表不用自增ID：id规律性明显 \u0026amp; 受单表数据量限制 分布式系统下生成全局唯一ID的工具 高可用 递增性 安全性 高性能 唯一性 ID组成：符号位 + 时间戳（31位） + 序列号（32位） 设置每天一个key 避免超过上限 超卖 产生：对库存进行操作完成前 有线程访问 即会产生超卖 锁： 悲观锁：线程安全问题一定发生，操作数据前先获取锁eg.Synchronized lock 乐观锁：不一定发生，只在更新数据时判断是否有其他线程对数据进行了修改 乐观锁：两种方案 版本号法：数据库中添加version字段，修改时需校验version与之前查到的是否一致，一致时同时更新版本号 CAS法：直接把库存当版本即可 成功率过低 一人一单 加悲观锁——Synchronized 对同一个用户加锁，intern方法保证只对该值加锁 不是新创建对象（toString会新创建对象） 当锁在事务中时，锁释放后事务尚未提交 ==\u0026gt; 其他线程仍有可能访问到未更新的内容 锁在方法上时，会对所有this对象都加锁and···，范围太广 选定把锁加在方法调用上 synchronized (userId.toString().intern()) 锁加在方法调用上时，this的对象并非代理（Impl）对象，Spring的事务会失效，解决方法选择获取代理对象 注意有几种使Spring的事务失效的可能 有几种解决方案\nsynchronized (userId.toString().intern()) { IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } * 主方法中添加注解`@EnableAspectJAutoProxy(exposeProxy = true)` * 添加AspectJweaver依赖 集群设备访问 失效 测试时设置虚拟机设置（VM options）修改为多个端口号 分布式锁 满足分布式系统/集群模式下多进程可见\u0026amp;互斥的锁\n要求：多进程可见 + 互斥 + 高可用 + 高性能 + 安全性 + ··· 对比：MySql Redis Zookeeper 维度 MS R Zk 互斥 自身的互斥锁 setnx等互斥命令 节点唯一性 有序性实现 高可用 好 好 好 高性能 一般 好 一般 安全性 断开连接自动释放锁 锁超时时间设置 临时节点 断开连接则释放 实现：设置锁的同时保证互斥（设置锁\u0026amp;设置过期时间 语句合二为一） 业务完成后需手动释放锁 SET lock thread1 NX EX 10 问题：误删（eg.某线程业务阻塞 锁超时释放 其他线程即可获取锁 此后原业务再释放即释放了其它线程的锁） 解决：删除锁时对比value是否是本线程——修改释放锁逻辑即可 value存储某固定UUID+线程标识 新问题：判断标识与释放锁必同时进行（否则过程中发生阻塞后也会有问题——Java自身导致的） 解决：保证原子性——Lua脚本（不用Redis的事务机制） 一个脚本中编写多条命令 -- 从1开始计数 local key=KEYS[1] -- 非key的都用ARGV保存 local threadId=ARGV[1] 隐患：（极小概率）——Redisson解决 不可重入——同个线程不可多次获取同一把锁 不可重试 超时释放——业务执行耗时较长 锁也会释放 主从一致性 Redisson 设置：引入依赖——配置config——注入后直接使用 @Configuration public class RedissonConfig { @Bean public RedissonClient redissonClient() { Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://192.168.balabal:6379\u0026#34;).setPassword(\u0026#34;123456\u0026#34;); return org.redisson.Redisson.create(config); } } 可重入锁原理👇：同一线程可以多次访问一个锁——Redis用Hash结构保存，value为访问次数，当最后value==0时释放锁（若非0，则重置有效期后继续执行业务——不在最外侧）\nLua脚本编写 可重试：订阅等功能实现——等待、唤醒、获取锁失败👇\n超时续约：watchDog 每隔一段时间重置超时时间（leaseTime=-1时自动进入）👇\nRedisson分布式锁过程👇（读源码）下图来自：黑马程序员Redis入门到实战教程 主从一致性（主从同步有延时/同步失败时）——设置多Node 必须在所有Node都获得锁程序才获得锁（也可以继续给Node配Slave节点）\n异步优化 （Lua脚本）Redis进行判断购买条件与“扣减库存” tomcat根据其传回的信息判断是否添加到阻塞队列并返回订单id mysql异步下单 两线程进行 阻塞队列 BlockingQuene——队列为空时 阻塞进程；队满时插入 阻塞进程 封装 泛型 其它 JMeter 运行jmeter.bat即可 拆箱装箱问题 Boolean-boolean Integer-int等\n","permalink":"https://Sattiluvcat.github.io/en/posts/java/%E7%82%B9%E8%AF%84proj/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"功能完善\"\u003e功能完善\u003c/h2\u003e\n\u003ch3 id=\"拦截器\"\u003e拦截器\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eUtils中实现添加拦截器Interceptor功能，在config中添加MVCConfig以添加拦截器并设置排除拦截的地址\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"session\"\u003esession\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e存储用户基本信息即可\u003c/p\u003e","title":"点评Proj"},{"content":" 所有图片来自：计算机网络微课堂（有字幕无背景音乐版） 概述 概念 计算机网络 由结点node\u0026amp;链路link构成 计算机网络可由交换机连接 多个计算机网络可由路由器连接成互连网（协议不定） 全球范围的互连网 = 互联网（统一采用TCP/IP协议） ISP 互联网服务提供商 组成与功能 组成 硬件+软件+协议 硬件：主机（end system端系统） 通信设备balabal 协议由硬件软件共同实现 边缘部分+核心部分 边缘 = 直接为用户服务 （从逻辑功能）资源子网+通信子网 资源子网 主要是主机 功能 数据通信（最基本最重要） 资源共享——硬件 软件 数据 分布式处理——eg.复杂任务多计算机处理 提高可靠性——eg.互为替代机 负载均衡 通信方式 电路交换eg.电话 通信时始终占用端到端线路资源 but 释放/建立连接需要额外时间开销 利用率低 报文交换eg.电报 无需提前建立连接 存储转发（通信线路可灵活分配） 线路利用率高 支持差错控制 but 报文不定长 不利管理 + 长报文存储转发时间、缓存开销大 + 长报文易出错 存储转发 = 先存储后转发 分组交换（现代网络采用） 定长——方便存储转发管理 + 转发时间更少（相对报文交换）+不易出错 控制信息占比增加（报文）+ 存在存储转发时延（电路交换）+ 分成多个分组 传输过程中可能出错 虚电路交换：虚拟电路建立连接 + 通信双方不独占线路 通信方式性能对比 电路交换 建立连接后再进行数据传送 最后连接释放 报文交换 中间节点需接收完整报文后再进行解析与转发 分组交换 分组进行报文交换 分类 分布范围 广域网WAN + 城域网MAN + 局域网LAN + 个域网PAN WAN多采用以太网 MAN 几乎全部采用以太网技术（城域网多归为局域网） 局域网可通过路由器接入广域网 个域网 eg.蓝牙 Zigbee等设备 传输技术：广播式网络 \u0026amp; 点对点网络 拓扑结构： 总线形 广播式 存在总线争用问题 环形结构 广播式 令牌顺环形传递 有令牌才发数据 eg.令牌环网 星形结构 中央设备实现数据点对点传输 eg.以太网交换机连接的设备 网状结构 数据通过各中间节点逐一存储转发 eg.由many路由器构建的广域网 使用者：公用网 \u0026amp; 专用网 传输介质：有线 \u0026amp; 无线 性能指标 信道：向某一方向发送信息的通道（一条发送信道+一条接受信道 = 一个通信线路） 速率：连接到网络上的节点在信道上传输数据的速率 常用单位：bit/s bps（也会用B 1B=8b） 带宽：某信道能传送的最高数据率 吞吐量：单位时间通过某网络（or信道/接口）的实际数据量 时延：数据从网络/链路的一端到另一端所需的时间 发送时延 = 传输时延 传播时延：电磁波在信道中传播花的时间 时延带宽积 = 传播时延 x 带宽 往返时延RTT = 发送方发送完数据的时间到完全接收确认信息的时间 信道利用率 = 有数据通过的时间/利用信道的总时间 利用率过低 = 浪费带宽 过高 = 易网络拥塞 分层结构 同个功能可由不同层实现 结构不固定\n常见计网体系机构： OSI参考模型 + TCP/IP模型 + 五层结构（教学 分层结构概念：计网的各层及其协议的集合 概念： 实体：第n层的活动元素（硬件 软件） = 第n层实体 不同机器上同一层为对等层 同层实体为对等实体 协议（网络协议Network Protocol）：控制对等实体间通信规则的集合 水平 服务 下层为紧邻的上层提供的功能调用 接口（服务访问点SAP） 实体通过接口请求下一层实体的服务 协议 数据传输过程：协议添加在首部or尾部 eg.YSCS协议（压缩传输） 协议数据单元PDU=服务数据单元SDU + 协议控制信息PCI \u0026ndash;\u0026gt; 整体下一层的SDU 协议三要素：语法 语义 同步 同步（时序）——时间实现顺序的详细说明 OSI参考模型 分层：（如下） 分层任务： 第0层：物理传输媒体 物理层：相邻节点间比特的传输 数据链路层：差错控制 + 流量控制（协调两节点的速率）（以帧为单位进行数据传输） 网络层（把分组从源节点转发到目标节点）（以分组为单位进行数据传输） 路由选择：决定分组到目的节点的最佳路径 分组转发：选择合适端口转发分组 网际互连：异构网络互联（不同构造的网络） 其他功能 包括差错控制 流量控制… 传输层（端到端通信 端即端口 = 进程到进程）（以报文段segment为单位） 复用与分用 几个高层实体复用一条底层连接 在接收端分用 其他功能 包括差错控制 流量控制… 会话层（管理进程间会话） 表示层（解决不同主机上信息表示不一致的问题 应用层（实现特定的网络应用）（以报文为单位进行数据传输） TCP/IP模型 分层：网络接口层（≈物理层+数据链路层）+ 网络层 + 传输层 + 应用层（≈else层） 原因： 表示层\u0026amp;会话层可以不用（需要时可在应用层进行处理） 网络层下主要是硬件部分（厂商可自由发挥so合并） 特点： 网络层不进行差错控制 only保证最大能力交付 传输层负责数据正确可靠性 物理层 不隔离广播域 冲突域\n通信基础基本概念 综合： 信源发送信号（数据的载体）到信宿 信号：数字信号 or 模拟信号 信号值离散 or 连续 码元：每个信号就是一个码元 信号周期 = 码元宽度 若一个码元可能有4种状态 = 4进制码元 = 一个码元携带2bit数据 速率：波特率 + 比特率 波特率：码元/秒 = 波特Baud 比特率：比特/秒 信道的极限容量 噪声：对信号产生干扰 奈奎斯特定理 无噪声（理想）低通信道\n极限波特率 = 2W（单位：波特） W为信道频率带宽（单位：Hz） 说明： 若波特率过高 = 导致码间串扰（接收方无法识别码元） 缺点：并未对码元可以携带多少比特做解释 香农定理 有噪声 带宽有限\n极限比特率 = $Wlog_2(1+S/N)$（此处信噪比无单位） $S/N$ 信噪比 = 信号功率/噪声功率 以dB为单位表示为$10log_{10}S/N$ 结合Nyquist可知，带宽、信噪比确定的信道上，一个码元可携带的比特数有上限 编码与调制 概念 信源\u0026ndash;\u0026gt;变换器\u0026ndash;\u0026gt;信道\u0026ndash;\u0026gt;反变换器\u0026ndash;\u0026gt;信宿 变换器：将二进制数据转换为信号 转换为数字信号 = 编码 转换为模拟信号 = 调制（eg.光猫） 反变换器：将信号转换为二进制数据 数字信号转换 = 解码 模拟信号转换 = 解调 编码 方法 不归零编码NRZ——低电平（表示）0，高电平（表示）1，中间不跳变 归零编码RZ——低电平（表示）0，高电平（表示）1，中间归零 反向非归零NRZI——遇0跳变，遇1不跳变，中间不跳变（看起点决定0/1） 曼彻斯特编码——遇0上/跳，遇1下/上跳，中间会跳变（看中间） 差分曼彻斯特——遇0跳变，遇1不跳变，中间会跳变（看起点） 特点 自同步能力——信源信宿可以根据信号实现节奏同步（知道断点在哪） 1无 3增加冗余位时可支持自同步 浪费带宽——每个信号（0/1）中间需要变化时就会浪费带宽 2 4 5浪费 3浪费一点 抗干扰能力 1 2 3弱 调制 调制方法 调幅AM幅移键控——调整正弦波振幅 调频FM频移键控——调整正弦波频率 调相PM相移键控——调整正弦波相位 正交幅度调制QAM——m种幅值 n种相位复合 QAM-32指调制出32种信号 = 每个码元可以携带32bit信号 传输介质 有线常用传输介质 双绞线：两导线绞合而成 有屏蔽层 = 屏蔽双绞线STP 无屏蔽层 / 非屏蔽双绞线UTP 抗干扰能力较好（绞合\u0026amp;屏蔽层） 局域网网线 同轴电缆：内导体\u0026amp;外导体屏蔽层 内导体越粗 电阻越低 信号衰减越少 抗干扰能力好（屏蔽层） 早期局域网 光纤：纤芯（高折射率）\u0026amp;包层（低折射率）= 单模光纤（一条光线传输）/ 多模光纤（多条光线） 单模光纤适合长距离 多模光纤适合短距离 抗干扰能力非常好 信号传输损耗小（中继器少） 命名规则 以太网For有线传输介质\n速度+Base+介质信息 Baseband基带传输 传输数字信号采用曼彻斯特编号 无线传输介质 无线电波（长波）——穿透能力强（绕射性好） 传输距离长 信号指向性弱 手机信号 WiFi 微波通信（短波）——频率带宽高 信号指向性强 保密性差 物理层接口特性 机械特性 + 电气特性 + 功能特性 + 过程（规程）特性 物理层设备 中继器Repeater 传输距离太长 数字信号会失真\nonly两端口 一个接收信号 \u0026ndash;\u0026gt; 整形再生 \u0026ndash;\u0026gt; 另一端口 仅支持半双工通信（一次只能处理一个方向） 两个端口对应两个网段 集线器hub 多端口中继器\n各节点不可同时发送数据 冲突域：若两主机同时发送数据会冲突 则其处于同个冲突域 在发数据前需信道争用 都不能无限串接 数据链路层 隔离冲突域（eg.网桥）\n概述 概念 链路Link：从一个结点到相邻结点的一段物理线路 数据链路：链路 + 实现通信协议的软硬件 以帧为单位传输处理数据 三个问题 封装成帧：为网络层协议数据单元添加帧头帧尾（成为帧） 差错检测：发送方将检错码封装在帧尾 检测是否有误码 检错码根据发送内容 检错算法而不同 可靠传输：即使检出错误，发送方也能保证接收方得到正确信息 封装成帧 帧头帧尾 作用：帧定界 + ··· 让接受层确定一帧的起始点 有的协议不通过帧头帧尾提供帧定界功能 以太网V2的MAC帧通过帧间间隔实现 透明传输 定义：数据链路层对上层交付的传输数据没有任何限制 实现：面向字节的物理链路使用字节填充方法实现 \u0026amp; 面向比特的物理链路使用比特填充方法实现 在特殊字符前添加转义字符 比特流中可采用零比特填充法 帧的长度 为提高运输效率 应使帧的数据部分长些 每种数据链路层协议都规定了👆的长度上限MTU（最大传送单元Maximum Transfer Unit） 差错检测 相关概念 比特差错：比特在传输过程中 0可能变为1··· 误码率BER：一段时间内 传输错的比特占总比特数的比例 校验方法 奇/偶校验：添加1位奇偶校验位 使所有数据中（包括其自己）1的个数为奇/偶 漏检率高 循环冗余校验CRC：约定一个生成多项式 发送方基于数据与多项式计算得冗余码 接收方通过其计算 生成多项式各项系数构成比特串eg.$1x^4+0x^3+1x^2+1x^1+0*x^0$ 对应$10110$ 特点 只能检测 不能定位（定位开销大 不采用） CRC硬件实现容易 可靠传输 概念 传输差错包括比特差错 分组丢失 分组失序 分组重复（一般出现在数据链路层上层）··· 可靠传输服务各层均可选择实现 不局限于此层 实现机制 可被应用到各层协议中\n停止-等待协议SW 属于自动请求重传ARQ Automatic Repeat reQuest\n基本过程：发送方发送分组\u0026ndash;\u0026gt;接收方校验正确给发送方发送ACK接收信号\u0026ndash;\u0026gt;接收方再次发送。若校验错误 接收方返回NAK否认信号 发送方重传 改进： 超时重传：设定超时计时器 若到达重传时间发送方未接收到信号则重传 设定重传时间略大于平均往返时间 数据链路层点对点往返时间较为确定——重传时间较好设定 设置编号：避免分组重复（接收方返回信号丢失后重传原数据） 只需保证与上次发送的数据不同——一个比特即可 （避免确认分组迟到）接收端返回信号进行编号——与发送方的编号一致 数据链路层一般不会出现 信道利用率$U$：往返时延$RTT$远大于数据帧发送时延$T_D$时，信道利用率非常低 回退N帧协议GBN 又名滑动窗口协议\n基本过程：发送方设置发送窗口，同时将窗口内的所有分组发送（需编序号）\u0026ndash;\u0026gt;接收方接收到后发送成功接收信息\u0026ndash;\u0026gt;接收窗口滑动按序号接收\u0026ndash;\u0026gt;发送方收到确认后 发送窗口向前滑动 发送窗口尺寸的取值范围：小于等于序号（eg.0~7 则最大为7） 若等于8 接收方无法分辨新旧数据分组 接收方窗口尺寸=1 差错：发送的信息中某分组错误，整个窗口的数据由于不能匹配被接收方丢弃\u0026ndash;\u0026gt;发送方也重传未被接收的帧eg.从有误码的帧开始（发生超时重传时）==\u0026gt;回退N帧 优化： 累计确认：接收方可以在收到几个数据分组后对按序到达的最后一个分组发送确认$ACK_n$，表示n前的都接收了 发送方收到多个重复确认时 可在重传计时器超时前开始重传 选择重传协议SR 不能再进行累计确认 需要逐一确认 实现发送方仅重传错误分组\n基本要求：发送窗口尺寸$W_T\u0026lt;=2^{n-1}$ \u0026amp; 接收窗口尺寸调整 一般设置与发送窗口尺寸相同（或小于） 若发送方大于，eg.发送方设置为5（最大为4）接收方0号丢失，发送方向后滑到5 6 7 0号，则0号混淆 过程：发送方收到未按序到达的确认分组信号时，对其进行记录，避免超时重发，且不可整体向前滑动（必卡在未收到确认的信号之后） 点对点协议PPP 最广泛的点对点数据链路层协议\n为传输的各种数据报提供标准方法：封装成帧+链路控制协议LCP+一套网络控制协议NCPs NCPs每个协议支持不同的网络层协议 帧格式 0x7E十六进制==\u0026gt;01111110二进制 透明传输实现： 面向字节的异步链路——插入转义字符的字节填充法 面向比特的同步链路——插入0的比特填充法 差错检测：对每个收到的PPP帧进行CRC检验 不通过的帧丢弃 向上不提供可靠传输 媒体接入控制MAC Medium Access Control\n基本概念：共享信道需协调多个发送与接收站点对一个共享传输媒体的占用 类型：静态划分信道 / 动态接入控制 静态多在物理层中应用 动态包括受控接入（以下两分类）与随机接入eg.共享式以太网 集中控制：主站轮询 分散控制：令牌轮流 静态划分信道 信道复用：一条物理线路同时传输多路用户信号 常见复用技术： 频分复用FDM：占用不同的频带资源 时分复用TDM：占用不同时隙 每个时隙周期出现 波分复用WDM：占用不同波长 码分复用CDM：（多用于多址接入 码分多址CDMA）各用户可同时在同样的频带上通信 使用不同码型 每个比特时间被划分为m个短间隔（码片Chip） 每个站被指派唯一的m bit码片序列 若要发送比特1 则发送自己的码片序列 0 则发送码片序列反码 每个站的码片序列必相互正交且不同==\u0026gt;接收站对收到的叠加信号与各站的码片序列相乘，得到-1则该站发送了0，得+1则发送了1，其它则未发送 动态接入控制——随机接入 CSMA/CD （早期以太网）载波监听多址接入/碰撞检测 多址接入MA：多站连接在一条总线上 竞争使用 载波监听CS：每个站发送帧前先检测总线上是否有其他站点在发送，若有96比特时间空闲，则发送 CD：每个正在发送帧的站边发送边检测碰撞，若发生则立即停止发送，过段时间继续 争用期：主机最多经过多久可检测到本次发送是否遭受澎湖藏 最小帧长：若过小，发送方不知发生了碰撞 最大帧长：若过大，其它主机长时间无法发送信号，接收端也可能溢出 截断二进制指数退避算法：退避时间 = 基本退避时间（争用期） x 随机数r r从0,1,…,$2^k-1$中随机取，$k=min[重传次数,10]$ 退避时间随重传次数增加而增大（动态退避） 可减小发生碰撞的概率 信道利用率——$S=\\frac{T_0}{T_0+\\tau}$ $T_0$为发送成功时间 $2\\tau$为争用期 CSMA/CA （无线）CA 碰撞避免\n帧间间隔：（802.11标准规定）所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧 短帧间间隔SIFS：分隔开属于一次对话的各帧 DCF帧间间隔DIFS：在DCF方式中用来发送数据帧 \u0026amp; 管理帧 相关问题与解答： why：源站检测到空闲后还要等待DIFS？ 让优先级更高的帧（其他站上）先发送 why：目的站正确接收数据帧后还要等待SIFS？ 完成从接收到发送的状态切换 why：其他站要退避随机时间？ 避免同时发送 使用退避算法的情况： 发送数据帧之前检测到信道忙 每次重传数据帧 每次成功发送后要连续发送下一帧（避免一个站点长时间占用信道） 退避算法：站点为退避计时器设置一个随机的退避时间，计到零开始发送，若信道转忙则冻结等其转闲后经过DIFS后继续计数 进行第i次退避时，退避时间在0,1,…,$2^{2+i}+1$中随机选择并乘基本退避时间 基本退避时间 = 一个时隙的长度 第六次退避后 不再增加（达到255） 减少选择相同退避时间的概率 允许对信道进行预约 发送数据帧前发送短控制帧 = 请求发送RTS RTS碰撞则执行退避算法重传RTS 目的站收到且空闲 发送响应控制帧 = 允许发送CTS 发送站收到并等待SIFS后可发送 其他站收到CTS后推迟接入 虚拟载波监听：监听到RTS/CTS/数据帧，即可知道信道被占用的持续时间 减少隐蔽站带来的碰撞问题 MAC地址 IP地址 ARP协议 MAC地址是以太网的MAC子层使用的地址——数据链路层中 IP地址是TCP/IP体系结构网际层使用的地址 ARP协议属于TCP/IP的网际层 可以通过IP地址获取到MAC地址\nMAC地址 链路层首部封装\n（多个主机在同个广播信道上）需要唯一的数据链路层地址 每个帧中需携带标识发送主机和接收主机的地址——MAC地址 一般被固化在硬件上 = “硬件地址” = “物理地址”（win系统中）但不属于物理层 每个网络适配器都有一个全球唯一的MAC地址——对各接口的唯一标识（而非设备） （IEEE 802局域网）MAC地址格式：组织唯一标识符OUI（三字节） + 网络接口标识符（三字节） OUI由注册管理结构分配 后3字节由厂商分配 通常将每4个比特用一个16进制数表示 = 12个的16进制数 MAC地址的第1字节的b0位（第0位）取0表示单播地址 取1表示多播地址 MAC地址的第1字节的b1位（第1位）取0表示全球管理 取1表示本地管理 MAC地址类型👆： 全球+单播：厂商生产网络设备时固化 全球+多播：标准网络设备支持的 本地+单播：网络管理员分配 覆盖全球单播 本地+多播：用户配置主机软件 表明其对多播组的从属关系 地址发送顺序：第一字节-\u0026gt;第六字节 b0-\u0026gt;b7 单播/广播/多播MAC地址：接收方地址（广播填全F 多播填多播组地址） 若多播组地址在接收方的多播组列表中 则接收 IP地址作用（网络层） 若要接入因特网 = IP地址+MAC地址 / 若不接入 只需MAC地址\n组成：网络编号+主机编号 主机编号：标识同一网络上不同主机/路由器各接口 数据包转发过程： 每个链路结束 目的MAC地址与源MAC地址都会改变 IP地址始终如一 每个设备只知下一设备的IP地址 不知MAC地址——地址怎样转变？ARP协议 ARP协议 广播\n封装在MAC帧中 所有主机检查是否请求的是自己的MAC地址 若否则忽略 若是，（添加到自己的ARP高速缓存）则单播发送自己的MAC地址 原请求端将其保存到自己的ARP高速缓存中 ARP只能在一个网络/一个链路中使用 不可跨网络 集线器与交换机 集线器：逻辑上仍是总线网 + 只在物理层工作（不进行碰撞检测）+ 一般有少量的容错能力 集线器HUB在物理层扩展以太网：集线器连接其它集线器 以太网交换机：多接口（全一般双工）+ 能同时联通多对接口 + 工作在数据链路层（包括物理层） 帧交换表（自学习算法建立）：查找帧的目的MAC地址对应的接口号 帧的转发方式：存储转发 \u0026amp; 直通交换（基于硬件的交换矩阵） 对比：集线器会扩大冲突域 交换机会隔离冲突域 以太网交换机自学习\u0026amp;转发帧 自学习：盲目泛洪（发给所有接口）——记录接收接口的号（及其MAC）与发送的接口号（及其MAC） 到期自动删除记录 以太网交换机生成树协议STP 提升以太网可靠性：添加冗余链路（负面效应：网络环路（问题👇） 广播风暴——大量消耗网络资源 无法正常转发其他数据帧 主机收到重复的广播帧 帧交换表反复振荡（同一MAC地址但接口一直变化） （改良）生成树协议STP——自动计算并构建一个逻辑上没有环路的网络——树形 网络物理拓扑发生变化时，生成树需重新计算 VLAN虚拟局域网 多个以太网交换机互连起来的交换式以太网 所有站点属于同一广播域\n广播域过大弊端：广播风暴 + 难以管理维护 + 潜在的安全问题 分割广播域方法：路由器隔离（工作在网络层） / VLAN VLAN：将设备划分为与物理位置无关的逻辑组的技术 VLAN实现机制 IEEE 802.1Q帧——在MAC帧中源MAC地址后插入4字节VLAN标记 交换机收到普通的以太网帧时 插入标记 = “打标签” 转发时 可能删除 = “去标签” 交换机端口类型：（交换机各端口的缺省VLAN ID 👇称为PVID） Access——一般连接用户计算机 只能属于一个VLAN PVID与端口所属VLAN的ID同 若帧中VID与端口PVID同 则去标签并转发 否则不转 Trunk——交换机间/交换机与路由器间的互连 可以属于多个VLAN 用户可设置其PVID值 发送：对VID=PVID的帧——去标签后转发 / 不等的帧——直接转发 接收：接收未打标签的帧 根据接收帧的那个端口的VLAN打标签 Hybrid——Trunk Access能用的地方都能用 其它与trunk类似 除发送处理方法：查看帧的VID是否在端口的去标签列表中（其余同👆） 应用如下👇 网络层 实现网络互连（路由器）——数据包传输\n三个问题：向运输层提供的服务 + 网络层寻址 + 路由选择 TCP/IP协议栈的网络层使用网际协议IP so 被称为网际层 提供的服务 面向连接的虚电路服务 可靠通信由网络保证 必建立网络层的连接（虚电路VC）——通信双方沿已建立的虚电路发送分组 目的主机地址在建立后不再需要 在分组首部携带VC编号即可 存储转发方式 通信结束后 释放VC 无连接的数据报服务 因特网使用——网络造价低\n可靠通信由用户主机保证 不需建立网络层连接 每个分组可走不同路径 每个分组首部需携带目的主机的完整地址 监测到拥塞时可合理丢弃IP分组\nIPv4地址 概述 因特网上每个主机/路由器的每个接口分配全世界unique的32bit标识符\n发展：分类编址\u0026ndash;\u0026gt;划分子网\u0026ndash;\u0026gt;无分类编址 表示方法：点分十进制表示方法——每8bit分为一组 用.隔开 分类编址 五类地址👆 ABC类可分配给主机/路由器的各接口 主机号全0 = 网络地址 不能分配给主机（···） 主机号全1 = 广播地址 不能分配···——该网络上所有地址都可收到目的地址为广播地址的信息 A类：最小网络号0保留不指派 最大网络号127作为本地环回测试地址不指派 最小本地环回测试地址：127.0.0.1 （主机号不能全0全1） B类：最小网络号128.0（除首位全0）最大网络号191.255（除二位全1） C类：类似B类👆 网络号范围192~223 划分子网 子网掩码——表明IP地址的主机号中有几个比特被借走作为子网号 连续1 = 网络号（不变）+子网号（占原来主机号的位置） 连续0 = 主机号 运算即得所在子网的网络地址 默认的子网掩码：未划分子网时使用的子网掩码 eg.255.0.0.0（A类） 无分类编址 无分类域间路由选择CIDR\n编写方法：斜线记法 eg.128.14.35.7/20 20表示网络前缀所占的比特数（后面的是主机编号） 将网络前缀都相同的连续的IP地址组成CIDR地址块 聚合C类网数量 = 地址数量 / C类网前缀数量 $2^8$ 主机号依然不可全0全1\n路由聚合（构造超网）——eg. 一个路由可以保存其连接的网络的地址的共同前缀 发送给其他路由 = 路由聚合后的目的网络地址（主机号设为0） IPv4地址的应用规划 定长的子网掩码FLSM：用同个子网掩码划分子网 每个子网需要的IP地址数量不同时 会造成浪费 变长的子网掩码VLSM：不同子网掩码划分——每个子网分配的IP地址数量不同 起点位置选择子网中块数量（初步分配的地址数量eg.6台主机+1路由器地址+1广播1网络=9 则选16）的整数倍 可以从主机多的子网开始分 IP数据报的转发与发送 =主机发送+路由器转发 以下忽略ARP与以太网交换机的工作过程\n数据报传递方式：直接交付（以太网交换机可交付） \u0026amp; 间接交付（需路由器中转） 主机发送过程：主机A将自己的IP与子网掩码做\u0026amp;运算，得到网络地址—-\u0026gt;将目标IP与子网掩码\u0026amp; 若网络地址不同\u0026ndash;\u0026gt;需要路由器转发（不在同一子网） how主机知道路由器？ 给每个主机设置默认网关 即对应路由器的IP地址 路由器转发过程：检查IP数据包首部是否出错（差错校验）（错则丢弃并通知源主机）\u0026ndash;\u0026gt;根据数据报的目的地址在路由表中查找匹配条目（与路由条目中的地址掩码\u0026amp;，检查网络号是否匹配）\u0026ndash;\u0026gt;转发 若不匹配则丢弃并通知源主机 采用最长前缀匹配 注意：广播数据报路由器不会转发（隔离广播域） 静态路由配置及路由环路问题 静态路由配置：人工配置路由表（指定目的网络地址与下一跳的接口） 不能及时适应网络状态（拓扑 流量等）的变化 可能导致路由环路的原因： 配置错误 聚合了不存在的网络 网络故障 特殊概念 默认路由：具有相同下一跳的不同目的网络的路由条目 可以将目的网络写作0.0.0.0/0（静态） 其它的所有目的网络都转向此接口 特定主机路由：设置目的网络地址为目的主机的IP 子网掩码有32位1（静态） 下一跳还是在特定主机连接的路由器接口 可能的路由环路 配置错误（配置了循环的下一跳接口）：IP数据报首部设置生存时间TTL 进入路由器后减一 若某次进入后TTL=0 则丢弃 聚合不存在的网络（本应将错误IP丢弃）：可添加针对不存在的网络的黑洞路由 即下一跳设置为null0 网络故障（某IP地址的网络出现故障 路由器自动丢弃对应路由表条目）：添加针对该网络的黑洞路由 路由选择协议 概述 静态路由选择：人工配置——小规模网络 不能及时适应网络状态变化 动态路由选择：自动获取路由信息（by路由选择协议） 特点与👆反 因特网路由选择协议特点：自适应（动态） + 分布式（路由器间交换路由信息） + 分层次（因特网划分为许多较小的自治系统AS） 因特网的分层次路由选择协议：（网关 = 路由） 自治系统内部采用内部网关协议IGP AS间采用外部网关协议EGP 常见的内部网关协议： 路由信息协议RIP——基于距离向量 内部网关路由协议IGRP——基于距离向量 增强型内部网关路由协议EIGRP——结合距离向量与链路 开放式最短路径优先OSPF——基于链路 中间系统到中间系统IS-IS——基于链路 常见EGP：边界网关协议BGP 路由器基本结构：路由选择部分（周期性与其它路由器交流并更新） + 分组转发部分 转发表from路由表 路由报文可更新路由表 具有输入输出缓冲区 RIP 最先得到广泛使用的IGP 用UDP协议直接封装报文 后由IP协议封装\n要求：AS内每个路由器维护自己到其它每个网络的距离记录——距离向量D-V（一组距离） 用跳数Hop Count作为度量 直连网络\u0026ndash;路由器 = 1；非直连网络\u0026ndash;路由器 = 经过的路由器数+1 一条路径最多15个路由器 = 只适用小型互连网 特点： 若有多条距离相等的路由 可进行等价负载均衡 包含要点：仅与相邻路由器交换信息 + 交换路由表 + 周期性交换 基本工作过程 = 路径规划（收敛则找到最短路径）\n更新规则：判断到达网络是否更新\u0026ndash;\u0026gt;下一跳是否相同\u0026ndash;\u0026gt;相同时更新消息 不同时比较路径长短 等于时添加做负载均衡 问题：“坏消息传得慢”（发生故障后👇） = 路由环路/距离无穷计数问题 D-V算法固有问题 减少问题的措施：限制最大路径距离 路由表发生变化时就发送更新报文（触发更新） 不让同一路由信息通过此接口反向传送（水平分割） OSPF 采用Dijkstra提出的SPF（最短路径算法） 基于链路 + 不会产生路由环路 + 不限制网络规模 收敛快 实现： 通过交互问候（Hello）分组 维护邻居关系 封装在IP数据报中 发往组播地址224.0.0.5 每个路由器产生LSA链路状态通告 包括直连网络链路状态信息 \u0026amp; 邻居路由器的 被封装在链路状态更新分组LSU中 洪泛法发送 每个路由器用LSDB链路状态数据库存储LSA 通过洪泛法 最终所有路由器的LSDB一致 基于LSDB进行SPF计算 构建路由表 五种分组类型：Hello 数据库描述 链路状态请求 链路状态更新 链路状态确认 周期时间/更新信息/回应其它路由器请求时 发送链路状态更新分组 多点接入网络中：选举指定路由器DR \u0026amp; 备用的指定路由器BDR 所有的非DR BDR只与其建立邻居关系 将一个AS划分为若干的区域 有自己的标识符 所有接口在区域内 = 区域内路由器IR 区域边界路由器ABR 与其他区域联通（两接口 一对外一对内） 主干路由器BBR 主干区域内的路由器 自治系统边界路由器ASBR 与其它自治系统交换信息 BGP 自治系统内度量采用的代价不同 故自治系统间不可用代价作为度量\n每个AS需有至少一个BGP发言人 不同AS的发言人交换路由信息前需建立TCP连接 端口号179 交换BGP报文以建立BGP会话 以此交换路由信息 交换网络可达性信息 后找出到达各AS较好的路由——无环连通图 四种报文（BGP-4）：打开 更新 保活 通知 IPv4数据报首部格式 IP数据报\n固定部分20字节 + 可变部分40字节 固定部分中每个区域都以4字节为单位（要么4要么8要么····） 解释： 版本：通信双方采用的IP协议版本必相同 首部长度：最小取值为5（仅有20字节固定部分） 最大15（20固定+40可变） 可选字段：长度1字节~40字节 填充字段：确保首部长度为4字节的整数倍 区分服务：区分不同等级的服务质量 总长度 = 首部 + 数据载荷 解释：根据以太网MTU将数据载荷分片以封装成帧 标识：同一数据报的各分片应具相同标识 标志：3bit DF位（1不许分片 0允许分片） MF位（1后还有分片 0此为最后分片） 保留位（必为0） 片偏移：分片数据报的数据载荷相对原数据报偏移的单位（以8字节为单位表示 eg.偏移32个字节则在此写4） 解释： 生存时间TTL：原来以秒为单位 现在以跳数为单位 （路由器转发时减一若为0则丢弃 协议：指明数据部分是哪种协议单元（ICMP-1 IGMP-2 TCP-6 UDP-17 IPv6-41 OSPF-89） 首部检验和：差错检查 比CRC简单 = “因特网检验和” IPv4所有路由器都要检查 IPv6不再检查 网际控制报文协议ICMP 更有效地转发IP数据报 提高交付成功地机会\n特点：主机/路由器用ICMP发送差错报告报文\u0026amp;询问报文 + 被封装在IP数据报中 差错报告报文 终点不可达：不能交付数据报 向源点发送 源点抑制：路由器/主机由于拥塞丢弃数据报 向源点发送（源点发送速率放慢） 时间超过：TTL 丢弃时向源点发送 分片不完整时 全部丢弃 参数问题：首部中检验与字段发现误码 改变路由（重定向）：路由器将改变路由报文发送给主机 不发送的情况：对ICMP差错报文不发 第一个分片的后续报片 具有多播地址的数据报 特殊地址（127.0.0.0等） 询问报文 回送请求与回答——测试目的站是否可达（收到的主机必须回答） 时间戳请求和回答——时钟同步 测量时间 应用 分组网间探测PING（packet Internet groper） 应用层直接使用网际层的ICMP 不通过运输层的TCP or UDP 跟踪路由traceroute 测试IP数据报从源主机到目的主机经过哪些路由器（原理：时间超过差错报告） 应用层直接使用网际层的ICMP 不通过运输层的TCP or UDP Unix中在运输层使用UDP 虚拟专用网VPN网络地址转换NAT VPN virtual private network VPN中各主机分配的地址是某机构可自由分配的专属地址（IPv4地址紧缺） “IP隧道技术” 分类：内联网VPN \u0026amp; 外联网VPN NAT network address translation 使用内部专用地址的专用网络用户共享少量外部全球地址以访问因特网 过程：NAT路由器为发送端分配一个全球IP地址 并修改数据报的源地址 并记录内外网地址对应关系 可以将运输层端口号与IP一起转换=一个全球IP地址可使多个（内部）主机与外通信 IP地址同 端口号不同 网络地址源端口号转换NAPT else：外网主机不能首先发起通信（NAT屏蔽了内网主机的网络地址）——NAT穿越技术 运输层 运输层概述 提供面向连接的TCP \u0026amp; 无连接的UDP 运输应用进程 不同进程用不同端口接收（非物理意义上的端口） 运输层端口号 复用 分用 端口号 需用统一方法对TCP/IP体系的应用进程标识——端口号区分（16比特） 端口号只具有本地意义——本计算机应用层的各进程 熟知端口号 登记端口号 短暂端口号 发送方复用 接收方分用 应用报文（不同端口）\u0026ndash;\u0026gt;UDP复用/TCP复用\u0026ndash;\u0026gt;用户数据报（UDP封装）/报文段（TCP封装）\u0026ndash;\u0026gt;IP复用 成为IP数据报\u0026ndash;\u0026gt;接收方对IP分用成用户数据报/报文段\u0026ndash;\u0026gt;分用成应用报文 应用层的不同协议在运输层使用不同协议的不同端口号（eg.http-\u0026gt;TCP 80 https-\u0026gt;TCP 443） 在网络层都使用IP协议 UDP TCP对比 UDP 用户数据报协议——无连接（过程） 支持单播多播广播 对应用层报文不合并不拆分 误码 丢失不处理 数据报首部仅8字节 TCP 传输控制协议——三报文握手建立连接 四报文挥手释放连接 仅支持单播 面向字节流 不保证传输的数据大小完全一致（交付时不检查传输了多少数据） 不会误码 丢失等 TCP流量控制 让发送方发送速率不过快 来得及接收——滑动窗口实现\n普通的滑动窗口算法（类帧） 接收方发送ACK ack=n表示n之前的数据已收到 设置零窗口持续计时器——到时时向接收方发送零窗口探测报文段 得到窗口大小 TCP拥塞控制 理想的拥塞控制——网络吞吐量=输入负载 输入负载过高 吞吐量不变 无拥塞控制时 输入负载过大吞吐量反而减小 方法 维护拥塞窗口变量——超时重传时判定为网络拥塞 发送方将拥塞窗口作为发送窗口\n维护慢开始门限ssthresh状态变量——大于拥塞窗口时 采用慢开始算法 小于时采用拥塞避免算法 等于时均可使用 不拥塞时拥塞窗口增大 拥塞时减小 慢开始算法：每接到一个确认 指数级增大窗口 拥塞避免算法：窗口只加一 若超时重传——慢开始门限设为一半 窗口设置为1 快重传算法：（尽快重传）发送方收到三个连续的重复确认就重传 接收方立即发送确认 收到失序报文段立即发出重复确认 部分丢失不会认为是拥塞\n快恢复算法：收到3个重复确认后执行 发送方将慢开始门限与拥塞窗口调整为当前窗口的一半 执行拥塞避免 TCP超时重传时间的选择 略大于往返时间\n利用每次的往返时间RTT样本 计算加权平均往返时间👇 超时重传时间RTO：$RTO=RTT_S+4*RTT_D$ $RTT_D$ RTT偏差的加权平均👇 （针对超时重传时测不准RTT问题）Karn提出不采用超时重传的RTT样本 时延突然增大——修正：出现超时重传时$RTO$变为原来2倍 TCP可靠传输实现 以字节为单位的滑动窗口实现——类似报文段（不赘述）\n发送方窗口大小根据接收方确定 但同时刻不一定总一样大 TCP未明确规定如何处理不按序到达的数据 通常先临时存放 收到缺失的数据时再按序交付（应用进程） 接收方必须有累计确认\u0026amp;稍待确认 全双工通信 TCP运输连接管理——连接建立 解决的问题：确知对方存在 + 协商参数 + 分配运输的实体资源 具体过程 三报文握手\nTCP服务器被动等待TCP客户的连接请求 客户主动发起连接请求 过程： TCP服务器创建传输控制块 从关闭状态进入监听状态——被动打开连接 客户创建传输控制块 向服务器发送连接请求报文段 进入同步已发送状态 SYN=1 seq=x 表示其为连接请求报文段 不能携带数据——主动打开连接 服务器发送对TCP连接请求的确认 进入同步已接受状态 SYN=1 ACK=1 ack=x+1 seq=y 也不能携带数据 客户发送对确认的确认 进入连接已建立状态（数据load部分可以携带请求内容） ACK=1 seq=x+1 ack=y+1 服务器接收后 进入连接已建立状态 客户与服务器的seq由各自决定 但ack序号与对方的seq有关（+1） 不能两握手的原因：避免失效的连接请求报文段传输到服务器（服务器直接开启连接已建立状态 但客户不会理睬 浪费资源） 连接释放 四报文挥手\n过程： 客户发送连接释放报文段 进入终止等待1状态——主动关闭 FIN=1 ACK=1 seq=u ack=v seq是客户发送的最后字节序号+1 ack是客户收到的（服务器发送的）最后字节序号+1 服务器发送普通确认报文段 进入关闭等待状态 并通知上层应用 ACK=1 seq=v ack=u+1 ——此时进入半关闭状态 客户不发送只接受 服务器继续发送没有发完的数据 服务器发送连接释放报文段 进入最后确认状态（应用数据发完 让其关闭）——被动关闭 FIN=1 ACK=1 seq=w ack=u+1 seq表示服务器自己发送的最后数据 ack是对客户发来的信息的重复确认 客户发送普通确认报文段 进入时间等待状态 ACK=1 seq=u+1 ack=w+1 seq要消耗一个序号 服务器接收后进入关闭状态 客户发送后经过2MSL时间进入关闭状态 MSL——最长报文段寿命 若客户直接关闭 确认报文段若遗失 服务器无法关闭 保活计时器：服务器每收到一次客户数据就重重启保活计时器——若保活周期内未收到 则发送探测报文段——连续发送探测不回复 则服务器关闭连接 TCP报文段首部格式 固定首部20字节 + 扩展（可变）首部最大40字节 组成： 源端口——16bit 标示 发送 报文段的 应用进程 端口号 目的端口——16bit 接收报文段的应用进程端口号 序号——32bit 本报文段数据load的第一个字节序号 确认号——32bit 若为n 表示n-1号及以前的数据都接收 需要n号数据 *ACK位为1时才有效 数据偏移——数据load起始处到报文段起始处有多远 = TCP报文段首部长度（以4字节为单位） 窗口——发送方的接收窗口大小 流量控制 校验和——检查首部与数据load（计算时要在报文段前加12字节伪首部） SYN同步标志位 终止标志位FIN 复位标志位RST（复位TCP连接）——取1时 表示TCP连接出现异常 需重新建立连接 可用来拒绝非法报文段 拒绝打开TCP连接 推送标志位PSH：若为1 该报文段会尽快上交应用进程 紧急功能：紧急标志位URG（取1有效）+紧急指针（指明紧急数据长度） = 紧急数据放到发送缓存最前 立刻封装后发送——接收缓存中同 扩展首部：选项部分可添加很多选项👇 填充部分将保证首部能被4整除 应用层 概述 最顶层\n各层应用 客户/服务器方式与对等方式 C/S方式与P2P方式 client/server \u0026amp; peer to peer\nC/S 客户计算机\u0026amp;服务器计算机\n客户请求服务 服务器提供服务 服务器始终运行 等待请求 \u0026amp; 具有固定端口号 \u0026amp; 运行服务器的主机具有固定的IP地址 服务集中型——会出现服务器跟不上客户机请求的情况——使用计算机群集（服务器场）构建虚拟服务器 P2P 对等方互为请求与服务方 双方直接通信——服务分散型 可扩展性（规模增大 性能不降低） 动态主机配置协议DHCP 通过DHCP自动获取网络配置信息 C/S类型\n用UDP用户数据报传输——计算机加入新网络时可自动获取网络配置信息 主要过程：客户寻找DHCP服务器（广播）——服务器提供IP地址租用——客户接收租约——服务器确认租约——客户对IP地址续约——客户随时解除租约 客户未获得IP地址时 使用0.0.0.0 挑选地址时 使用ARP确保挑选的地址未被占用 使用前 客户用ARP检查 DHCP中继代理：给与客户主机直接相连的路由器配置DHCP服务器的IP地址 使其成为中继代理——将寻找的数据报单播给服务器 否则会丢弃客户的寻找DHCP服务器数据报 域名系统DNS 域名便于记忆 但需用IP地址进行访问 = DNS对域名解析成目标服务器的IP地址\n采用层次结构的命名树作为域名 使用分布式的域名系统==\u0026gt;大多域名在本地解析 UDP封装 层次树状结构的域名系统 eg.···.三级域名.二级域名.顶级域名 不区分大小写 完整域名不超过255字符 特点：各级域名由上级域名管理 分类： 顶级域名TLD分类：国家 通用（com gov等） 反向域（IP地址反向解析为域名） 转换：分布在各地的域名服务器实现转换 根域名服务器 顶级域名服务器 权限域名服务器（二级三级等） 本地域名服务器（默认···） 权限域名服务器——管理某个区的域名 本地——代理作用 转发报文到其它域名服务器的等级结构 解析过程：递归查询 / 迭代查询 递归：主机-\u0026gt;本地-\u0026gt;根-\u0026gt;顶级-\u0026gt;权限-\u0026gt;反向回 迭代：主机-\u0026gt;本地-\u0026gt;返回顶级地址 主机-\u0026gt;顶级··· 主机-\u0026gt;权限 主机到本地采用递归 其余采用迭代 高速缓存：存放最近查询过的域名与IP地址——为每个项目设置计时器 超时项删除——不需DNS查询 文件传送协议FTP C/S方式 可用ftp://balabal域名访问\n提供交互式访问 允许客户指明文件类型与格式 存取权限 屏蔽系统细节 适合在异构网络任意计算机间发送文件 工作原理： 客户与FTP服务器建立传送控制命令的TCP连接（FTP端口号20） （客户告知）服务器发起传送文件的TCP连接——主动模式（数据连接）（端口号21） 客户发起传送文件的TCP连接——被动模式（数据连接）（FTP随机端口号） 电子邮件 C/S\n组成：用户代理（email客户端软件） + 邮件服务器 + 电子邮件所需协议（包括发送与接收协议） 服务器向用户发送——POP3协议（其它为SMTP） 全部建立TCP连接 常用的发送协议——SMTP 常用的接受协议——POP3 SMTP 发送方周期性扫描邮件缓存 建立TCP连接（端口号25） 发送14条SMTP命令 接收方返回21种SMTP应答 针对发送方地址 接收方地址 邮件内容 结束符等都需交互 电子邮件发送 格式：信封+内容（首部+主体） SMTP只能传送ASCII码数据——MIME多用途因特网邮件扩展 发送方非ASCII内容经过MIME转译为ASCII后给SMTP 接收方同 MIME增加了邮件首部字段 内容格式 传送编码等 也应用于HTTP 接收 常用读取协议：POP邮局协议 IMAP因特网邮件访问协议——TCP 端口POP110\u0026amp;IMAP143 IMAP4允许用户操控邮件服务器中的邮箱——联机协议 万维网email 使用HTTP协议与邮件服务器交互 万维网WWW 运行在因特网上的分布式应用 利用超链接将不同网站的网页链接\n使用统一资源定位符URL指明位置 格式：\u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt; 万维网文档：HTML+CSS+JavaScript——通过浏览器渲染 html超文本标记语言——网页结构与内容 css层叠样式表——审美 js脚本——控制网页行为 HTTP HTTP超文本传输协议——定义服务器怎样请求WWW文档 \u0026amp; 服务器怎样传回浏览器 HTTP/1.0采用非持续链接 每次请求文件都需建立TCP 1.1采用持续连接 非流水线方式——收到一个请求的响应后才发送下一个请求 流水线：收到响应前 可不断发送请求 请求报文格式👇：（面向文本 每个字段都是ASCII码串 长度不确定） 报文格式：状态码202——正常 400——请求错误 cookie——记录用户信息（浏览器与www服务器建立TCP） 在服务器为用户生成唯一的cookie识别码 给浏览器返回识别码 else 缓存与代理服务器——web缓存（客户机 中间系统（代理服务器）上都可） 最近的请求与响应暂存在disk ","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ca href=\"https://www.bilibili.com/video/BV1c4411d7jb/\" style=\"color: black; text-decoration: underline;\"\u003e所有图片来自：计算机网络微课堂（有字幕无背景音乐版）\u003c/a\u003e\n\u003ch2 id=\"概述\"\u003e概述\u003c/h2\u003e\n\u003ch3 id=\"概念\"\u003e概念\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e计算机网络 由结点node\u0026amp;链路link构成\n\u003cul\u003e\n\u003cli\u003e计算机网络可由交换机连接\u003c/li\u003e\n\u003cli\u003e多个计算机网络可由路由器连接成互连网（协议不定）\u003c/li\u003e\n\u003cli\u003e全球范围的互连网 = 互联网（统一采用TCP/IP协议）\n\u003cul\u003e\n\u003cli\u003eISP 互联网服务提供商\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"组成与功能\"\u003e组成与功能\u003c/h3\u003e\n\u003ch4 id=\"组成\"\u003e组成\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e硬件+软件+协议\n\u003cul\u003e\n\u003cli\u003e硬件：主机（end system端系统） 通信设备balabal\u003c/li\u003e\n\u003cli\u003e协议由硬件软件共同实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e边缘部分+核心部分\n\u003cul\u003e\n\u003cli\u003e边缘 = 直接为用户服务\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e（从逻辑功能）资源子网+通信子网\n\u003cul\u003e\n\u003cli\u003e资源子网 主要是主机\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"功能\"\u003e功能\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e数据通信（最基本最重要）\u003c/li\u003e\n\u003cli\u003e资源共享——硬件 软件 数据\u003c/li\u003e\n\u003cli\u003e分布式处理——eg.复杂任务多计算机处理\u003c/li\u003e\n\u003cli\u003e提高可靠性——eg.互为替代机\u003c/li\u003e\n\u003cli\u003e负载均衡\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"通信方式\"\u003e通信方式\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e电路交换eg.电话 通信时始终占用端到端线路资源 but 释放/建立连接需要额外时间开销 利用率低\u003c/li\u003e\n\u003cli\u003e报文交换eg.电报 无需提前建立连接 存储转发（通信线路可灵活分配） 线路利用率高 支持差错控制 but 报文不定长 不利管理 + 长报文存储转发时间、缓存开销大 + 长报文易出错\n\u003cul\u003e\n\u003cli\u003e存储转发 = 先存储后转发\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e分组交换（现代网络采用）\n\u003cul\u003e\n\u003cli\u003e定长——方便存储转发管理 + 转发时间更少（相对报文交换）+不易出错\u003c/li\u003e\n\u003cli\u003e控制信息占比增加（报文）+ 存在存储转发时延（电路交换）+ 分成多个分组 传输过程中可能出错\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e虚电路交换：虚拟电路建立连接 + 通信双方不独占线路\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"通信方式性能对比\"\u003e通信方式性能对比\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e电路交换 建立连接后再进行数据传送 最后连接释放\u003c/li\u003e\n\u003cli\u003e报文交换 中间节点需接收完整报文后再进行解析与转发\u003c/li\u003e\n\u003cli\u003e分组交换 分组进行报文交换\n\u003cimg loading=\"lazy\" src=\"image.png\" alt=\"alt text\"  /\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"分类\"\u003e分类\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e分布范围 广域网WAN + 城域网MAN + 局域网LAN + 个域网PAN\n\u003cul\u003e\n\u003cli\u003eWAN多采用以太网 MAN 几乎全部采用以太网技术（城域网多归为局域网）\n\u003cul\u003e\n\u003cli\u003e局域网可通过路由器接入广域网\n\u003cimg loading=\"lazy\" src=\"image-1.png\" alt=\"alt text\"  /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e个域网 eg.蓝牙 Zigbee等设备\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e传输技术：广播式网络 \u0026amp; 点对点网络\u003c/li\u003e\n\u003cli\u003e拓扑结构：\n\u003cul\u003e\n\u003cli\u003e总线形 广播式 存在总线争用问题\u003c/li\u003e\n\u003cli\u003e环形结构 广播式 令牌顺环形传递 有令牌才发数据 eg.令牌环网\u003c/li\u003e\n\u003cli\u003e星形结构 中央设备实现数据点对点传输 eg.以太网交换机连接的设备\u003c/li\u003e\n\u003cli\u003e网状结构 数据通过各中间节点逐一存储转发 eg.由many路由器构建的广域网\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e使用者：公用网 \u0026amp; 专用网\u003c/li\u003e\n\u003cli\u003e传输介质：有线 \u0026amp; 无线\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"性能指标\"\u003e性能指标\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e信道：向某一方向发送信息的通道（一条发送信道+一条接受信道 = 一个通信线路）\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003e速率：连接到网络上的节点在信道上传输数据的速率\n\u003cul\u003e\n\u003cli\u003e常用单位：bit/s bps（也会用B 1B=8b）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e带宽：某信道能传送的最高数据率\u003c/li\u003e\n\u003cli\u003e吞吐量：单位时间通过某网络（or信道/接口）的实际数据量\u003c/li\u003e\n\u003cli\u003e时延：数据从网络/链路的一端到另一端所需的时间\n\u003cul\u003e\n\u003cli\u003e发送时延 = 传输时延\u003c/li\u003e\n\u003cli\u003e传播时延：电磁波在信道中传播花的时间\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e时延带宽积 = 传播时延 x 带宽\u003c/li\u003e\n\u003cli\u003e往返时延RTT = 发送方\u003cstrong\u003e发送完\u003c/strong\u003e数据的时间到\u003cstrong\u003e完全接收\u003c/strong\u003e确认信息的时间\u003c/li\u003e\n\u003cli\u003e信道利用率 = 有数据通过的时间/利用信道的总时间\n\u003cul\u003e\n\u003cli\u003e利用率过低 = 浪费带宽 过高 = 易网络拥塞\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"分层结构\"\u003e分层结构\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e同个功能可由不同层实现 结构不固定\u003c/p\u003e","title":"计算机网络"},{"content":" Bi-RRT 原理 基本名词 状态空间：系统全部可能状态的集合 RRT原理 RRT(Rapidly exploring Random Tree 快速随机搜索树)是一种全局规划算法\n已知：\n初始状态（起点位置）$q_{start}$ 目标状态（终点位置）$q_{goal}$ 搜索步长 ${\\rho}$ 系统状态空间 $C$ 自由状态空间 $C_{free}$ $C_{free}{\\subset}C$，是 $C$ 中不会发生碰撞的状态集合 目标状态空间 $C_{goal}$ 有 $k$ 个节点的快速随机搜索树 $T_k$ 过程：\n生成随机点：在自由状态空间 $C_{free}$ 中随机采一个状态点 $q_{rand}$，同时保证 $q_{rand}{\\notin}T_k$ 查找最近点：遍历现有的随机搜索树 $T_k$ 寻找与 $q_{rand}$ 最近的节点 $q_{near}$，满足：$DIS(q_{near},q_{rand})\u0026lt;=DIS(q_i,q_{rand})$，其中 $q_{rand}{\\in}T_k$ 计算新节点：从 $q_{near}$ 向 $q_{rand}$ 方向拓展距离 ${\\rho}$ 得到 $q_{new}$，检查该路径是否会发生碰撞。 若会发生碰撞，返回1. 不会发生碰撞，则将 $q_{new}$ 添加到 $T_k$ 中 计算公式： $$q_{\\text {new }}=q_{\\text {near }}+\\varepsilon \\frac{q_{\\text {rand }}-q_{\\text {near }}}{\\left|q_{\\text {rand }}-q_{\\text {near }}\\right|}$$ 到达检查：若节点 $q_{new}$ 实现 $DIS(q_{new},q_{goal})\u0026lt;{\\rho}$，证明已经到达终点，添加 $q_{goal}$ 到 $T_k$ ，搜索结束。若 $DIS(q_{new},q_{goal})\u0026gt;{\\rho}$，返回1. 得到路径：从 $q_{goal}$ 开始反向回溯亲节点直到 $q_{start}$，形成完整路径 $L$ graph LR 生成随机点--\u0026gt;生成新节点 生成新节点--\u0026gt;碰撞检查 生成新节点-----\u0026gt;到达检查 到达检查--\u0026gt;|不成功|重新生成随机点 碰撞检查---\u0026gt;|不成功|重新生成随机点 碰撞检查--\u0026gt;|成功|扩展树 扩展树--\u0026gt;重新生成随机点 到达检查---\u0026gt;|成功|结束 Bi-RRT原理 从起点、终点同时开始随机搜索树的构建\n另外已知：\n从起点开始构建的随机搜索树的新节点为 $q_{new-start}$ 从终点开始构建的随机搜索树的新节点为 $q_{new-goal}$ 从起点开始构建的随机搜索树为 $T_{k-start}$ 从终点开始构建的随机搜索树为 $T_{k-goal}$ 将上文RRT构建过程的4.到达检查修改为如下检查:\n若节点 $q_{new-start}$ 实现 $DIS(q_{new-start},q_{new-goal})\u0026lt;{\\rho}$， 证明已经到达终点，添加 $q_{new-goal}$ 到 $T_{k-goal}$ ，搜索结束。若 $DIS(q_{new-start},q_{new-goal})\u0026gt;{\\rho}$，返回1. 将上文RRT构建过程的5.得到路径修改为如下过程:\n从 $q_{new-goal}$ 开始同时向起点、终点回溯亲节点直到 $q_{start}$ 与 $q_{goal}$，形成完整路径 RRT-Connect原理 与Bi-RRT大致相同\n相对于Bi-RRT，RRT-Connect虽然也是起终点同时开始两条路径，但是从起点方向生成随机点， 用终点的随机搜索树向其进行拓展，反之亦然 分析 出入 （生成随机点）程序实际在 $C$ 中随机采样，也未避免其在 $T_k$ 中；可能造成冗余，在狭窄复杂环境中可能会导致收敛速度减慢 其他问题 （生成随机点）在整个自由状态空间任何位置以相同概率生成随机点，缺少对目标点的指向性 （计算新节点）任何节点的拓展距离都相同，缺少空间敏感性 eg.在空旷位置可以适当增长拓展距离 （计算新节点）遇到障碍时回退到1.生成随机点，可以考虑不回退，通过更换方向避障 （到达检查）用 $DIS(q_{new},q_{goal})\u0026lt;{\\rho}$ 进行到达检查，可能在终点 附近需要不同的标准 改进点 （生成随机点）引入人工势场/其他方法提高随机点指向性 \u0026amp; 在自由状态空间中生成随机点 （查找最近点）最近点的度量方式在基础算法中是最基础的几何距离，可以更改度量方式 剪枝处理——生成的路径有较多折角与累赘路径，可进行剪枝处理 对得到的路径 $L$，从 $q_{goal}$（视为当前起始点 $q_{now}$）开始分别与其后的节点连接并进行碰撞检查 若在连接 $q_{now}$ 与某节点 $q_{collision}$ 时发生碰撞，回退到 $q_{collision}$ 的亲节点 $q_{no-collision-near}$， 并连接 $q_{now}$ 与 $q_{no-collision-near}$ 形成新路径的一部分 从 $q_{no-collision}$ 开始重复3.1.，直到某个 $q_{now}$ 连接到 $q_{goal}$ （到达检查）根据实例对到达检查精度进行修改 路径折角多，可通过样条曲线对路径进行光顺 \u0026amp; 生成路径时进行转角优化 源码中转角通过角度常量进行简单约束，可考虑结合运动方程 实现 生成随机点 def get_random_node(x_min, x_max, y_min, y_max, goal_point=None): # 此处在目标点方向增加生成概率 if goal_point is not None and random.random() \u0026lt;= 0.2: x = goal_point[0] y = goal_point[1] else: x = random.uniform(x_min, x_max) y = random.uniform(y_min, y_max) rnd_node = Node(x, y) return rnd_node 查找最近点 def get_nearest_node_index(node_list, rnd_node): dlist = [] # 遍历随机搜索树 for node in node_list: dis = calc_p2p_dis(node, rnd_node) dlist.append(dis) minind = dlist.index(min(dlist)) # 返回距离最近的点 return minind 计算新节点 def generate_new_node(nearest_node, random_node, extend_length): new_node = Node(nearest_node.x, nearest_node.y) d = math.sqrt((random_node.x - nearest_node.x) ** 2 + (random_node.y - nearest_node.y) ** 2) if extend_length \u0026gt; d: extend_length = d dx = random_node.x - nearest_node.x dy = random_node.y - nearest_node.y if dx * dx + dy * dy == 0: return random_node # 新节点计算公式 new_node.x += extend_length / math.sqrt(dx * dx + dy * dy) * dx new_node.y += extend_length / math.sqrt(dx * dx + dy * dy) * dy # 建立节点的连接（亲节点） new_node.parent = nearest_node return new_node 碰撞检查（圆形/矩形障碍物） def check_collision(node1, node2, obstacleList): for [ox, oy, size] in obstacleList: round = Node(ox, oy) # 增加障碍物的半径为size_new 避免实际情况下的碰撞 size_new = size if node2 is None: return False if calc_p2p_dis(node1, round) \u0026lt;= size_new: return True # 发生碰撞 if calc_p2p_dis(node2, round) \u0026lt;= size_new: return True # 若点线距小于“半径”且该线段可能出现在圆内 if calc_p2l_dis(node1, node2, round) \u0026lt;= size_new and calc_triangle_deg(node1, round, node2) \u0026lt;= 90 and \\ calc_triangle_deg(node2, round, node1) \u0026lt;= 90: return True elif len(obstacle) == 4: # 矩形障碍物用内置函数判断 rect_shape = box(obstacle[0], obstacle[1], obstacle[2], obstacle[3]) if not isinstance(node1, list): line = LineString([(node1.x, node1.y), (node2.x, node2.y)]) else: line = LineString([(node1[0], node1[1]), (node2[0], node2[1])]) if line.intersects(rect_shape): return True return False # 不碰撞 Bi-RRT到达检查与路径生成 # 每次生成一轮（两个）新节点后都对整个路径进行遍历，检查两个路径中可否各有一个点相连生成路径 for node1 in node_list1: for node2 in node_list2: if calc_p2p_dis(node1, node2) \u0026lt;= extend_length and \\ check_collision(node1, node2, obs_list) == False: # 生成从起点到相交点的路径 path1 = [] node = node1 while node is not None: path1.append([node.x, node.y]) node = node.parent path1.reverse() # 反转路径，使其从起点开始 # 生成从终点到相交点的路径 path2 = [] node = node2 while node is not None: path2.append([node.x, node.y]) node = node.parent # 合并两条路径 path = path1 + path2 此处可以优化为只用新生成的点来试验能否连上（已完成 与上文程序类似 省略）\n剪枝 def prune_path(path, obs_list): pruned_path = [path[0]] i = 0 while i \u0026lt; len(path) - 1: found = False # 从终点开始验证 找到第一个不碰撞的（反之有漏洞 for j in range(len(path) - 1, i, -1): if not check_collision(path[i], path[j], obs_list): pruned_path.append(path[j]) # 更新起点 i = j found = True break if not found: # 确保路径前进 i += 1 if pruned_path[-1] != path[-1]: pruned_path.append(path[-1]) return pruned_path 效果 单向RRT\u0026amp;不剪枝\n单向RRT\u0026amp;剪枝\n双向RRT\u0026amp;剪枝\n适用 基于随机采样的树形路径规划算法\n适用于非凸高维状态空间 \u0026amp; 动态环境 可以快速生成可行路径 容易处理包含障碍物、差分运动约束的场景 差分运动约束——每个约束条件由其中两个变量作差构成 需得出满足所有约束条件的解 无需梯度信息 适用未知环境（目标函数未知） Bi-RRT* 原理 在Bi-RRT的基础上增加重写（rewrite）与重布线（rewire）功能\n另外已知：\n生成的随机点 $q_{rand}$ 随机搜索树上距离随机点最近的树节点 $q_{near}$ 从树节点延伸出来的新节点 $q_{new}$ 重写操作搜索范围 $R_{write}$ 重布线操作搜索范围 $R_{wire}$ 随机搜索树上每个节点 $q$ 关联的成本 $C(q)$，定义为： $$C(q)=C(q_{parent})+DIS(q_{parent},q)$$ 过程：\n重写Rewrite 潜在亲节点集合：在Bi-RRT方法的步骤3.计算新节点确认 $q_{new}$ 有效性后，在以 $q_{rand}$ 为圆心， $R_{write}$ 为半径的范围内寻找随机搜索树 $T_k$ 上所有节点，并将节点集合视为 $q_{rand}$ 潜在的亲节点集合 $Q_{near}$ 更新亲节点：计算通过 $Q_{near}$ 中每个亲节点到 $q_{new}$ 的成本 $C(Q_{new})$ 选择成本最小的节点为 $q_{new}$ 的新亲节点，更新 $T_k$。即满足： $$C\\left(q_{\\text {new }}\\right)=\\min \\left{C\\left(q_{\\text {near }}\\right)+\\operatorname{DIS}\\left(q_{\\text {near }}, q_{\\text {new }}\\right) \\mid q_{\\text {near }} \\in Q_{\\text {near }}\\right}$$ 重布线Rewire 计算成本：重写Rewrite的2.操作后，以 $q_{new}$ 为圆心， $R_{wire}$ 为半径的范围内寻找随机搜索树 $T_k$ 上所有节点 $Q_{near}\u0026rsquo;$，逐个比较将这些节点的亲节点设置为 $q_{new}$ 的成本与原成本 $C(q_{near}\u0026rsquo;)$ 更新亲节点：满足下式时将 $q_{near}\u0026rsquo;$ 的亲节点更新为 $q_{new}$： $$C(q_{new})+DIS(q_{new},q_{near}\u0026rsquo;)\u0026lt;C(q_{near}\u0026rsquo;) \\mid q_{{near}}\u0026rsquo; \\in Q_{{near}}\u0026rsquo;$$ 继续Bi-RRT的4. 5.步骤 分析 优化 相比Bi-RRT，以每个新节点为中心，在小区域内更新亲节点选择最优情况（以新节点为主要优化对象），放大到全路径实现整体优化 改进方案 更新成本函数定义，可以引入外部变量对成本进行把控 搜索区域范围大小可更新，搜索区域形状等也可根据实际需要具体调整 RRT算法对障碍物的动态、静态并无要求，只通过避碰函数进行障碍物判断（其他时候无影响），可以引入动障碍进行试验 实现 重写Rewrite\ndef rewrite_index(node_new, node_list, obstacle_list): r = 8 # 搜索范围 min_cost = float(\u0026#39;inf\u0026#39;) min_node_index = None for i, node in enumerate(node_list): # 确定潜在亲节点集合 if calc_p2p_dis(node_new, node) \u0026lt; r and not check_collision(node_new, node, obstacle_list): # 计算成本函数 potential_cost = node.cost + calc_p2p_dis(node_new, node) # 根据成本函数更新亲节点索引 if potential_cost \u0026lt; min_cost: min_cost = potential_cost min_node_index = i return min_node_index 重布线Rewire\ndef rewire(node_new, node_list, obstacle_list): r = 30 # 搜索范围 for node in node_list: # 排除node_new的亲节点 if node != node_new.parent and calc_p2p_dis(node_new, node) \u0026lt; r: potential_cost = node_new.cost + calc_p2p_dis(node, node_new) # 根据成本函数更新亲节点 if potential_cost \u0026lt; node.cost and check_collision(node, node_new, obstacle_list) is False: # if potential_cost \u0026lt; node.cost: node.parent = node_new node.cost = potential_cost 效果 Bi-RRT*\n相较Bi-RRT，路径折角减少，优化效果较为明显 Bi-RRT*加剪枝\n相较Bi-RRT加剪枝，明显减少路径节点，路径更简单 适用 解决RRT难以求解最优的可行路径的问题\n引入路径成本 通过最小化路径成本提升路径质量 渐进地向全局最优解收敛 Bi-RRT*+DWA DWA原理 引入机器人运动方程 相当于对机器人运动路径的模拟\n已知变量 假设为全向移动机器人 机器人移动速度：$v_x, v_y$ 速度空间：$v, \\omega$，以下列出可能限制速度的因素： 自身能到达的所有矢量速度： $$ V_{\\mathrm{s}}=\\left{(v, \\omega) \\mid v \\in\\left[v_{\\min }, v_{\\max }\\right] \\wedge \\omega \\in\\left[\\omega_{\\min }, \\omega_{\\max }\\right]\\right} $$ 受电机性能影响——设定加速度的最大最小值（包括刹车）后在一定时间内能到达的速度： $$V_d=\\left{(v, \\omega) \\mid v \\in\\left[v_c-\\dot{v}_b \\Delta t, v_c+\\dot{v}_a \\Delta t\\right] \\wedge \\omega \\in\\left[\\omega_c-\\dot{\\omega}_b \\Delta t, \\omega_c+\\dot{\\omega}_a \\Delta t\\right]\\right}$$ 障碍： $$V_a=\\left{(v, \\omega) \\mid v \\leq \\sqrt{2 \\operatorname{dist}(v, \\omega) \\dot{v}_b} \\wedge \\omega \\leq \\sqrt{2 \\operatorname{dist}(v, \\omega) \\dot{\\omega}_b}\\right}$$ 评价函数： $$G(v, \\omega)=\\sigma(\\alpha * \\operatorname{heading}(v, \\omega)+\\beta * \\operatorname{dist}(v, \\omega)+\\gamma * \\operatorname{vel}(v, \\omega))$$ $heading(v,\\omega)$ 方位角评价函数——轨迹末端朝向与目标点间的角度差距 $dist(v,\\omega)$ 距离评价函数——路径末端与最近障碍物的距离 $velocity(v,\\omega)$ 当前机器人的线速度 $\\alpha \\beta \\gamma \\sigma$为权重系数 原理 速度空间动态窗口：在受限制的速度空间内进行采样，选择不同的$v,\\omega$ 在一定时间段内根据运动学模型可生成多种轨迹 评价函数选择路径：通过评价函数对所有可能轨迹打分 选择最优路径 Bi-RRT*+DWA原理 根据已知障碍物通过Bi-RRT*方法生成路径 机器人沿路径开始运动，选择$\\Delta t$，对机器人前方$\\Delta L$长度的路径进行碰撞检测 若碰撞检测通过，不采用DWA方法；若不能通过，进入DWA状态进行动态障碍物避碰 DWA避碰状态下，以最近的路径点为goal，并不断更新，直到进入到达域 分析 剪枝后的路径进行dwa优化效果更好 否则每个目标点寻找的耗时长\n运动方程：以上机器人运动方程需要用水下机器人的运动方程进行优化，影响速度、角速度的因素可以根据水下机器人的转角限制、运动限制等进行限定 障碍物限定条件：速度限定中，受障碍物影响的限定方程现在采用最简单的$x=\\frac{1}{2}av^2$，可以根据实际情况进行优化，也可以考虑结合check-collision函数 评价函数：评价函数暂时选择方位角、与最近障碍物的距离与线速度三方面进行评价，可以考虑引入其它物理量并对权重系数通过相关公式等进行优化 算法结合：两算法可以通过其它方法进行结合 也可以根据其它物理量的评价（如与障碍物的距离）决定当前情况是否引入DWA/退出DWA 参数优化：根据机器人实际情况调整相关参数（如最大速度等） 实现 DWA方法 计算动态窗口\nVs = [self.config[\u0026#39;min_speed\u0026#39;], self.config[\u0026#39;max_speed\u0026#39;], -self.config[\u0026#39;max_yawrate\u0026#39;], self.config[\u0026#39;max_yawrate\u0026#39;]] Vd = [x[3] - self.config[\u0026#39;max_accel\u0026#39;] * self.config[\u0026#39;dt\u0026#39;], x[3] + self.config[\u0026#39;max_accel\u0026#39;] * self.config[\u0026#39;dt\u0026#39;], x[4] - self.config[\u0026#39;max_dyawrate\u0026#39;] * self.config[\u0026#39;dt\u0026#39;], x[4] + self.config[\u0026#39;max_dyawrate\u0026#39;] * self.config[\u0026#39;dt\u0026#39;]] dw = [max(Vs[0], Vd[0]), min(Vs[1], Vd[1]), max(Vs[2], Vd[2]), min(Vs[3], Vd[3])] return dw 评估函数计算并选出最优路径\nx_init = x[:] min_cost = float(\u0026#34;inf\u0026#34;) best_u = [0.0, 0.0] best_trajectory = np.array(x) # evaluate all trajectory with sampled input in dynamic window for v in np.arange(dw[0], dw[1], self.config[\u0026#39;v_reso\u0026#39;]): for y in np.arange(dw[2], dw[3], self.config[\u0026#39;yawrate_reso\u0026#39;]): trajectory = self.calc_trajectory(x_init, v, y) to_goal_cost = self.calc_to_goal_cost(trajectory, goal) speed_cost = self.config[\u0026#39;speed_cost_gain\u0026#39;] * (self.config[\u0026#39;max_speed\u0026#39;] - trajectory[-1, 3]) ob_cost = self.calc_obstacle_cost(trajectory, obstacles) final_cost = to_goal_cost + speed_cost + ob_cost if min_cost \u0026gt;= final_cost: min_cost = final_cost best_u = [v, y] best_trajectory = trajectory return best_u, best_trajectory 运动学方程\nx[2] += u[1] * self.config[\u0026#39;dt\u0026#39;] x[0] += u[0] * np.cos(x[2]) * self.config[\u0026#39;dt\u0026#39;] x[1] += u[0] * np.sin(x[2]) * self.config[\u0026#39;dt\u0026#39;] x[3] = u[0] x[4] = u[1] return x 效果 避障 完整规划 DQN-RRT-Connect 填坑中…\n","permalink":"https://Sattiluvcat.github.io/en/posts/else/bi-rrt/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"bi-rrt\"\u003eBi-RRT\u003c/h2\u003e\n\u003ch3 id=\"原理\"\u003e原理\u003c/h3\u003e\n\u003ch4 id=\"基本名词\"\u003e基本名词\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e状态空间：系统全部可能状态的集合\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"rrt原理\"\u003eRRT原理\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRRT(Rapidly exploring Random Tree 快速随机搜索树)是一种全局规划算法\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e已知：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e初始状态（起点位置）$q_{start}$\u003c/li\u003e\n\u003cli\u003e目标状态（终点位置）$q_{goal}$\u003c/li\u003e\n\u003cli\u003e搜索步长 ${\\rho}$\u003c/li\u003e\n\u003cli\u003e系统状态空间 $C$\u003c/li\u003e\n\u003cli\u003e自由状态空间 $C_{free}$\n\u003cul\u003e\n\u003cli\u003e$C_{free}{\\subset}C$，是 $C$ 中\u003cem\u003e不会发生碰撞\u003c/em\u003e的状态集合\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e目标状态空间 $C_{goal}$\u003c/li\u003e\n\u003cli\u003e有 $k$ 个节点的快速随机搜索树 $T_k$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e过程：\u003c/p\u003e","title":"Bi-RRT及改良"},{"content":" 概要 产品原型：展示项目的业务功能\n技术选型： 前端已完成 知识点 JavaScript 三种变量：var——全局\u0026amp;可变 let——局部\u0026amp;唯一 const——全局\u0026amp;不可变 特殊运算符：==不同类型进行类型转换后再比较 ===（全等）不进行类型转换即比较（不同类型必报错） 类型转换： 除0与NaN转换为false外其它全为true 除空字符串转为false外均为true parseInt转换为int类型 JSON格式：先属性后函数 else——XHR xml http request SpringBoot 自动进行请求响应：@RequestMapping即可 保证形参与在PostMan中的定义名称相同 不可保证的变量前添加@RequestParam(name=\u0026quot;\u0026quot;,require=false)前缀 require=false表示不一定需要此变量 传递参数过多时可将其封装到某实体类中——形参为该类 自动进行类型转换 Maven java项目管理与构建 基于项目对象模型POM\n作用 依赖管理：管理项目依赖的资源——jar包 避免版本冲突 pom.xml中配置依赖信息dependency（会指明存储地址） maven_repo作为本地仓库可查看已有的依赖信息 中央仓库 统一项目结构：不同IDE下项目结构都标准统一 项目构建：跨平台eg.Linux-Windows自动化项目构建 编译、测试等功能在maven中已集成为插件 流程 创建maven模块\n坐标：组织名groupId-模块名artifactId-版本号version ——唯一定义资源位置 组织名：通常域名反写 模块名：通常项目名称 编译后产生target文件夹 存放字节码 导入Maven项目——右侧栏Maven项添加对应项目的pom.xml 依赖管理 依赖配置——dependency指明组织名 模块名 版本 依赖传递——直接/间接依赖 可通过exclusion排除被传递来的依赖 依赖范围——默认在主程序main、测试程序test、参与打包运行package范围内均有效 可通过scope指定范围（与坐标并列）eg.test/provided（主+测）/runtime（测+包） 生命周期——三套 同一套生命周期中 有先后顺序 在前的先运行 clean 清理 default 核心工作（调试 测试等） site 生成报告 发布站点 分模块开发 将工具类、实体类等拆分为单独的模块——需要调用时引入该模块 继承与聚合 继承：定义parent工程——引入公共依赖 子工程使用parent parent工程设置打包方式（使用）packaging为pom 只能单继承 但可以多层继承 继承——版本锁定：parent工程中锁定依赖的版本（但并不引入） 需要引入依赖的子工程无需指定版本号 运用dependencyManagement进行版本指定（确定坐标） parent工程中可以用：(方便在统一位置查看) \u0026lt;something.version\u0026gt;*.*.**\u0026lt;/something.version\u0026gt; 定义版本 something下\u0026lt;version\u0026gt;${something.version}\u0026lt;/version\u0026gt;调用 聚合：问题——拆分出来的类在main打包前需要全部先install到本地 解决：创建聚合工程（= parent工程）——不包含业务功能 只有一个pom modules \u0026amp; module关键字指定所有需要一起打包的模块 指定顺序无影响 格式：\u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; 私服 局域网内的仓库\n步骤：maven——conf——settings.xml\nsevers标签配置私服访问用户\u0026amp;密码 \u0026lt;server\u0026gt; \u0026lt;!-- 还有maven-snapshots也需要配置 --\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;satti\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;something\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; mirrors\u0026amp;profiles标签配置连接私服访问地址 \u0026lt;mirror\u0026gt; \u0026lt;!-- 若配置过aliyun镜像 需先将其去掉 --\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;allow-snapshots\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; pom文件中配置上传url地址 \u0026lt;distributionManagement\u0026gt; \u0026lt;!-- release版本的发布地址--\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-releases/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!-- snapshot领本的发布地址: --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 通过生命周期deploy上传到私服 之后可以直接从私服中下载依赖（之前上传的模块） SpringBoot SpringBootWeb 基本内容 SpringBootApplicaton启动类——通过其运行整个程序 配置文件：main——resource——application.properties 实现 请求处理类 类前注明@RestController 处理请求的方法前注明@RequestMapping(\u0026quot;/something\u0026quot;) http协议 Hyper Text Transfer Protocol超文本传输协议 规定浏览器vs服务器的数据传输规则\n特点： 基于TCP协议——安全 基于请求-响应模型——一次请求得一次响应 无状态协议——每次请求相互独立（多次请求不能共享数据 but 快） 请求协议：请求行 + 请求头（+ 请求体） 请求行（第一行） = 请求方式 + 资源路径 + 协议 请求头：(格式key: value) 常用：Host（主机名）User-Agent（浏览器版本） 请求参数（JSON格式）——GET存放在请求行中 POST在请求体中 响应协议：响应行 + 响应头（+ 响应体） 响应行：协议 + 响应状态码 + 描述 状态码：1**——响应中 2**——成功 3**——重定向 4**——客户端错误 5**——服务器错误 客户端错误——eg.请求不存在的资源404/未被授权403/语法错误400 服务器错误——eg.程序抛出异常 响应头：(格式key: value) eg.Content-Encoding响应压缩算法 如gzip 响应体：存放请求参数 协议解析 TomCat 轻量级web服务器\nweb服务器：对http协议操作进行封装 \u0026amp; 部署web项目 对外提供网上信息浏览服务 安装目录： bin——可执行文件 work——工作目录 lib——依赖的jar包 webapps——部署项目 程序简单解析 starter——起步依赖 springboot有内嵌tomcat 请求响应 架构： BS Browser/Server 浏览器/服务器架构 CS Client/Server 客户端/服务器架构（需安装） postman——接口测试 统一接口（返回值） 对所有类型都适配 主题内容包括code（响应码）+msg+data（返回数据） public static Result success(Object data){ //外部定义code msg data（Object类型） return new Result(1,\u0026#34;success\u0026#34;,data); } 分层解耦 web开发三层架构 controller控制层——接收前端请求并处理响应 service业务逻辑层——具体逻辑 dao数据访问层（data access object持久层）——数据增删改查 内聚——模块内部功能联系 耦合——模块间依赖/关联（高内聚低耦合） IOC\u0026amp;DI——类上添加注解@Component（注册Bean） 控制器类改为@Controller 业务类前改为@Service 数据访问类改为@Repository IOC容器提供该类的bean对象并赋值 DI：在类内部对象前添加@Autowired依赖注入——使用Bean 会话 用户访问web：会话开始 某方断连：会话结束 一次会话可以包括多次请求响应 会话跟踪：追踪请求来自同一浏览器（以便在同一会话的多次请求间共享数据）\n会话跟踪方案：客户端Cookie 服务端Session 令牌 Cookie（HTTP协议支持）移动端无法用 \u0026amp; 用户可禁用 \u0026amp; 不能跨域 跨域——协议 IP 端口 Session 服务器集群时无法直接用 \u0026amp; Cookie的缺点 令牌——反上述缺点 but 需要自己实现 JSON Web Token(JWT)——json格式传输 Header + Payload有效载荷（自定义内容） + Signature数字签名（防止Token被篡改） Header\u0026amp;Payload：Base64编码（A-Z a-z 0-9 + /）——表示二进制（可解码） Signature：登录成功后生成令牌 后续请求都须携带 可设定有效期 Filter过滤器 拦截资源请求 一般完成登录校验 统一编码处理 敏感字符处理等\n实现： 创建Filter类（immport javax.servlet.*）添加注解@WebFilter(urlPatterns=\u0026quot;/bal\u0026quot;) init（调用一次） doFilter destroy（调用一次）方法 需要开启：添加注解@ServletComponentScan doFilter添加放行功能 chain.doFilter(request,response)——放行到下一个过滤器 其后添加放行后的逻辑 Bean 声明Bean对象未指定名称——默认为类的首字母小写（获得Object对象） 作用域：单例——singleton（启动时创建一个） 非单例——prototype（同名只创建一次实例） Mybatis 持久层框架（数据库操作） 简化JDBC（对数据库进行操作的规范）开发\n使用： 定义接口类 添加注解@Mapper 内部实现Mysql操作（使用注解@Delete/Select等） 使用时需要注入 运行时会自动生成接口的实现类对象（代理对象） 并交给IOC容器 通过#{balabal}传递方法中的参数 若需拼接（eg.模糊匹配）用concat('%','balabal','%') 调用（定义该类型变量）时添加注解@Autowired @Autowired private EmpDao empDao; JDBC——使用Java操作关系型数据库 数据库连接池——分配管理数据库连接（SpringBoot默认Hikari） 允许重复使用现有的数据库连接（不重新建立）——资源重用 提升系统响应速度 释放空闲时间过长（被占用但未与数据库连接）的连接——避免连接泄露 lombok——通过注解自动生成构造器等方法、日志变量 @Data=@Getter/Setter/ToString/EqualsAndHashCode @NoArgsConstructor无参 @AllArgsConstructor除static修饰的字段外带各参构造方法 增删改查：定义public int delete/insert等返回此操作会影响的记录数（用void则忽略） 增（主键返回）添加注解@Options(keyProperty=\u0026quot;id\u0026quot;,useGeneratedKeys=true)将生成的主键赋值给emp（定义的类的对象）的id 查 实体类属性名与SQL字段名相同时 mybatis会自动封装 可给字段名起别名/mybatis驼峰命名映射开关 配置日志信息：application.properties中添加mybatis.configuration.log-impl=StdOutImpl 预编译SQL——缓存语法检查、优化SQL、编译SQL过程，（条件一定时）直接执行 用占位符定义（之后传参） 避免SQL注入——通过输入影响预定的SQL语句 xml映射文件——定义比较复杂的SQL语句（让代码更简洁） 映射配置文件名与Mapper接口名一致，且放在相同的包下(同包同名) 映射配置文件的namespace属性与Mapper接口的全类名一致 XML映射文件中sql语句的id与Mapper接口中的方法名一致 SDK Software Development Kit软件开发工具包 SpringBoot 起步依赖 自动配置\n起步依赖——依靠maven的依赖传递 自动配置（某些配置类、bean对象自动存入IOC容器（不需要声明对象）） SpringBootApplication扫描当前包与子包检查类的调用（不同包下自定义类不能注入） @ComponentScan(balabal)组件扫描 @Immport导入 自动配置原理：（源码跟踪AutoConfiguration.Imports）添加Conditional注解（有多个子注解） SpringBoot进行条件装配 Ctrl点方法查看源码 事务管理\u0026amp;AOP 事务 注解@Transactional 以方法为单位作为事务（多在多次执行数据修改的方法上应用） 发生RuntimeError异常即回滚（默认） 通过rollbackFor=指定异常类型 传播行为Propogation指定 在启动类中需要添加允许注解开启事务的注解😋 AOP 面向切面编程——动态代理（主流） eg.计算每个方法的执行耗时\n声明AOP类@Aspect eg.包装需要计算耗时的方法 时间通过log输出 返回原方法运行的结果Object AOP类中方法添加注解@Around(\u0026quot;\u0026quot;)声明运用在哪些方法上（还有其它通知类型） Apache POI Java中操作ms office软件\n写入\n读取\n语法补充 try-finally 可用作记录日志（finally部分） else 用HashMap承接需要查找的条件 数据库查询时直接操作map（MyBatis） 取今天的最早时刻：LocalDateTime begin = LocalDateTime.now().with(LocalTime.MIN); 后端 项目结构Base sky-pojo中存放Entity（实体 与数据库中的表对应）、DTO（数据传输对象 各层间传输数据）、 VO（视图对象 前端展示数据）、POJO（普通java对象 仅属性\u0026amp;对应的getter setter） 一般用VO传回前端 DTO接收前端数据 sky-common——com.sky——exception下存放异常类 报错集锦 初始版本编译：“找不到符号” jdk版本不匹配：设置中修改为jdk18 \u0026amp; 将maven——运行程序——JRE版本更新 \u0026amp; 项目结构SDK版本更新 点击登录没反应 nginx启动 知识点 前后端联调 前端请求如何传输到后端？ Nginx反向代理——前端发出动态请求Nginx转发到后端服务器Tomcat 优点：提高访问速度\u0026amp;负载均衡（大量的请求按指定方式均衡分配给每台服务器）\u0026amp;保证后端服务安全 负载均衡策略：weight/ip_hash/least_conn/… # 处理管理端发送的请求 location /api/ { proxy_pass http://localhost:8080/admin/; # 反向代理 #proxy_pass http://webservers/admin/; # 负载均衡 } Swagger 生成接口文档\u0026amp;在线接口调试——Knife4j封装 开发阶段\n扫描包——设置静态资源映射 访问地址 常用注解——添加参数说明 注解 说明 @Api for类 对类的说明 @ApiModel for类 VO等 @ApiModelProperty for属性 @ApiOperation for方法 功能完善 登录功能 MD5加密——密码散列函数 不能解密（只能加密后比较结果）\n数据库保存加密后的密码，用户登录时将输入的密码进行加密后比较 员工\u0026amp;分类管理 约定：用户端发出请求以/user为前缀 管理端为/admin\n若前端数据与实体类中对应属性差别较大时 用DTO封装better 方法上注解——@PostMappingPost类型请求响应 controller设置新方法 调用service中定义的函数 在service对应的实现类中实现功能 将数据保存到对应的持久层mapper（数据库操作） 测试：一般采用接口文档测试（测试时检查token有效期等） 功能： 增：设置Employee对象承接传来的参数 若属性名一致，可直接进行属性拷贝`BeanUtils.copyProperties(employeeDTO,employee); 规范设置eg：employee.setStatus(StatusConstant.ENABLE); 查——xml 传出total（总记录数） record（查询到的记录信息） select * from employee \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null and name!=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; 改（状态修改） 通过路径参数传参：/employee/status/{status} 接收（Long等类型）参数的变量添加注解@PathVariable 修改信息 = 显示已有+修改 要用对象调用方法！（不是类名） 静态方法可以直接用类名调用\n完善： 报错信息处理(返回msg)：捕获异常并判断是否含有某些特定字句（自设）GlobalExceptionHandler中添加同名方法 ThreadLocal应用——为每个线程提供单独的存储空间 实现线程隔离（值） 定义一个类存储使用到ThreadLocal的方法 日期统一格式 公共字段自动填充——AOP方法 定义接口类（对外）与切面类（具体实现） 用Object类型承接传入的参数 用Method setCreateTime = obj.getClass().getDeclaredMethod(\u0026quot;方法名\u0026quot;, LocalDateTime.class)调用方法 方法名可设置常量避免出错 通过invoke反射进行赋值 eg.setCreateTime.invoke(entity,now); trick： 含@builder注解的类可以如下赋值 Employee employee=Employee.builder() .id(id).status(status) .build(); 添加配置属性类（注解@ConfigurationProperties定义可能用到的属性） 若需使用主键值 在插入语句中需注明useGeneratedKeys=\u0026quot;true\u0026quot; 菜品管理 添加DishVO类 增加分类变量（可直接返回前端） 在service实现层中进行事务管理 xml中foreach基本语法：传入数据形如(1,2,3) 需要提取1 2 3 select setmeal_id from setmeal_dish where dish_id in \u0026lt;foreach collection=\u0026#34;dishIds\u0026#34; item=\u0026#34;dishId\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{dishId} \u0026lt;/foreach\u0026gt; 营业状态 1参数 避免创建新表/类\n基于Redis字符串存储 用户端与管理端有同名类时 通过RestController(\u0026quot;名字\u0026quot;)设置Bean名以区分 Swagger中设置不同分组——docket设置groupName分开用户端\u0026amp;商家端（都要加@Bean） 用户登录 生成jwt令牌并校验 特殊 mapper层mysql语句中 后一个id变量与setmealId变量的值相同 但名称沿用类中名称 @Delete(\u0026#34;delete from setmeal where id=#{id}\u0026#34;) void delete(Long setmealId); 接收（Long等类型）参数的变量添加注解@PathVariable 缓存信息 减少数据库查询操作——Redis\n逻辑：每个分类下的菜品保存一份缓存数据——保存一对keyvalue 注意修改信息后需要重建缓存 Spring Cache 基于注解的缓存功能 仅提供一层抽象 底层可以切换不同的缓存实现（Redis EHCache等） @EnableCaching 开启缓存注解 加在启动类上 @Cacheable 方法执行前查询有否缓存 有则返回无则调用方法并添加 @CachePut 添加数据到缓存 @CacheEvict 删除n条缓存数据 Spring Cache语法：Spring EL 如@CachePut(cacheNames=\u0026quot;一个名字\u0026quot;,key=\u0026quot;#形参.要取的形参的信息（如id）\u0026quot;) 如key=#result.某 result即为当前方法的返回值 如key=#p0 传入的第一个参数（第二个即用p1） a0相同效果 最后生成的key的格式如：一个名字::1 删除语法：@CacheEvict调用 AllEntries=true 购物车 设置冗余字段 如图片/名称等 减少对多个数据库的访问 超时订单处理 Spring Task定时任务+WebSocket 统计 Aoache Echart 可以用stream读取List中某信息，eg.List中存储DTO，分别读取出num和number建立新List 在mysql中查询得到的结果名称需与DTO中变量名相同，否则不能存储 List\u0026lt;GoodsSalesDTO\u0026gt; goodsSalesDTOList=orderMapper.getTop10(beginTime,endTime); List\u0026lt;String\u0026gt; list = goodsSalesDTOList.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList()); String name = StringUtils.join(list, \u0026#34;,\u0026#34;); 知识点 HttpClient 发送请求 进行响应\n使用： GET：创建httpclient对象\u0026ndash;\u0026gt;创建请求对象\u0026ndash;\u0026gt;通过httpClient发送请求并通过CloseableHttpResponse接收\u0026ndash;\u0026gt;显示接收到的信息（状态码 响应体）\u0026ndash;\u0026gt;关闭response与httpClient资源 POST：需要提供请求体 SpringTask 按约定的时间自动执行——定时任务框架 cron表达式：（可生成） 普通：0 0 9 12 10 ? 2024——2024年10月12日 星期？省略 9点 使用：导入spring-context坐标——启动类添加注解@EnableScheduling——自定义定时任务类 添加注解@Component——方法上添加注解@Scheduled(cron=\u0026quot;一些\u0026quot;) 无返回值 WebSocket 实现浏览器与服务器的全双工通信 一次握手创建持久性连接并双向通信 使用：websocket.html作为客户端——导入maven坐标——导入服务端组件WebSocketServer——导入配置类 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/%E5%A4%96%E5%8D%96proj/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"概要\"\u003e概要\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e产品原型：展示项目的业务功能\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e技术选型：\n\u003cimg loading=\"lazy\" src=\"img.png\" alt=\"alt text\"  /\u003e\n\n\u003cul\u003e\n\u003cli\u003e前端已完成\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"知识点\"\u003e知识点\u003c/h2\u003e\n\u003ch3 id=\"javascript\"\u003eJavaScript\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e三种变量：\u003ccode\u003evar\u003c/code\u003e——全局\u0026amp;可变 \u003ccode\u003elet\u003c/code\u003e——局部\u0026amp;唯一 \u003ccode\u003econst\u003c/code\u003e——全局\u0026amp;不可变\u003c/li\u003e\n\u003cli\u003e特殊运算符：==不同类型进行类型转换后再比较 ===（全等）不进行类型转换即比较（不同类型必报错）\u003c/li\u003e\n\u003cli\u003e类型转换：\n\u003cul\u003e\n\u003cli\u003e除0与NaN转换为false外其它全为true 除空字符串转为false外均为true\u003c/li\u003e\n\u003cli\u003eparseInt转换为int类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eJSON格式：先属性后函数\u003c/li\u003e\n\u003cli\u003eelse——XHR xml http request\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"springboot\"\u003eSpringBoot\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e自动进行请求响应：\u003ccode\u003e@RequestMapping\u003c/code\u003e即可\n\u003cul\u003e\n\u003cli\u003e保证形参与在PostMan中的定义名称相同\n\u003cul\u003e\n\u003cli\u003e不可保证的\u003cstrong\u003e变量前添加\u003c/strong\u003e\u003ccode\u003e@RequestParam(name=\u0026quot;\u0026quot;,require=false)\u003c/code\u003e前缀\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequire=false\u003c/code\u003e表示不一定需要此变量\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e传递参数过多时可将其封装到某实体类中——\u003cstrong\u003e形参为该类\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e自动进行类型转换\n\u003cimg loading=\"lazy\" src=\"image.png\" alt=\"alt text\"  /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"maven\"\u003eMaven\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003ejava项目管理与构建 基于项目对象模型POM\u003c/p\u003e","title":"外卖Proj"},{"content":" 所有图片来自：王道计算机考研 操作系统 操作系统 定义 系统资源的管理者\u0026amp;提供方便的接口与环境\u0026amp;最接近硬件的软件\n功能：处理机(CPU)管理\u0026amp;存储器管理\u0026amp;文件管理\u0026amp;设备管理 程序运行 将相关数据从磁盘放入内存 = 存储器 进程被CPU管理 = 处理机 接口\u0026amp;环境 flowchart LR 接口--\u0026gt;GUI 接口--\u0026gt;程序接口 用户接口--\u0026gt;程序接口 用户接口--\u0026gt;脱机命令接口 接口--\u0026gt;命令接口 命令接口--\u0026gt;脱机命令接口 命令接口--\u0026gt;联机命令接口 联机命令接口---交互式命令接口 交互式命令接口--\u0026gt;cmd 批处理--\u0026gt;.bat 脱机命令接口---批处理 GUI 图形化用户接口 硬件拓展 无软件支持的计算机 = 裸机 覆盖了软件 = 扩充机器（虚拟机） 四个特征 并发 共享 是最基本的特征 互为存在条件\n并发 宏观上同时发生 微观上交替（= 同时段发生）\n单核CPU同一时刻只能执行一个程序=并发 多核可以实现并行（同一时刻进行多个程序） 共享 资源共享 系统资源可供内存中多个并发进程共同使用 两种资源共享方式：\n互斥共享 一时段一进程 eg.摄像头 同时共享 一时段多进程 虚拟 物理实体变为逻辑上的对应物\nflowchart LR 虚拟技术--\u0026gt;空分复用技术 虚拟技术--\u0026gt;时分复用技术 空分复用技术--\u0026gt;eg.虚拟存储器 时分复用技术--\u0026gt;eg.虚拟处理器 没有并发性 虚拟性 = 不存在 异步性 多个程序并发 资源有限时进程执行以未知速度推进\n没有并发性 异步性 = 不存在 发展与分类 flowchart TB subgraph 手工操作 缺点1--\u0026gt;独占全机 缺点1--\u0026gt;资源利用率低 资源利用率低--\u0026gt;计算机快\u0026amp;人工慢 end 手工操作--\u0026gt;批处理阶段 subgraph 批处理阶段 subgraph 单道批处理系统 主要结构--\u0026gt;磁带\u0026amp;监督程序 缺点2--\u0026gt;内存中仅能运行一道程序 end 单道批处理系统--\u0026gt;多道批处理系统 subgraph 多道批处理系统 输入计算输出错峰运行 缺点3--\u0026gt;运行过程时不能调试 end end 批处理阶段--\u0026gt;分时操作系统 subgraph 分时操作系统 特点--\u0026gt;以时间片为单位轮流服务用户 优点--\u0026gt;及时响应解决人机交互问题 缺点4--\u0026gt;不能优先处理紧急任务 end 分时操作系统--\u0026gt;实时操作系统 subgraph 实时操作系统 在严格时限内处理事件---可以优先响应 特点1--\u0026gt;及时性\u0026amp;可靠性 分类--\u0026gt;硬实时系统 硬实时系统---严格时限 分类--\u0026gt;软实时系统 软实时系统---偶尔接受迟滞 end 实时操作系统--\u0026gt;网络操作系统 实时操作系统--\u0026gt;分布式操作系统 实时操作系统--\u0026gt;个人计算机操作系统 subgraph 不重要 网络操作系统 分布式操作系统 个人计算机操作系统 end 运行机制 指令 = 机器指令 非cmd\n两种 flowchart LR 内核程序Kernal--\u0026gt;特权指令 应用程序--\u0026gt;非特权指令 特权指令--\u0026gt;内核态 非特权指令--\u0026gt;用户态 内核程序 = 最接近硬件的部分 特权指令 = 管理者操作 内核态/用户态 = CPU状态（用PSW存储状态） PSW 程序状态字寄存器 内核态=核心态=管态 用户态=目态 切换状态：\n内核到用户：特权指令修改PSW 用户到内核：触发中断 硬件自动完成 中断与异常 中断作用 唯一让CPU从用户态变为内核态的途径 = 保障并发\n中断类型 内中断（异常）：中断信号来自CPU内部 当前执行指令\n指令自身非法/遇到特权指令 eg.trap程序引发/fault错误条件 Kernal可能修补/abort致命错误 外中断（中断）：与当前指令无关 eg.时钟中断 eg.I/O中断 基本原理 CPU检测到中断后查询中断向量表 找到中断处理程序的内存位置\n系统调用 一组系统调用组成程序接口\n应用程序通常通过库函数进行系统调用 有些库函数不调用 有些语言直接进行系统调用 eg.汇编语言 向系统内核提出请求对共享资源进行操作 即系统调用 发出trap指令提出请求（用户态） 执行trap后引发内中断进入核心态 体系结构 大/宏内核操作系统：所有内核功能（Linux UNIX等）\neg.进程 存储 设备 + 微内核部分 性能高 内核代码庞大 结构混乱 微内核操作系统：与硬件关系最紧密的功能（Windows NT） eg.时钟管理 中断处理 原语（设备驱动 CPU切换） 优缺点反之 引导 过程 CPU从主存（ = RAM + ROM（BIOS））执行ROM引导程序 将磁盘中主引导记录（MBR）读入内存 执行磁盘引导程序 扫描分区表 从活动分区（主分区）读入分区引导记录（PBR） 执行程序 主分区即安装了操作系统的分区 从根目录找到启动管理器并执行 完成开机🥳 虚拟机 Virtual Machine (VMware \u0026amp; Virtual Box)\n虚拟机管理程序（VMM monitor）\n第一类VMM 运行在硬件上（CPU 磁盘 内存进行划分） 用户空间分为虚拟用户态\u0026amp;虚拟内核态（但实际均为用户态） 若执行特权指令 由内核中的VMM进行虚拟执行 第二类VMM 运行在宿主操作系统（Host OS）上（如Vmware） VMM大部在用户态 VM驱动部分在内核态 对比：第一类性能更好 可容纳更多虚拟机 运行在最高特权级(Ring 0) 但可迁移性不强 第二类反之 进程管理 进程基础知识 基本 定义 程序：静态 = 指令集合 进程：动态 = 程序的执行过程\n进程组成 PCB（Process Control Block）进程控制块 For操作系统\n进程存在唯一标志 保存：PID UID \u0026amp; 进程控制与管理信息 \u0026amp; 资源分配清单 \u0026amp; 处理机信息 PID（进程ID 唯一不重复） 程序段：程序代码 For进程\n程序运行：程序-\u0026gt;硬盘（exe）-\u0026gt;内存PCB-\u0026gt;CPU取出指令 数据段：运行过程中产生的数据 For进程 进程实体（进程映像）=PCB+程序段+数据段 静态 进程 进程实体的运行过程 动态 特征 动态性：最基本的特征 并发性：内存中有多个进程实体 独立性：获得资源的基本单位 异步性 结构性：每个进程都有一个PCB\n状态与转换 创建态 就绪态 运行态 阻塞态 终止态\n就绪态——等待处理机调度 运行态——占用整个CPU运行 阻塞态——运行态进程请求等待某事件发生 下CPU（进程主动） 事件发生后改为就绪态（被动） 进程的组织 链式：队列指针 索引：索引表指针\n进程控制 实现进程状态转换\n原语实现——具原子性 = 不可中断\n特权指令 关中断指令\u0026amp;开中断指令实现原子性 关中断开启——不再检查中断信号 创建/撤销进程时使用的原语：PCB更新——资源分配——合适的队列\n申请空白PCB——找到对应PCB 为新进程分配资源——若运行 剥夺CPU并分配 初始化PCB——终止所有子进程 PCB插入就绪队列——资源归还并删除PCB 阻塞/唤醒原语——成对使用（因何阻塞必因何唤醒）\n切换进程的原语：将现行运行环境存入PCB\n进程通信IPC 两进程间的数据交互 不同进程的内存地址不重叠 通信需要操作系统支持\n共享存储 设定共享存储区 映射到进程的虚拟地址空间\n互斥访问 由进程自己实现 基于存储区：灵活性高 高级通信 基于数据结构：低级通信 消息传递 消息包括消息头\u0026amp;消息体 操作均由原语完成\n直接通信：两进程明确消息的接收方与发送方 在内存中存储发送了的消息 形成消息队列 间接通信：发到内存中的信箱 另一进程从信箱读取 信箱公用 管道通信 某时段内单向传输（半双工通信） I/O进程不固定数量\n一种共享文件pipe 内存中一个大小固定的内存缓冲区 队列 先进先出 线程与多线程 同个进程中可能有多个线程 程序执行的最小单位（相当于小进程）\n提升并发度 不用切换进程（同进程内线程切换）系统开销小 每个线程有自己的线程ID与TCB线程控制块 几乎不拥有系统资源（来自所属的进程） 通信方便 同进程内不需系统干预 线程实现方式 用户级线程（早期）——由线程库实现\u0026amp;管理 程序实现 与操作系统无关 并发程度很低（阻塞） 内核级线程（KTL） 进程与对应的内核级线程都在内核态的操作系统 内核级线程一一管理用户级线程 线程切换管理成本更高 多线程模型 一对一：一内核一用户 多对一：一内核多用户（退化） 多对多：多内核多用户（内核更少） 线程状态与转换 就绪——运行——阻塞 线程组织与控制 TCB(≈PCB)=线程标识符（TID）+程序计数器PC+其他寄存器+堆栈指针+线程运行状态+优先级 调度时保存PC+其他寄存器+堆栈指针 调度 处理机调度 确定处理任务的先后顺序\n三个层次 高级调度（作业调度）——从外存调入内存开始任务 低级调度（进程调度）——最基本 快速 内存到CPU 中级调度（内存调度）——从外存调到内存 从挂起队列调回内存（内存不足） 进程调度时机 不能调度的eg.处理中断 原语 处于内核程序临界区（操作系统内） 可调度eg包括主动与被动 方式： 非抢占方式——反之 抢占方式——更紧急的任务优先执行 当前任务中止 适用分时、实时操作系统 包括：选择进程+进程切换 调度器（调度程序）scheduler与闲逛进程idle 触发调度器eg.创建新进程+进程退出+进程阻塞+I/O中断（maybe唤醒阻塞进程） 抢占式调度：时钟中断触发 非抢占式：only阻塞/退出才触发 闲逛进程idle——优先级最低 占一个完整的指令周期（提醒作用） 调度算法评价指标 CPU利用率=利用时间/总时间 系统吞吐量=单位时间内完成作业的数量 周转时间=作业提交至系统-\u0026gt;作业完成的时间 平均周转时间=各作业周转时间和/作业数 带权周转时间=周转时间/实际运行时间（\u0026gt;=1） 平均带权周转时间=带权和/作业数 等待时间=等待处理机状态时间和 for进程：等待被服务的时间 for作业：建立进程后的等待时间+作业在外存后备队列的等待时间 响应时间=提交请求-\u0026gt;首次响应的时间 调度算法 先来先服务FCFS first come first serve 非抢占式 公平 but 长作业有利 短作业不利 不会饥饿（长期得不到服务） 短作业优先SJF shortest job first——当前已到达 运行时间最短 =短进程优先 非抢占（抢占版为最短剩余时间优先算法SRNT 新达到进程/进程完成时 剩余时间最短者抢占当前进程 SRNT平均等待时间、平均周转时间最少 若所有进程几乎同时到达 SJF平均等待时间、平均周转时间最少 时间短 but 不公平 长作业不利 会饥饿 maybe饿死 高响应比优先HRRN highest response ratio next——每次调度时先计算响应比 响应比同先来先服务 响应比=(等待时间+要求服务时间)/要求服务时间 非抢占式 考虑了要求服务时间 不会饥饿\n（适用于交互式系统的调度算法👇） 时间片轮转RR round-robin——根据到达顺序轮流执行一个时间片 only用于进程调度 可抢占式——时钟中断 公平 but 切换频繁\u0026amp;不区分紧急程度 时间片过大——增大进程响应时间 过小——进程切换过于频繁 不会饥饿 优先级——设置优先级：系统\u0026gt;用户 前台\u0026gt;后台 更偏好I/O型（I/O可以和CPU并行工作） 也可用于I/O 非抢占 有抢占式版本 考虑优先级 but 可能导致饥饿 多级反馈队列——设置多级就绪队列 优先级从高到低 时间片从小到大 规则： 新进程先进第1级队列 FCFS分配时间片 时间片用完还未结束 则进入下级队尾（最下级的就进入本级队尾） k级队列为空时 再为k+1级分配时间片 被抢占的进程进入此队队尾 用于进程调度 抢占式（有非抢占式版本） 相对公平 响应快 短进程完成较快 避免用户作假 灵活调整偏好程度 maybe饥饿 多级队列——按进程类型设置不同优先级 队列间可采取固定优先级/时间片划分 各队列可采用不同调度策略 进程同步 互斥等 进程同步与互斥 进程同步——进程的次序（对抗异步性——未知速度） 进程互斥——临界资源（一时段一程序访问）互斥 进入区（检查可否进入 设置正在访问标志）——临界区——退出区（解除标志）——剩余区 临界区空闲则让进 忙则等待 有限等待——能在有限时间内进入临界区 让权等待 进程互斥的软件实现 单标志法——一个flag=允许进入临界区的进程号 空闲让进不符 双标志先检查法——进程数个flag 表达本进程是否进入临界区 忙则等待不符（检查与上锁不是同时发生） 双标志后检查法——先上锁后检查 空闲让进 有限等待不符 Peterson——自己flag为true \u0026amp; 上其它锁 \u0026amp; 若其它flag为true且上锁则自己while空循环等待 进程互斥硬件实现 中断屏蔽——开/关中断指令实现 简单高效 but 不适用多处理机（only单处理机）\u0026amp;特权指令 TS指令 TestAndSetLock——执行过程不允许中断 让权等待不符——无法进入的程序会占用CPU并循环TSL指令 SWAP指令（即XCHG）——类TSL指令 互斥锁 主要缺点：忙等 需要连续循环忙等的互斥锁 = 自旋锁 适用多处理机系统 信号量机制 用户进程用一对原语对信号量操作\n信号量：变量（整数/记录型变量） 整型信号量——仅初始化、P、V操作 存在忙等 记录型信号量——灵活使用阻塞态 就绪态等 value表示资源的剩余数量 遵循让权等待 一对原语：wait(S) signal(S) 简称为P、V操作 必成对出现 信号量机制应用 实现进程互斥——value定为互斥信号量mutex（进入临界区的名额） 初值为1 进程同步——保证操作顺序——设置同步信号量S 初值0（反互斥之道而行之） 先V（进程一结束后）后P（进程二开始前）——V释放资源 P获取资源 前驱关系 PV例题 生产者消费者问题 bg：生产者生产一个产品放入缓冲区 消费者每次取出一个产品 缓冲区有大小限制且为临界资源 PV关系：缓冲区空否——同步信号量（初值为n） 满否——同步信号量（初值为0） 访问——互斥信号量 P操作：互斥信号always在同步信号后（不空/满才访问） V：whatever 多生产多消费者 bg：生产者A生产a 消费者C只要c BD同理 缓冲区仅能放有限数量 PV：互斥——访问 同步——几个a/b（For消费者） 同步——还可以放多少（For生产者） 共4个 若缓冲区大小为1 maybe可以不加互斥信号量 吸烟者 bg：3个抽烟者和1个供应者 卷烟需要3种材料 一抽烟者有1种 供应者每次供应2种 1对应抽烟者拿走 PV：互斥——访问 同步——1 2 3是否卷好 可以省略互斥 读者-写者 bg：共享一个文件 可以多个读 一个写则其它均不可 写时让已有的读与写全部退出 PV：互斥——记录读进程个数（互斥访问计数器） 互斥——写锁 读写锁等 哲学家进餐 bg：圆桌 每人两边各有一只筷子 哲学家要么思考要么进食（需要两只筷子） PV：对筷子设置互斥 无限制会死锁——限制最多四人进餐/… 管程 信号量机制——编写程序困难易出错 =\u0026gt; 引入管程替代PV\n组成≈类（过程≈Java中的方法） 特征：管城内的数据只能被其内部的过程访问 + 只有通过管程的过程才能访问内部的共享数据 + 每次仅有一个进程在管程内执行过程 Java中的类似机制：synchronized 被其 修饰的函数在同一时段内只能被一个线程调用 死锁 概述 概念 死锁：各进程互相等待对方的资源 = 都阻塞 管理者的问题 饥饿：长期得不到资源 某进程无法推进 管理者的问题 死循环：进程执行时跳不出循环 条件 互斥——资源使用互斥 不剥夺——其他进程不能强行夺走资源 请求和保持——已经保持了至少一个资源 但还有请求 循环等待——资源的循环等待链 循环等待时不一定会发生死锁 发生死锁的情况 资源竞争 进程推进顺序非法（请求与释放的顺序不当） 信号量使用不当 = 不可剥夺的资源分配不合理\n处理策略 预防（破坏形成条件） + 避免（防止进入不安全状态） + 检测与解除\n预防死锁（静态策略） 互斥条件破坏——改为共享资源 eg.SPOOLing技术 适用范围窄 不剥夺破坏——请求无法满足时释放所有资源/操作系统将资源强行剥夺 复杂+降低吞吐量+maybe饥饿+只适用易保存回复资源 请求保持破坏——静态分配方法（运行前申请所有资源 不满足则不运行 运行后不请求） 资源利用率低 maybe饥饿 循环等待破坏——顺序资源分配法（资源编号 每个进程按编号递增请求资源 同号一次申请完） 难新增资源+资源浪费+编程麻烦 避免死锁（动态策略） 安全序列：按此序列分配资源则每个进程都能完成 安全 = 一定不死锁 不安全 = 不一定死锁 银行家算法：进程申请时 预判分配会否导致不安全 会则阻塞该进程 安全性算法：根据资源分配循环找安全序列 n个进程 m种资源 = n*m矩阵 =\u0026gt;最大需求矩阵Max n*m的分配矩阵Allocation 最多还需要多少资源Need 长m的一维数组Available表示还有多少可用资源 长m的一维数组Request表示本次申请的各种资源\n不断重复上述步骤 检测与解除 检测：保存资源的请求与分配信息（数据结构）+检测是否死锁（算法） 两种边：请求与分配 最终能消除所有边 = “可完全简化” = 一定没有死锁 死锁定理：若不能消除 = 发生死锁 还连着的边 = 处于死锁[^2]: 暂时挂到外存 解除： 资源剥夺法：挂起[^2]某些死锁进程 并将其资源分给其它死锁进程 注意防止饥饿 撤销进程法：强制撤销部分/全部死锁进程 并剥夺资源 代价大 进程回退法：一个/多个死锁进程回退到避免死锁的地步 需设置还原点 进程选择考虑：进程优先级 已执行时间 还要多久完成 已使用多少资源 交互式or批处理式 内存 内存基础 内存中存储程序的最小单位——存储单元 按字节编址 = 每个存储单元大小为1B 1K=2^10^ 1M=2^20^ 1G=2^30^ 逻辑地址（编程时指定的相对地址）转换为物理地址（绝对地址）方法： 绝对装入——编译时指定绝对地址 不存在操作系统时应用 静态重定位（可重定位装入）——装入模块（exe）装入时转换 必分配要求的全部内存空间 运行期间位置不能移动 动态重定位（……）——程序要执行时再进行转换 需要重定位寄存器——寄存装入模块存放的起始位置 允许程序在内存中移动 链接方式 静态链接——运行前链接为装入模块 装入时动态链接——装入内存时 边装入边链接 运行时动态链接——执行时需要某模块才链接 内存管理 概念 功能：内存空间的分配与回收 + 内存空间的扩展 + 地址转换 + 内存保护 内存保护方法： CPU中设置上下限寄存器——限定进程可访问的空间 重定位寄存器（基址寄存器）+界地址寄存器（限长寄存器）=起始物理地址 + 最大逻辑地址 最大逻辑地址判定是否越界异常 起始物理地址确定被查询数据的具体位置 覆盖与交换（内存空间的扩展） 覆盖：不能同时进行的程序段共享同一片覆盖区 一个固定区（程序段不会被调入调出）+若干覆盖区 程序员提前声明 对用户不透明——已淘汰 交换：内存紧张时 内存中某进程暂时换出外存 外存中某进程换入内存 外存（磁盘）包括文件区\u0026amp;对换区——对换区IO速度比文件区更快（对换区主要追求效率） 可优先换出阻塞/优先级低进程/…… PCB常驻内存 不会被换出（储存进程换出在外存的位置） 连续分配管理方式 为进程分配连续的内存空间\n单一连续分配：内存 = 系统区 + 用户区 内存中只能有一个用户程序 无外部碎片 有内部碎片（分配的内存区域有部分没有用上） 固定分区分配——用户空间划分为固定大小的分区 每个分区运行一道作业（分区大小可相同/不相同） 分区说明表（数组/链表表示）：记录分区大小 起始地址 状态等 无外部碎片 but 用户程序过大只能覆盖 会产生内部碎片 动态分区分配（可变分区分配） 动态分区分配的几个问题 空闲分区表/链存储内存使用情况\n…链：空闲分区起始加前向指针 末尾加后向指针 多个空闲分区分配——动态分区分配算法\n分区的分配与回收——简单的修改表项操作\n特点：没有内存碎片 but 有外部碎片\n外部碎片：内存中某些空闲分区因太小而难以利用 可通过紧凑（拼凑Compaction）解决——换入换出 装入方式选择？ 动态重定位 紧凑之后？ 修改起始地址——PCB 也要放入CPU的基址寄存器 动态分区分配算法 首次适应算法：从低地址开始查找 找到第一个满足大小的空闲分区 空闲分区按地址递增的次序排列 算法开销小 性能最好 最佳适应算法：优先使用更小的空闲区 按容量递增次序排列 会产生很多外部碎片 + 算法开销大 最坏适应算法：优先使用最大的连续空闲区 容量递减次序 可能大进程无处安放 + 算法开销大 邻近适应算法：首次适应 + 每次从上次查找结束的位置开始检索 地址递增次序\u0026amp;上次查找结束 高地址的大分区可能被用完 基本分页存储管理（非连续分配管理方式） 分页存储： 内存空间分为大小相等的分区 每个分区就是一个页框 每个页框有编号 即页框号 页框=页帧=内存块=物理块=物理页面 页框号=页帧号=内存块号=物理块号=物理页号 页框号从0开始 进程的逻辑地址空间分为与页框大小相等的部分 每个部分即为页面 每个页面标号为页号 页面=页 页号从0开始 页面与页框一一对应 各页面不必连续存放 页表 通常保存在PCB中\n一进程对应一张页表 进程的每个页面对应一个页表项（=页号+块号） 记录进程页面和实际存放的内存块间的映射关系 问题：每个页表项占多少字节？ 从内存块号范围（如0~2^20^-1）确定（二进制表示至少需要20bit 即内存块号大小） 用B（字节）表示至少3B（1B=8bit） 即至少用3B表示块号 页号不占存储空间——页表项连续存放 问题：如何实现地址转换？ 确定页号+页内偏移量 基本地址变换机构 逻辑地址到物理地址的转换\n注意越界检查——从系统区的PCB调出数据 放到页表寄存器（页表始址 + 页表长度） 页表长度即页表中有多少页表项 实际会拓展页表项大小——最好一个页框能装下整数个页表项（跟进程存储相独立） 具有快表地地址变换机构 快表TLB（联想寄存器translation lookaside buffer）——访问速度比内存快很多的高速缓存（Cache） 非内存（内存中的页表被称为慢表） 存放最近访问的页表项的副本 普通Cache中存放其它内容的副本 在快表中查询是否有需查找的页表项 若未命中则访问内存中慢表——内存中最近访问过的页表项存放到快表中 两级页表 将页表拆分为很多小页表——页目录表存储小页表存放位置 二级页表存放进程页面的存放位置 二级页表可以离散存储 逻辑地址结构 = 一级页号 + 二级页号 + 页内偏移量 各级页表最多存储页表项数量 = 各页面可存放的最多页表项 基本分段存储管理（非连续分配管理方式） 分段：程序自身逻辑划分为若干段 每段有段名（低级语言——汇编语言 按段名编程） 每段从0开始编址 段号位数决定了每个进程最多分多少段 段内地址数决定了每段最大长度 段表：保存逻辑段存放位置 = 段号 + 段长 + 基址（段号隐含 不占内存） 各段表项长度相同 地址变换——段表寄存器（段表始址+段表长度）\u0026amp;段内地址与段长 进行越界中断检查 分页\u0026amp;分段 页是信息的物理单位 对用户不可见 进程地址空间为一维 段是信息的逻辑单位 对用户可见 进程地址空间为二维 更易实现信息共享与保护 不会被修改的代码（即纯代码）才可以共享 段页式管理方式（非连续分配管理方式） 分页分段优缺点：分页不会产生外部碎片 但不能按逻辑实现信息共享 分段反之 段页式 = 先分段 \u0026amp; 每段再分页 逻辑地址结构 = 段号 + 页号 + 页内偏移量 一个段表 + n个页表 页部分对用户不可见 只需指定段号与段内偏移量 检查段号 页号是否越界 虚拟内存（内存的扩充） 局部性原理 时间局部性——某指令/数据若被调用过 不久后很可能再次被调用 空间局部性——某存储单元若被访问过 不久后其附近存储单元很可能被访问 很多数据在内存中连续存放 程序指令也是顺序存放 虚拟内存——很快会用到的部分装入内存 剩下的在外存 + 若执行时某信息不在内存 操作系统将其调入 + 内存不够时将暂时不用的调出 特征： 多次性——无需一次性装入 对换性——作业运行时允许换入换出 虚拟性——逻辑上扩充内存容量 管理：请求分页管理方式\u0026amp;请求分段管理方式\u0026amp;请求段页式管理方式 实现：操作系统提供请求调页功能 + 页面置换功能（For分页 分段类似） 请求分页管理方式 页表机制：操作系统需知页面是否已调入内存/外存存放位置 内存空间不够时进行页面置换——修改过的页面调出覆盖外存中旧数据 未修改的不变 缺页中断：若页面不在内存则产生 缺页的进程阻塞 调页完成后唤醒就绪 中断处理程序需要保存CPU现场 中断信号来自CPU 为内中断 地址变换机构：新增请求调页 \u0026amp; 页面置换 \u0026amp; 修改请求页表中的新增表项 调入的页面对应的表项会直接加入快表 页面置换算法 选择哪个页面被换出\n最佳置换算法OPT：淘汰以后永不使用/最长时间不访问的页面 保证最低缺页率 不可能实现 先进先出FIFO：淘汰最早进入内存的页面 为进程分配的物理块数（内存块）增多时 缺页次数反而增加 = Belady异常 只有FIFO有Belady 性能差 最近最久未使用置换算法LRU：淘汰自上次访问至今时间最长的页面 性能好 but 实现困难开销大 时钟置换CLOCK/最近未用NRU：（简单版）内存中页面用指针链接为循环队列 被访问时访问位设为1 淘汰时遇1置0 遇0淘汰 最多经过两轮扫描进行淘汰页面 未考虑是否修改 改进版时钟置换：设置修改位 0表示未被修改 1表示被修改 优先淘汰(0,0)（访问位，修改位） 二轮淘汰(0,1) 并把扫描过的页面访问位置0 三轮淘汰(0,0)，四轮淘汰(0,1)（访问位均为0，故总有页面被淘汰） 算法开销小 \u0026amp; 性能可 页面分配策略 驻留集 请求分页存储管理中给进程分配的物理块集合\n虚拟存储技术的系统中 驻留集一般小于进程总大小 页面分配置换策略 固定分配 \u0026amp; 可变分配 驻留集大小在进程运行期间是否可变 局部置换 \u0026amp; 全局置换 缺页时 只能选进程自己的物理块进行置换 可选其他进程的物理块/操作系统保留的物理块 固定分配局部置换 难以在初期确定合理的物理块数目 可变分配全局置换——选择未锁定页面换出外存 将其分配（只要缺页就分配新物理块） 被选中的进程缺页率增加 可变分配局部置换——频繁缺页 系统会多分配物理块 调入页面时机 预调页策略——相邻页面调入 主要用于进程首次调入 请求调页策略——缺页时调入 抖动现象（颠簸） 刚换出的页面马上需换入内存\n原因：频繁访问的页面数目高于可用的物理块数（物理块不够） 工作集：某时间间隔里 进程实际访问页面的集合 一般驻留集\u0026lt;工作集 否则会频繁缺页 内存映射文件Memory-Mapped Files 将文件映射到进程的虚拟地址空间——以访问内存的方式访问文件 读入写出由操作系统负责 多个进程可以映射同个文件 实现共享 文件管理 在磁盘（外存）中\n文件的逻辑结构 逻辑结构 For用户（看来 内部数据如何组织） 物理结构 For操作系统（看来 文件数据如何存放在外存）\nflowchart LR 逻辑结构--\u0026gt;无结构文件 逻辑结构--\u0026gt;有结构文件 有结构文件--\u0026gt;顺序文件 有结构文件--\u0026gt;索引文件 有结构文件--\u0026gt;索引顺序文件 顺序文件--\u0026gt;顺序存储 顺序文件--\u0026gt;链式存储 无结构文件（流式文件）——内部数据为一系列二进制流/字符流 eg.txt 有结构文件（记录式文件） 每条记录有一个数据项可作为关键字 定长记录——各条记录长度相等 可变长记录——不等 有结构文件的逻辑结构 各记录排列的顺序\n顺序文件：记录按顺序排列（逻辑上的顺序） 定长/可变长记录 串结构——记录的顺序与关键词无关 顺序结构——记录顺序按关键词顺序 定长记录的顺序文件可实现随机存取 若采用顺序结构可快速找到关键字对应的记录（折半查找） 可变长记录的顺序文件不能随机存取 索引文件（加快文件检索速度）——可变长记录的顺序文件改进 索引表自身为定长记录的顺序文件 可能会占用很大的内存空间 索引顺序文件——索引表改进 将文件数据分组 索引顺序文件储存分组信息 查找：先在索引顺序文件中顺序找分组 后在分组中顺序找记录 多级索引顺序文件——索引顺序文件改进 文件目录 文件控制块FCB——包含文件基本信息 FCB有序集合即为文件目录 目录结构： 单极目录结构 不允许文件重名 两级目录结构 = 主文件目录 + 用户文件目录 允许不同用户的文件重名 多级目录结构（树形结构）——用文件路径名标识文件 eg./users/local/bin 树形结构不便于文件共享 无环图目录结构——增加一些指向同节点的有向边（相当于共享） 可设置共享计数器 索引结点：存放FCB中除文件名外的信息（用索引结点指针存放） 加快查找效率 文件物理结构 磁盘块：磁盘中分为many磁盘块 大小与内存块、页面大小相同 逻辑块号 + 块内地址 = 文件的逻辑地址 连续分配：要求每个文件在磁盘上占有一组连续的块 文件目录需记录文件存放在磁盘中的起始块号\u0026amp;长度（总共占用几块） 优点：支持顺序访问与直接访问 \u0026amp; 顺序读写时速度最快（距离近 磁头移动更快） 缺点：存储空间利用率低 会产生磁盘碎片 链接分配：离散分配 指针链接 隐式链接——必须从上一个逻辑块中读到下一个块的物理地址 只支持顺序读取 but 不会产生碎片 显式链接——链接各物理块的指针显式存放在一张表中（文件分配表FAT File Allocation Table） 一个磁盘仅一张FAT 开机时读入内存并常驻 FAT各表项在物理上连续存储 且长度相同 支持顺序/随机访问 不会产生外部碎片 but FAT需要占用一定存储空间 索引分配：离散分配 每个文件都有一张索引表（记录文件逻辑块对应的物理块） 索引表存放的磁盘块称为索引块（FCB中记录索引块位置） 文件数据存放的称为数据块 索引表过大 解决方案： 链接方案——顺序读取各索引块 多层索引——需多次读磁盘 混合索引——多种索引分配方式结合 eg.有的直接地址索引 有的一级间接（单层索引表） 有的二级间接索引 各级索引表不能超过一个块 文件存储空间管理 存储空间划分与初始化 将物理磁盘划分为文件卷（逻辑卷/逻辑盘） eg.C盘 文件卷包括目录区（存放FCB 存储空间管理的信息等）\u0026amp;文件区 空闲表法——建立空闲表（包括空闲盘块号\u0026amp;空闲盘块数） 分配回收与内存的动态分区分配类似 空闲链表法——空闲盘块链/空闲盘区链（连续的盘块组成盘区） OS保存链头链尾指针 盘区链适用于离散分配\u0026amp;连续分配 位示图法 每一格代表一个盘块 盘块号=ni+j（n为字长 i为字号 j为位号） 空闲标0 不空标1 成组链接法（UNIX采用） 空闲表/链表法不适用于大型文件系统 文件基本操作 创建文件：在外存中找到文件所需空间 + 创建该文件对应的目录项 删除文件：找到目录项 + 回收磁盘块 + 删除目录项 打开文件：找到目录项（检查权限） + 目录项复制到内存中的打开文件表 打开文件表 系统有一总表 各进程也有表（记录读写指针 访问权限 系统表索引号） 关闭文件：进程的打开文件表项删除 + 回收内存 + 系统打开文件总表计数器更改 读/写文件：读/写指针指向外存（文件数据存储处） OS将用户指定的数据读入内存 写回写指针指向的外存数据 文件共享 基于索引结点的共享方式——硬链接 不同用户的目录下索引结点指针指向同一个索引结点 索引结点中设置链接计数变量 基于符号链的共享方式——软链接 创建Link类型文件 根据其记录的路径查找目录 eg.快捷方式 文件保护 口令保护：为文件设置口令（保存在FCB中） 请求访问时验证 口令存放在系统内部 加密保护：对文件原始数据进行加密 eg.异或加密 访问控制：为文件的FCB/索引结点增加访问控制列表(Access-Control List,ACL) 记录各用户可执行的操作 设备管理 I/O设备分类 输入输出\n分类：人机交互类外部设备 + 存储设备 + 网络通信设备 eg.猫 人机…：数据传输速度慢 存储设备：数据传输速度快 分类：低速设备 + 中速设备 + 高速设备 分类：块设备 + 字符设备 以块为单位进行信息交换 eg.移动硬盘 字符设备常采用中断驱动方式 I/O控制器 CPU控制I/O控制器 I/O控制器控制设备的机械部件\n功能： 接收识别CPU命令——控制寄存器存放 向CPU报告设备状态——状态寄存器 数据交换——数据寄存器 地址识别——为寄存器设置地址 组成：CPU与控制器的接口 + I/O逻辑 + 控制器与设备的接口（多个） 各寄存器也可能有多个 寄存器地址分类：内存映像I/O——与内存地址统一编址 寄存器独立编址——使用单独的地址 都储存在内存中 I/O控制方式 程序直接控制方式：数据最后要存储到内存中 CPU干预频繁 每次传送一个字 实现简单 but CPU与I/O只能串行工作 CPU长期处于忙等 中断驱动方式：CPU发出命令后将等待I/O的进程阻塞 切换执行其它进程 I/O完成后发出中断信号 CPU检测到中断信号后处理中断（读一个字） 之后恢复进程运行环境（等待I/O或其它） CPU在每个指令周期末尾检查中断 中断时需要保存进程现有状态 频繁中断效率低 DMA直接存储器存取——主要用于块设备的I/O控制 数据从设备到内存 or 从内存到设备 不经过CPU CPU通过MAR内存地址寄存器等指明存放位置等信息 可读写一个或连续的多个块 CPU只在传送的开始或结束时介入 but 只能读写连续的数据块 通道控制 = 更弱的CPU（硬件） CPU只需发出I/O命令 完成后向CPU发出中断信号 可处理一组块 I/O软件层次结构 know某处理是在哪层完成的 用户层软件：与用户交互 提供库函数进行操作 \u0026amp; 将用户请求转为I/O请求 用系统调用请求内核服务 设备独立性软件（与硬件特性无关的功能） 如：向上层提供系统调用接口\u0026amp;设备保护（如访问权限）\u0026amp;差错处理\u0026amp;设备分配回收\u0026amp;数据缓冲区管理\u0026amp;逻辑、物理设备名映射 不同设备内部硬件特性不同——不同的设备驱动程序 设备驱动程序：对硬件设备的具体控制 将命令转化为特定设备的操作 中断处理程序：I/O任务完成时控制器发送中断信号 系统根据中断信号类型找到中断处理程序 输入输出管理 I/O程序接口： 字符设备接口 get/put系统调用 块设备 read/write seek——在读写指针处操作 网络设备 网络套接字socket接口 eg.localhost:1313 1313即为一个套接字 可与其它ip地址的socket绑定 实现信息传输 阻塞I/O 发出I/O系统调用进程需转为阻塞态 非阻塞I/O不需阻塞等待 设备驱动程序接口——设备独立软件层 I/O核心子系统 I/O调度——类其它调度策略 设备保护——UNIX将设备视为特殊的文件 假脱机技术SPOOLing 用户层软件 模拟脱机技术\n组成：缓冲区与井都暂存数据 位置不同 共享打印机原理——输出井为每个打印请求分配一个存储区（逻辑设备） 设备的分配与回收 设备独立性软件\n设备分配考虑：设备固有属性 设备分配算法 设备分配安全性 分配方法： 静态分配 运行前分配资源 动态分配 过程中分配 分配管理的数据结构 设备控制表DCT 指向COCT的指针 控制器控制表COCT 指向CHCT的指针 通道控制表CHCT 等待队列指针 系统设备表SDT 包括DCT 分配步骤：根据物理设备名找SDT 从SDT找到DCT 到COCT找到控制器 到CHCT分配通道 设备、控制器、通道都分配成功才成功 必须使用物理设备名——难换 \u0026amp; 若正忙进程必须阻塞等待 改进：用逻辑设备名申请 OS用LUT（逻辑设备表）实现名称映射 一张LUT中逻辑设备名不可重复 一般每个用户一张 缓冲区 作用：缓和CPU与I/O设备速度不匹配的矛盾 减少对CPU的中断频率 解决数据粒度不匹配问题（字符/块） 单缓冲：主存中分配缓冲区——非空时不能进数据 空时可以进数据但必须充满 双缓冲：分配2个缓冲区 循环缓冲区：多个大小相等的缓冲区链接为循环队列 缓冲池：系统中共用的缓冲区组成 可分为空缓冲队列 装满输入数据的缓冲队列（输入队列） 输出队列 缓冲区种类：收容输入hin 提取输入sin 收容输出sout 提取输出hout 磁盘 结构 磁盘上一圈为一个磁道 磁道被分为一个个扇区（即磁盘块） 可能有很多盘面 但所有盘面连轴转 每个磁头共进退 各扇区存放数据量相同 读写数据：移到指定磁道 磁盘转动使目标扇区从磁头下划过实现 柱面号-盘面号-扇区号定位磁盘块 柱面：所有盘面中相对位置相同的磁道（下图黄色部分） 分类：活动头磁盘（磁臂可移动） 固定头磁盘（不可动 但有很多磁臂） 也可按盘片可否更换分类 磁盘调度算法 一次读写操作时间： 寻找时间——读写数据前 磁臂移动到指定磁道 延迟时间——旋转磁盘 定位扇区 传输时间——从磁盘读出/写入数据 调度算法： 先来先服务FCFS：进程请求磁盘访问的先后顺序 最短寻找时间优先SSTF：优先处理离当前磁头最近的磁道 可能饥饿 扫描SCAN（电梯算法）：磁头移动到最外侧才能向内动 反之亦然 不会饥饿 but 不同磁道响应频率不平均 LOOK：若在移动方向上无其他请求 可以立即改变磁头移动方向 循环扫描C-SCAN：只有朝固定方向移动时才处理磁道访问请求 返回时直接到起始段 响应频率平均 but 平均寻道时间更长 C-LOOK：移动方向上若无其他请求立即返回 减少延迟时间的方法 读取一块后就需要处理——但磁盘转动不停——下一块要转圈\n交替编号——逻辑上相邻的扇区在物理上有间隔 磁盘地址结构设计： 为什么柱面号在前？ 面对连续的地址如000,00,000-000,01,111 柱面号在前时不用移动磁臂；盘面号在前需移动磁臂 错位命名——改变相邻盘面对应顺序（相邻地址读取时间问题） 磁盘管理（理解） 磁盘初始化： 低级格式化（物理格式化）——划分扇区 分为头、数据区域、尾 磁盘分区——每个分区由若干柱面组成eg.C盘 逻辑格式化——创建文件系统（创建根目录 初始化数据结构eg.位示图） 引导块（启动块/启动分区）——存放完整的自举程序 启动块位于磁盘的固定位置 拥有启动分区的磁盘 = 启动磁盘/系统磁盘eg.C盘 坏块（无法正确使用的扇区） 简单的磁盘可在逻辑格式化时检查并标明 复杂的用磁盘控制器维护坏块链 管理备用扇区 固态硬盘SSD 重点如下\n主要结构： 以页为单位读写 以块为单位进行数据擦除 方可重写每页 先把不需擦除的页复制到其它闪存芯片对应位置 在其它芯片上写后整体移入原芯片 映射的物理位置可以改变 读快写慢 SSD的一个块被多次擦除可能会损坏 磨损均衡技术：将擦除平均分布在各个块上 动态磨损均衡：写入数据时 优先选择累计擦除次数少的新闪存块 静态磨损均衡：SSD分配数据 让老旧闪存块承担以读为主任务 新的以写为主🥳🥳 ","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ca href=\"https://www.bilibili.com/video/BV1YE411D7nH/\" style=\"color: black; text-decoration: underline;\"\u003e所有图片来自：王道计算机考研 操作系统\u003c/a\u003e\n\u003ch2 id=\"操作系统\"\u003e操作系统\u003c/h2\u003e\n\u003ch3 id=\"定义\"\u003e定义\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e系统资源的管理者\u0026amp;提供方便的接口与环境\u0026amp;最接近硬件的软件\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e功能：处理机(CPU)管理\u0026amp;存储器管理\u0026amp;文件管理\u0026amp;设备管理\n\u003cul\u003e\n\u003cli\u003e程序运行 将相关数据从磁盘放入\u003cstrong\u003e内存\u003c/strong\u003e = 存储器\u003c/li\u003e\n\u003cli\u003e进程被CPU管理 = 处理机\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e接口\u0026amp;环境\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart LR\n 接口--\u0026gt;GUI\n 接口--\u0026gt;程序接口\n 用户接口--\u0026gt;程序接口\n 用户接口--\u0026gt;脱机命令接口\n 接口--\u0026gt;命令接口\n 命令接口--\u0026gt;脱机命令接口\n 命令接口--\u0026gt;联机命令接口\n 联机命令接口---交互式命令接口\n 交互式命令接口--\u0026gt;cmd\n 批处理--\u0026gt;.bat\n 脱机命令接口---批处理\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eGUI 图形化用户接口\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e硬件拓展\n\u003cul\u003e\n\u003cli\u003e无软件支持的计算机 = 裸机\u003c/li\u003e\n\u003cli\u003e覆盖了软件 = 扩充机器（虚拟机）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"四个特征\"\u003e四个特征\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发 共享 是最基本的特征 互为存在条件\u003c/p\u003e","title":"操作系统OS"},{"content":" 部分代码来自：OI WIKI 基础 三要素 数据结构 = 逻辑结构 + 数据运算 + 物理结构 逻辑结构=集合+线性+树形+图状 运算=增删改查 物理结构=存储结构=顺序+链式+索引+散列 存储 时间复杂度排序：O(1) \u0026lt; O(log~2~n) \u0026lt; O(n) \u0026lt; O(nlog~2~n) \u0026lt; O(n^2^) \u0026lt; O(n^3^) \u0026lt; O(2^n^) \u0026lt; O(n!) \u0026lt; O(n^n^) 最坏\u0026amp;平均时间复杂度度量 最深层循环的循环次数与n的关系 乘法规则：相乘后度量 空间复杂度 内存中的变量存储大小 递归\u0026amp;动态规划 递归：选定递归基 + 认定该方法可以解决该问题\n空间复杂度较高 动态规划：部分或完全消除算法中的递归成分（用有限空间记录子问题的解 以避免重复访问子问题） 条件：\n最优子结构（可能适用贪心） 无后效性：已求解的子问题不受后续决策影响 子问题重叠 线性表 相同数据类型 有限序列（有次序） ai中i为位序\n基础 基本操作 InitList(\u0026amp;L) DestroyList(\u0026amp;L) 增删改查: ListInsert(\u0026amp;L,i,e) ListDelete(\u0026amp;L,i,\u0026amp;e) LocateElem(L,e)按值查找 GetElem(L,i)按位查找 Length(L) \u0026amp; PrintList(L) \u0026amp; Empty(L) 传入\u0026amp;：需要用到修改后的值 栈 后进先出 (last in first out,LIFO)\nCpp的STL中stack容器提供成员函数： st.top()返回栈顶 st.push()进栈到顶 st.pop()弹出栈 st.empty() st.size()栈容量 Python模拟栈 st=[1,2,3] st.append(2) # 入栈 st.append(3) # [1,2,3,2,3] st.pop() st.clear() 队列 先进先出 (first in first out,FIFO)\n数组模拟队列 标记队列首尾(ql,qr) 删除元素：ql++ 清空队列：ql=1,qr=0(ql\u0026gt;qr即可) 双栈模拟队列 F为队尾栈 S为队首栈 pop时若S为空 则将F元素弹出后插入S 再进行pop 双端队列 队首队尾均可插入删除元素 Python中容器为collections.deque 循环队列 下标为0的位置视为最后位的后继 队列向数组尾部移动 最终入队即使有空位也会溢出（假溢出） 单调栈与单调队列 保证元素单调性的栈/队列（递增or递减）\n维护一个单增/单减的数组 实现最小/最大值查找\\\n(以单减找最大为例) 新元素与队尾元素比较 若更小则进队 若更大 则从队尾开始将所有比之更小的元素踹出队 lc.239滑动窗口找最大\\ int head=0,tail=-1; int i=0; int[] win=new int[nums.length]; for(;i\u0026lt;k;i++){ while(head\u0026lt;=tail\u0026amp;\u0026amp;nums[win[tail]]\u0026lt;=nums[i]){ tail--; } win[++tail]=i; System.out.println(\u0026#34;now tail is \u0026#34;+tail); } System.out.println(nums[win[head]]); for(;i\u0026lt;nums.length;i++){ while(head\u0026lt;=tail\u0026amp;\u0026amp;nums[win[tail]]\u0026lt;=nums[i]){ tail--; } win[++tail]=i; while(win[head]\u0026lt;=i-k) head++; System.out.println(nums[win[head]]); } 类似还有lc.84/739/862/901/907等可用类似方法\n链表 增删 O(1) 查读 O(n)\n单向链表 指针 + 数据 双向链表 指针（左、右） + 数据 struct Node{ int value; Node *left; Node *right; }; 插入数据 单向链表 new node的next指向p的next node p的next node指向new node node-\u0026gt;value=i; node-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=node; 单向循环链表 首尾相连 插入时判断是否为空 若为空 new node的next指向自己 p指向new node if(p==NULL){ p=node; node-\u0026gt;next=node; } 双向循环链表 判断是否为空 \u0026amp; 修改左右两个指针 非空 node-\u0026gt;left = p; node-\u0026gt;right = p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left = node; p-\u0026gt;right = node; 删除数据 单向循环链表 删除p = p-\u0026gt;next的值给p \u0026amp; 跳过p-\u0026gt;next p-\u0026gt;value = p-\u0026gt;next-\u0026gt;value; Node *t = p-\u0026gt;next; p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; 双向循环链表 p-\u0026gt;left-\u0026gt;right = p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left = p-\u0026gt;left; Node *t = p; p = p-\u0026gt;right; delete t; 哈希表 key-\u0026gt;哈希函数-\u0026gt;索引≈内存位置-\u0026gt;value\n哈希冲突 = 不同key计算的索引相同 拉链法（开散列法）多键值索引到同一位置 在该位置建立链表 闭散列法 所有记录记录在散列表中 发生冲突则根据某方式继续探查 堆 树 每个节点的键值都大于等于/小于root节点的键值\n大于等于的为最小化堆 反之为最大化堆（左子大于右子）\n二叉堆 结构：完全二叉树（以下以最大化堆为例） 插入：最下层最右叶子插入 向上调整 复杂度O(logn) 删除（root）：root与最后的节点交换 向下调整 向下调整 = 子节点中最大的与新root交换 复杂度O(logn) 实现：在序列中 Hi的子节点为H2i与H2i+1 void up(int x) { while (x \u0026gt; 1 \u0026amp;\u0026amp; h[x] \u0026gt; h[x / 2]) { std::swap(h[x], h[x / 2]); x /= 2; } } void down(int x) { while (x * 2 \u0026lt;= n) { t = x * 2; if (t + 1 \u0026lt;= n \u0026amp;\u0026amp; h[t + 1] \u0026gt; h[t]) t++; if (h[t] \u0026lt;= h[x]) break; std::swap(h[x], h[t]); x = t; } } 建堆：向上/向下调整 向上调整 从叶子开始向堆上部移动 复杂度O(nlogn) 向下调整 从root开始向堆下部移动 复杂度O(n) 二叉树 二叉搜索树 左子\u0026lt;root\u0026lt;右子\n删除元素：若有两个非空子节点 用左子树的最大值/右子树的最小值代替它后删除\n平衡树 每个节点的左子树和右子树高度差最多为1\n调整过程 右旋 root左子成为新root root成为新root的右子 新root原右子成为root左子 TreeNode* newRoot = root-\u0026gt;left; root-\u0026gt;left = newRoot-\u0026gt;right; newRoot-\u0026gt;right = root; 四种平衡破坏情况 LL RR省略 LR 左子的右子树过长 RL 右子的左子树过长（类上） AVL树 平衡的二叉搜索树\n性质：\nAVL的左右子树也是AVL树 且左右子树高度相差不大于1（平衡因子 = 右子树高 - 左子树高） 树高logn 调整：若平衡因子=-2 == 左子左旋后root右旋 B树 每个节点可以拥有两个以上的子节点 增删改查在对数时间完成\n最下层的节点称为叶子节点 性质：（m阶）\n每个节点最多有m个子节点 非叶子节点（除root）最少有m/2个子节点 若root不是叶子节点 则至少有2个子节点 排序 冒泡排序 对序列逐个扫描 n次扫描后排序完毕\n最坏\u0026amp;平均情况下时间复杂度O(n^2^) 最好情况下时间复杂度O(n)\nbool flag = true; while (flag) { flag = false; for (int i = 1; i \u0026lt; n; ++i) { if (a[i] \u0026gt; a[i + 1]) { flag = true; int t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; } } } 插入排序 最坏\u0026amp;平均情况下时间复杂度O(n^2^) 最好情况下时间复杂度O(n)\\\n从头开始遍历每个需插入的数据 与其前已排序的数据的末尾向头逐一比较 for (int i = 1; i \u0026lt; len; ++i) { int key = arr[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } 折半插入 二分算法优化 时间复杂度不变 快速排序 将数列划分为2parts 递归到两子序列中进行快排 = 挖坑填数\n最优/平均时间复杂度O(nlogn) 最坏O(n^2^)\n若选第一个数为基准数 数组首尾两指针 i\u0026amp;j\n从j开始向前找小于或等于基准数的 放到原基准数的位置\n从i开始向后找大于基准数的 放到原j的位置\n以此循环 最后i=j放入基准数\n在前后两parts再继续进行以上步骤\n三数取中：前中后三个数先排序——中与后换（后的前一个也可以）——从 前 到 后的前一个 进行大小判断（前指针先动）——后和指针位置处数字交换——重复\n排序后再选pivot while内每一步也要限定i\u0026lt;j或i\u0026lt;=j（且放在\u0026amp;\u0026amp;号之前） void quick_sort(int s[],int l,int r){ if(l\u0026lt;r) { int i=l,j=r,base=s[l]; while(i\u0026lt;j){ while(i\u0026lt;j\u0026amp;\u0026amp;s[j]\u0026gt;base) j--; if(i\u0026lt;j){ s[i++]=s[j]; } while(i\u0026lt;j\u0026amp;\u0026amp;s[i]\u0026lt;=base) i++; if(i\u0026lt;j){ s[j--]=s[i]; } } } s[i]=base; quick_sort(s,l,i-1); quick_sort(s,i+1,r); } 优化：\n三路快速排序 三路取中（首、中、尾三元素进行比较后选择base） 与base相等的元素聚集在其周边 短序列用插排 归并排序 时间复杂度O(nlogn) 空间复杂度O(n)\n堆排序 二叉堆 = 完全二叉树（/近似） 最大堆/最小堆 时间复杂度：$O(nlogn)$ 空间复杂度：$log(n)$ 递归使用栈的空间代价\n拥有一个arr 对arr建最大堆——只检查倒数第二行及以上，使用heapify 循环检查 从最后一个数字检查到第二行（即不包括root）——将root与当前数字交换后，从顶向下heapify 过程中可以将len\u0026ndash;（后面的已经检查过了） heapify：左子右子定义——检查parent是否比左子右子大——否 则将其与最大值交换后向下继续heapify（更新被交换的子的子树） public static void main(String[] args) { int[] arr={6,3,8,2,9,4,7,1,5}; int len=arr.length; buildMaxHeap(arr,len); for(int i=len-1;i\u0026gt;0;i--){ swap(arr,0,i); len--; heapify(arr,0,len); } System.out.println(Arrays.toString(arr)); } public static void buildMaxHeap(int[] arr,int len) { for(int i=len/2;i\u0026gt;=0;i--){ heapify(arr,i,len); } } public static void heapify(int[] arr,int i,int len) { int left=i*2+1; int right=i*2+2; int largest=i; if(left\u0026lt;len \u0026amp;\u0026amp; arr[left]\u0026gt;arr[largest]) largest=left; if(right\u0026lt;len\u0026amp;\u0026amp; arr[right]\u0026gt;arr[largest]) largest=right; if(largest!=i){ swap(arr,largest,i); heapify(arr,largest,len); } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 特殊应用 康托展开 数学方法 详见wiki\n应用：LC.60排列排序permutation-sequence\n","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ca href=\"https://oi-wiki.org/\" style=\"color: black; text-decoration: underline;\"\u003e部分代码来自：OI WIKI\u003c/a\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"三要素\"\u003e三要素\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e数据结构 = 逻辑结构 + 数据运算 + 物理结构\n\u003cul\u003e\n\u003cli\u003e逻辑结构=集合+线性+树形+图状\u003c/li\u003e\n\u003cli\u003e运算=增删改查\u003c/li\u003e\n\u003cli\u003e物理结构=存储结构=顺序+链式+索引+散列 存储\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e时间复杂度排序：\u003ccode\u003eO(1) \u0026lt; O(log~2~n) \u0026lt; O(n) \u0026lt; O(nlog~2~n) \u0026lt; O(n^2^) \u0026lt; O(n^3^) \u0026lt; O(2^n^) \u0026lt; O(n!) \u0026lt; O(n^n^)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e最坏\u0026amp;平均时间复杂度度量\u003c/li\u003e\n\u003cli\u003e最深层循环的循环次数与n的关系\u003c/li\u003e\n\u003cli\u003e乘法规则：相乘后度量\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e空间复杂度 内存中的变量存储大小\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"递归动态规划\"\u003e递归\u0026amp;动态规划\u003c/h3\u003e\n\u003cp\u003e递归：选定递归基 + 认定该方法可以解决该问题\u003c/p\u003e","title":"数据结构"},{"content":" 存储引擎 MySql体系结构 MySql服务器 flowchart LR 连接层--\u0026gt;服务层 服务层\u0026lt;--\u0026gt;SQL接口 服务层\u0026lt;--\u0026gt;解析器 服务层\u0026lt;--\u0026gt;查询优化器 服务层\u0026lt;--\u0026gt;缓存 SQL接口--\u0026gt;d((可插拔式存储引擎)) 解析器--\u0026gt;d 查询优化器--\u0026gt;d 缓存--\u0026gt;d d--\u0026gt;存储层 存储引擎包括InnoDB等，Index信息也存储在其中 存储层存储系统文件、文件和日志等 存储引擎 存储引擎简介 存数据、建索引、更新数据等的实现方式，基于表不基于库（被称为表类型）\n建表时指定存储引擎\nCREATE TABLE 表名( … \\)ENGINE=INNODB … SHOW ENGINES; 显示支持的存储引擎\n存储引擎特点 InnoDB DML操作遵循ACID模型 支持事务 行级锁 提高并发访问性能 支持外键 以.idb表空间文件存储该表的表结构(frm sdi)、数据与索引 用cmd打开 idb2sdi ***.idb 查看表结构 数据段即为B+树的叶子节点 索引段为非叶子节点 flowchart LR Tablespace--\u0026gt;Segment--\u0026gt;Extent--\u0026gt;Page--\u0026gt;row 表空间--\u0026gt;段--\u0026gt;区--\u0026gt;页--\u0026gt;行 MyISAM 不支持事务 外键 支持表锁 不支持行锁 访问速度快 ✕✕.sdi 存储表结构信息 ✕✕.MYD 存储数据 ✕✕.MYI 存储索引 Memory 存储在内存中 只做临时文件\n内存存放 hash索引 ✕✕.sdi 存储表结构 比较 特点 InnoDB MyISAM Memory 事务安全 支持 - - 锁机制 行锁 表锁 表锁 支持外键 支持 - - B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持 支持 - 空间使用 高 低 N/A 内存使用 高 低 中 批量插入速度 低 高 高 选择 InnoDB 事务完整性\u0026amp;并发条件 各种操作都很多 MyISAM 以读\u0026amp;插入操作为主 少更新\u0026amp;删除 对事务的完整性与并发性要求不高(被ControlDB取代) Memory 临时表的缓存 对表的大小有限制 安全性没有保障(被Redis取代) 索引 索引概述 帮MySql高效获取数据的数据结构（有序） 在存储引擎中实现 优点： 提高查询效率 降低IO成本 降低排序成本 降低CPU消耗 缺点： 占用磁盘空间 降低更新表的速度 索引结构 主要索引： 索引结构 描述 B+Tree索引 大部分引擎都支持 最常见 Hash索引 不支持范围查询 精确匹配索引列的查询才有效 R-Tree(空间索引) MyISAM的特殊索引 用于地理空间数据类型 Full-text(全文索引) 建立倒排索引 快速匹配文档 支持引擎： 索引 InnoDB MyISAM Memory B+Tree 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree 不支持 支持 不支持 Full-text 支持 支持 不支持 一般索引直接指B+Tree索引 B+Tree\u0026amp;其它Tree 二叉树：左子小于亲点 右子大于亲点 顺序插入时会形成链表 大数据量下 层级较深 效率低 红黑树：新数据会先与根节点判断大小 大数据量下 层级较深 B Tree(多路平衡查找树)： 最大度数为n，最多n个子节点，每个节点最多存储n-1个key(元素)，n个指针 中间节点向上分裂 B+Tree 所有元素都会出现在叶子节点(树只起到索引作用) 所有叶子节点形成单向链表 B+Tree in MySql 增加了指向相邻叶子节点的链表指针 形成带顺序指针的B+Tree 一页(一个磁盘块)只存放指针和key不存放数据，则一页上可以存放的指针与key相比BTree更多，故层级更少 Hash 键值换算成新的hash值 映射到对应槽位 存储在hash表中 hash冲突(多个键值映射到同个槽位)时用链表解决 特点： 只能用于对等比较 不支持范围查询 无法利用索引进行排序 查询效率高 通常只需一次检索 通常效率高于B+Tree 索引分类 分类： 索引 含义 特点 关键字 主键索引 针对主键创建的 默认自动创建 onlyone PRIMARY 唯一索引 避免同表中某列数据的值重复 可有多个 UNIQUE 常规索引 快速定位特定数据 可多个 全文索引 查找文本关键词 非比较索引中的值 可多 FULLTEXT 根据索引的存储形式分类： 聚集索引 将数据存储与索引放到一起 索引的叶子节点保存行数据(有且仅有1个) 聚集索引选取规则：主键\u0026gt;第一个唯一索引\u0026gt;innoDB生成rowid作为隐藏聚集索引 二级索引 将数据与索引分开存储 叶子节点关联对应主键(可有多个) 如建立name的索引 叶子节点即存储id 回表查询 eg.查询Satti的所有信息 先二级索引查主键 后聚集索引查row信息 索引语法 CREATE [UNIQUE/FULLTEXT] INDEX 索引名 ON 表名 (字段名,…); 创建索引 字段名后可指定升降序建立索引 索引名一般为 idx_表名_字段名1_字段名2 可以关联多个字段 SHOW INDEX FROM 表名[\\G]; 查看索引 \\G可以把以行显示的索引转换为列显示 DROP INDEX 索引名 ON 表名; 删除索引 SQL性能 性能分析 SHOW GLOBAL STATUS LIKE'Com____' 查询命令(Delete等)执行频次 SHOW GLOBAL STATUS提供服务器状态 7个下划线 慢查询日志 记录超过指定时间的SQL语句 SHOW VARIABLES LIKE'SLOW_QUERY_LOG‘; 检查慢查询日志是否开启 开启慢查询日志： 在MySql配置文件/etc/my.cnf中配置\n#开启慢查询 slow_query_log=1\n#设置慢日志时长\nlong_query_time=2 查看记录信息 /var/lib/mysql/localhost-slow.log profile详情 SELECT @@have_profiling; 是否支持profile操作 开启profile SET PROFILING=1 SHOW PROFILES; 查看所有指令耗时 SHOW PROFILES [CPU] FOR QUERY query号; 查看某个query的耗时(与cpu消耗) explain执行计划 在select语句前加 desc 或 explain id select查询的序列号（操作顺序） id相同 顺序从上到下 id不同 值越大越先执行 type 性能指标从好到差： NULL\u0026gt;system\u0026gt;const(以上较好)\u0026gt;eq_ref\u0026gt;ref\u0026gt;range\u0026gt;index\u0026gt;all 主键/唯一索引==const possible_key 可能用到的索引 key 实际用到的索引 key_len 索引字段最大可能长度 rows 预估执行查询的行数 filtered 返回结果行数占读取行数的比例(越大越好) 索引使用原则 最左前缀法则 联合索引时遵守\n查询从索引的最左列开始 且不跳过索引中的列（即从联合索引的第一个字段开始） 若跳过索引中某字段 则后面的字段失效 范围查询 联合索引时遵守\n即\u0026gt; \u0026lt;等范围限定 若出现 其右侧列索引失效 若使用\u0026gt;=或\u0026lt;=则不存在此问题 失效问题 索引列运算 若对索引中的字段进行运算 索引失效 包括substring等 字符串不加引号 字符串类型字段若不加引号 索引失效 模糊查询 尾部模糊查询 不失效 头部模糊查询 索引失效 or连接 or中一条件中的字段有索引 + 另一列无索引 = 索引失效 数据分布影响 如索引效率不如全表扫描时 启用全表扫描 SQL提示 EXPLAIN select语句 USE INDEX(索引名) 建议使用某索引 EXPLAIN select语句 IGNORE INDEX(索引名) 不用某索引 EXPLAIN select语句 USE INDEX(索引名) 必用某索引 覆盖索引 需要返回的列在索引中可全部找到 \u0026ldquo;using where;using index\u0026rdquo; 在列 \u0026ldquo;using index condition\u0026rdquo; 需回表查询 前缀索引 字段类型为varchar text等 需索引很长字符串——前缀索引 CREATE INDEX 索引名 ON 表名(COLUMN(N)); 创建前缀索引 N为前缀长度 选择性计算：COUNT(DEISTINCT SUBSTRING(字段名,m,n))/COUNT(\\)* 根据选择性取舍选择N的大小 单列与联合索引的选择 业务场景中存在多个查询条件 建议采用联合索引 单列易产生回表查询 索引设计原则 数据量较大（\u0026gt;几十万） 查询频繁 常作为where、order by、group by条件的字段 区分度高的列（相对唯一 如身份证号等） 若为字符串类型 字段长度较长——前缀索引 尽量使用联合索引 控制索引数量 若索引列不能有NULL 建表时即规定NOT NULL 便于优化器选用索引 SQL优化 插入优化 基本优化 批量插入(500-1000条) 手动提交事务 主键顺序插入 大批量插入数据\n# 客户端连接服务端时加\u0026ndash;LOCAL-INFILE\nMYSQL --LOCAL-INFILE -U ROOT -P;\n# 设置全局参数为1 允许从本地加载文件导入数据\nSET GLOBAL LOCAL_INFILE=1;\n# 执行load加载数据\nLOAD DATA LOCAL INFILE '数据地址' INTO TABLE '表名' FIELDS TERMINATED BY ',' LINES TERMINATED BY '\\n'; linux命令行：head 文件名查看文件前十行 主键优化 数据组织方式 InnoDB中 表数据按主键顺序组织存放 此种表即为索引组织表(IOT) 页分裂 （页中存放的是行数据）\n每个页包含2~n个数据（若1个 则相当于一个链表） 根据主键排列 若乱序插入 可能发生页分裂 前一页后50%部分与新数据挪至新页 新页插入前一页与后一页间 页合并 当页中删除的row达到MERGE-THRESHOLD（默认50%） InnoDB会寻找靠近的页进行合并 MERGE-THRESHOLD 合并页的阈值 可自定义 主键设计原则 尽量降低主键长度（占用的字节大小） 尽量顺序插入（自增主键） 尽量不用UUID（通用唯一识别码）或其它自然主键（如身份证号）为主键 因为无序 避免修改主键 order by优化 Extra显示 Using index 通过索引排序 Using filesort 不可通过索引直接返回排序结果 索引升序创建时 若倒序排序则需filesort 优化 根据排序字段建立合适索引 多字段排序时也遵循最左前缀 尽量使用覆盖索引\u0026amp;注意升降序设定 不可避免出现filesort大数据量排序时 适当增加排序缓冲区sort_buffer_size大小 group by优化 extra显示 Using temporary 使用临时表（性能低） Using index 使用索引 满足最左前缀 limit优化（分页） limit不能用在in/all/any/some子语句中==多表查询 将limit的结果视为新表 覆盖索引 + 子查询 原表与分页查到的主键id表联合查询name等索引覆盖的字段 count优化 MyISAM将表的总行存在磁盘中 效率高 InnoDB需将数据从引擎中读出后累计计数 优化思路 自己计数（设定计数器cnt） 用法 count(*) 不取值 直接累加 count(主键) 取主键id值 按行累加 主键不可能为NULL count(字段) 字段为NULL时 count不加1 字段有not null约束时 不需判断null count(1) 可以取-1等 服务层对返回的每一行放1（或-1）进去 后逐行累加 效率：字段 \u0026lt; 主键id \u0026lt; 1 \u0026lt; * update优化 update优先行锁（有索引字段时 锁住该行）若无索引 执行表锁 InnoDB的行锁针对索引 视图 虚拟存在的表 只保存查询的逻辑不保存结果\n视图语法 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED |LOCAL] CHECK OPTION]\n创建视图（OR REPLACE或替换视图） SHOW CREATE VIEW 视图名\n查看创建视图语句\nSELECT * FROM 视图名\n查看视图 类似表 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED/LOCAL] CHECK OPTION]\n修改视图（REPLACE为主要）\nALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED/LOCAL] CHECK OPTION]\n修改视图 DROP VIEW [IF EXISTS] 视图名称 删除视图 检查选项 WITH [CASCADED/LOCAL] CHECK OPTION 使之后对视图进行的增删改操作符合视图最初的定义 CASCADED/LOCAL 检查依赖视图的规则 保持一致性 二者限定的范围不同 CASCADED （若v1未指定视图检查 但为v2的依赖视图 也会检查v1）检查所有亲辈的限制 无论其是否指定 LOCAL 若v1未指定 则不检查v1 视图更新 可更新的视图：视图中的行与基础表的行一一对应 包含 聚合/DISTINCT/GROUP BY/HAVING/UNION/… 的视图不可更新 视图作用 简单 简化理解\u0026amp;操作（复杂且多次使用到的检索可以形成视图） 安全 可以只查看某表的部分内容（授权只能精确到表） 数据独立 屏蔽基表变化对查看信息带来的影响 存储过程 SQL语言的代码封装与重用\n特点 封装 复用 可以接收参数 返回数据 减少应用途径与数据库间的网络交互 提升效率 语法 创建存储过程 CREATE PROCEDURE 存储过程名([参数列表])* BEGIN ——SQL语句 END; 命令行中解决遇 ; 即停问题：用delimiter 某符号指定语句结束位置 在DataGrip中存储为routines 中文“例程”\nCALL 存储过程名([参数列表]) 调用存储过程 SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='表名';\n查询指定数据库的存储过程与状态\nSELECT CREATE PROCEDURE 存储过程名\n查询某存储过程的定义 DROP PROCEDURE 存储过程名 删除存储过程 变量 系统变量 由服务器提供 分为全局变量GLOBAL与会话变量SESSION（仅在当前会话 即当前控制台 生效） 默认SESSION 系统重启后全局参数失效 可在/etc/my.cnf中配置 SHOW [SESSION/GLOBAL] VARIABLES;\n查看所有系统变量\nSHOW [SESSION/GLOBAL] VARIABLES LIKE '…';\n模糊匹配\nSELECT @@[SESSION/GLOBAL] 系统变量名;\n查看指定变量的值 系统变量用@@ SET [SESSION/GLOBAL] 系统变量名=值\nSELECT @@[SESSION/GLOBAL] 系统变量名=值\n设置系统变量 SET SESSION AUTOCOMMIT =0 切换到手动提交 用户自定义变量 不用提前声明 通过“@变量名”使用(未定义时调用返回null) 作用域为当前\nSET @变量名=值;\nSET @变量名:=值;\nSELECT @变量名=值;\n赋值 可多个同时赋值\nSELECT 字段名 INTO @变量名 FROM 表名; 将字段名结果赋值给变量 SELECT @变量名 使用变量 局部变量 作用域在begin…end块之间 先声明后调用\nDECLARE 变量名 变量类型 [DEFAULT …]; 声明（有否默认值） SET 变量名 := 值\nSELECT 字段名 INTO 变量名 FROM 表名;\n为变量赋值 条件判断\u0026amp;循环 if IF 条件1 THEN …; ELSEIF 条件2 THEN …; ELSE …; END IF; 用SELECT语句显示返回值\n参数 类型 类型 含义 备注 IN 输入 调用时传入值 默认 OUT 输出 可为返回值 INOUT 输入\u0026amp;输出 CREATE PROCEDURE 存储过程名([IN/OUT/INOUT 参数名 参数类型]) case CASE [变量] WHEN … THEN …; … ELSE … END CASE; while WHILE 条件 DO SQL逻辑 END WHILE 条件为true时进行 repeat REPEAT SQL逻辑 UNTIL 条件 END REPEAT 先执行一次逻辑 若条件满足则停止循环 loop [begin_label:] LOOP … END LOOP [end_label]; 配合语句： LEAVE LABEL; 退出循环 ITERATE LABEL; 只可在循环中使用 跳过当前循环剩下的语句进入下一次循环 游标\u0026amp;条件处理程序 游标 暂时存储查询结果集的数据类型（集合）\nDECLARE 游标名 CURSOR FOR 查询语句; 声明游标 OPEN 游标名 打开游标 FETCH 游标名 INTO 变量; 获取游标记录（可以是多个变量） CLOSE 游标名 关闭游标 使用游标记录结果集 开启游标通过循环获取游标内的数据 条件处理程序 定义在流程控制结构执行过程中遇到问题的处理步骤\nDECLARE 处理动作 HANDLER FOR 状况值 … statement; 处理动作： CONTINUE 继续执行当前程序 EXIT 终止 状况值： SQLSTATE 状态码 可用下列替代 SQLWARNING（01开头的状态码） NOT FOUND（02开头的状态码） SQLEXCEPTION（除以上两种的其它） 存储函数 有返回值 参数必为IN类型（应用少）\nCREATE FUNCTION 存储函数名([参数列表]) RETURNS 数据类型 [characteristic] BEGIN ——SQL语句 END; characteristic：（二级日志开启 默认需加）\nDETERMINISTIC 相同输入产生相同结果 NO SQL 不包含SQL语句 READ SQL DATA 包含读取数据的语句 不包含写入数据的语句 触发器 触发器定义 与表有关的数据库对象。在insert/update/delete之前或之后，触发并执行其定义的语句（多为记录数据变更日志） OLD与NEW引用触发器中发生变化的记录内容 如insert用NEW；update用OLD（引用需修改的内容）与NEW（引用修改后的内容） 只支持行级触发器 不支持语句级触发 触发器语法 CREATE TRIGGER 触发器名 BEFORE/AFTER INSERT/… ON 表名 FOR EACH ROW——行级触发器 BEGIN 语句（将修改的内容放入新建的日志表中） END; 创建触发器 “语句”为将新操作记录插入日志表（自建） 可以记录插入的详细信息 用 concat() 拼接字符串 SHOW TRIGGERS; 查看触发器 DROP TRIGGER [数据库名.]触发器名; 删除触发器 锁 概述 协调多进程或线程并发访问某资源的机制 事务中进行 分类 全局锁 数据库中所有表 表级锁 行级锁 全局锁 通常用做全数据库的逻辑备份\n语法 FLUSH TABLES WITH READ LOCK 加全局锁 MYSQLDUMP -UROOT -P1234 数据库名\u0026gt;保存地点 备份数据库 在命令行中运行 非mysql语句 用户名root 密码1234 UNLOCK TABLES 释放锁 特点（不重要） 若主库备份 备份期间不能更新主库 若从库备份 备份期间从库不能执行主库同步来的二进制日志 导致主从延迟 MYSQLDUMP --SINGLE-TRANSACTION -UROOT -P1234 数据库名\u0026gt;保存地点 不需加全局锁的备份 表级锁 锁定粒度大 发生所冲突的概率最高 并发度最低\n分类： 表锁 元数据锁 意向锁 表锁 分类： 表共享读锁 表独占写锁 LOCK TABLES 表名… READ/WRITE 加锁 读锁 所有客户端都可读 不可写 写锁 当前客户端可读 / 写 其他客户端不可读 / 写 UNLOCK TABLES 释放锁 元数据锁(meta data lock,MDL) 系统自动控制\n维护表元数据的数据一致性==表上有活动事务时不可对元数据进行写入 避免DML与DDL冲突 MySql5.5后 DML增删改查加读锁 DDL对表结构变更加写锁 SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM PERFORMANCE_SCHEMA.METADATA_LOCKS; 查看元数据锁 意向锁 使表锁不用检查每行数据是否加行锁 避免DML执行时行锁与表锁冲突 分类： 意向共享锁(IS) 意向排他锁(IX) SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM PERFORMANCE_SCHEMA.DATA_LOCKS;\n查看锁 日志中RECORD锁类型代表行锁 意向锁间不互斥\nIS 意向共享锁 由SELECT语句 LOCK IN SHARE MODE添加 与表锁共享读锁(read)兼容 与表锁排它写锁(write)互斥 IX 意向排他锁 由增删改语句 FOR UPDATE添加 与表锁共享读锁(read)互斥 与表锁排它写锁(write)互斥 行级锁 锁定粒度最小 锁冲突改率最低 并发度最高 在InnoDB存储引擎中应用\n分类： 行锁 锁定单个行记录——在RC RR隔离级别下都支持（包括共享锁与排他锁） 间隙锁 确保索引记录间隙不变 防止insert产生幻读——在RR下支持 临键锁 行锁+间隙锁（该行之前的间隙）——RR下支持 行锁类型 SQL 行锁类型 说明 增删改 排他锁 自动加 SELECT语句 无锁 SELECT加共享锁 共享锁S 手动 SELECT…FOR UPDATE 排他锁X 手动 行锁 InnoDB使用next-key（临键锁）进行搜索与索引扫描 以防止幻读\n针对唯一索引检索时 对存在的记录进行等值匹配（通过 “=” 检索）时会自动将next-key锁优化为行锁 InnoDB中不通过索引检索数据会升级为表锁 间隙锁\u0026amp;临键锁 理解 唯一索引的等值查询 给不存在的记录加锁时 优化为间隙锁 普通索引的等值查询 向右遍历到最后一个值不满足查询需求时 临键锁退化为间隙锁 唯一索引的范围查询 访问到不满足条件的第一个值为止（加锁） 间隙锁可以共存（只为防止其它事务插入间隙so） InnoDB引擎 理解 整体架构 内存架构 直接操作\n缓冲池 Buffer Pool Change Buffer 对非唯一的二级索引进行修改 操作存储在此（先到缓冲池 后到磁盘） Adaptive Hash Index 优化对缓冲池数据的查询(自动生成) 用SHOW VARIABLES LIKE '%HASH_INDEX%';查看其是否启用（模糊匹配） Log Buffer 日志缓冲区 保存要写入磁盘的log INNODB_LOG_BUFFER_SIZE查看大小 INNODB_FLUSH_LOG_AT_TRX_COMMIT刷新到磁盘的时机（可设置0 1 2 具体含义略） 磁盘结构 System Tablespaces系统表空间 主要存放Change Buffer %DATA_FILE_PATH%模糊匹配 General Tablespaces通用表空间 需在创建表时指定 CREATE TABLESPACE创建该表空间 Undo Tablespaces撤销表空间 自动创建两个 Temporary Tablespaces临时表空间 DoubleWrite Buffer Files双写缓冲区（缓冲池刷新到磁盘前先写入此） Redo Log重做日志 实现事务持久性（包括重做日志缓冲 储存在内存中） 后台线程 将缓冲区数据刷新到磁盘中\nMaster Thread核心后台线程 调度其他线程 IO Thread 负责IO请求的回调 Purge Thread 回收事务已提交的undo log Page Cleaner Thread减轻主线程刷新脏页的压力 事务原理 redo log 刷新脏页到磁盘发生错误时进行数据恢复（物理日志） undo log 回滚日志（逻辑日志） 记录数据被修改前的信息 MVCC需要 MVCC⭐ 多版本并发控制 Multi-Version Concurrency Control\n基本概念 当前读 读取记录数据的最新版本并对记录加锁 共享锁/排他锁/增删改 快照读 读取记录数据的可见（历史）版本 不加锁 RC隔断下 每次select生成一个快照读 RR 开启事务后第一个select才是快照读 S 快照读退化为当前读 MVCC 维护一个数据的多个版本 使读写操作没有冲突 快照读为其提供非阻塞读功能 依赖于： 数据库记录中的三个隐式字段 undo log readView 实现原理 三个隐式字段 （InnoDB隐式生成）\n隐藏字段 含义 DB_TRX-ID 最近修改事务ID DB_ROLL_PTR 回滚指针 指向这条记录的上个版本 配合undo log DB_ROW_ID 隐藏主键 若无指定主键则生成此字段 undo log日志（增删改时产生便于数据回滚的日志）\ninsert 只在回滚时需要log 事务提交后可被删除 删改 在回滚与快照读时需要（不会被立即删除） 生成undo log版本链 头部是最新的历史记录 尾部是最旧的历史记录 ReadView 记录并维护系统当前活跃（未提交）的事务id（MVCC提取数据的依据）\n四个核心字段 字段 含义 m_ids 当前活跃事务ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID（当前最大事务ID+1 自增） creator_trx_id ReadView创建者的事务ID 版本链数据访问规则（当前事务ID为trx_id 即DB_TRX_ID）理解 只可符合下列四个条件 若都不符合 则换下一条undo log trx_id==creator_trx_id ✔ 说明数据由当前事务更改 trx_id\u0026lt;min_trx_id ✔ 说明数据已提交 trx_id\u0026gt;max_trx_id ✖ 事务在RV生成后才开始 min_trx_id\u0026lt;=trx_id\u0026lt;=max_trx_id 且trx_id不在m_ids中 ✔ 说明数据已提交 RC隔离级别 事务中每次执行快照读时生成ReadView RR隔离级别 事务中第一次执行快照读时生成 后复用 MySql管理 系统数据库 自带四个数据库 数据库 作用 mysql 服务器运行需要的信息（时区 主从 用户 权限等） information_schema 访问元数据的表、视图等 performance_schema 底层监控服务器运行状态 收集其性能参数 sys 方便DBA 便于性能调优与诊断的视图 常用工具 MySQL 数据库名 -e \u0026quot;执行语句\u0026quot; -e执行sql语句并退出 适用于shell脚本 mysqladmin -uroot -p****** … 查看帮助文档并进行相关操作 mysqlbinlog log1 查看二进制日志文件 mysqlshow … 查找数据库/表/列/索引等 mysqldump [options] db_name备份数据库 mysqllimport或source 客户端数据（mysqldump加-T参数导出的文本文件）导入 🎉🎉 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/mysql/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"存储引擎\"\u003e存储引擎\u003c/h2\u003e\n\u003ch3 id=\"mysql体系结构\"\u003eMySql体系结构\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eMySql服务器\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart LR\n连接层--\u0026gt;服务层\n服务层\u0026lt;--\u0026gt;SQL接口\n服务层\u0026lt;--\u0026gt;解析器\n服务层\u0026lt;--\u0026gt;查询优化器\n服务层\u0026lt;--\u0026gt;缓存\nSQL接口--\u0026gt;d((可插拔式存储引擎))\n解析器--\u0026gt;d\n查询优化器--\u0026gt;d\n缓存--\u0026gt;d\nd--\u0026gt;存储层\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e存储引擎包括InnoDB等，\u003c!-- raw HTML omitted --\u003eIndex\u003c!-- raw HTML omitted --\u003e信息也存储在其中\u003c/li\u003e\n\u003cli\u003e存储层存储系统文件、文件和日志等\n\u003cimg loading=\"lazy\" src=\"2.jpg\" alt=\"系统结构图\"  title=\"系统图\"  /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"存储引擎-1\"\u003e存储引擎\u003c/h3\u003e\n\u003ch4 id=\"存储引擎简介\"\u003e存储引擎简介\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e存数据、建索引、更新数据等的实现方式，基于表不基于库（被称为表类型）\u003c/p\u003e","title":"MySql"},{"content":" 简介 NoSql 非关系型数据库 No Structured Relational\n特点： 表型 JSON型 图型==非结构化 Redis为键值类型 JSON表==数据无关联 查询方式==非SQL（语法不统一） 事务ACID无法全部满足==BASE 存储==内存 使用场景： 数据结构不固定 对一致性 安全性要求不高 性能要求 Redis 特征： 键值型 key-value 支持多种数据结构 单线程 命令具原子性 低延迟 内存 IO多路复用 编码风格 支持数据持久化 支持主从集群 分片集群（主表\u0026amp;从表） 多语言客户端 redis-cli -h 192.168.211.129 -p 6379 -a 密码\n启动（不安全） systemctl stop redis关闭 连接虚拟机与图形化界面失败=检查防火墙\n基本语法 不区分大小写\n数据结构 value类型 基本类型：String Hash List（可重复） Set SortedSet（排序集合 不可重复） 特殊类型：GEO（地理坐标） BitMap HyperLog 帮助文档 or 命令行 help\n通用命令 用help 命令名查看命令的具体使用方法\nKEYS查看符合模板pattern如a**的所有key（以a开头的key） 慢 DEL删key 会返回删除的个数 EXISTS判断是否存在 EXPIRE设置key的有效期 TTL查看key的剩余有效期 类型\u0026amp;命令 String 分类 类型 数据结构 string 字符串 int 整型 float 浮点数 常见命令 命令 作用 SET 添加/修改键值对 GET 由key得value MSET/MGET 批量操作 INCR 整型key自增1 INCRBY 整型自增指定步长 INCRBYFLOAT 浮点类型自增指定步长 SETNX 添加String键值对 前提key不存在 SETEX 添加String键值对 指定有效期 SETNX==SET key value NX\n返回0表示键值已存在不会添加\n返回1表示不存在已添加 层级结构 key的层级结构：用:隔开\n若值为Java对象 可用JSON形式存储： eg.'{\u0026quot;id\u0026quot;:1, \u0026quot;name\u0026quot;:\u0026quot;Satti\u0026quot;, \u0026quot;age\u0026quot;:20}'单引 Hash类型 无序字典 类HashMap CRUD 增删改查\n相对String类型的JSON字符串 可以将每个字段独立存储 KEY保存键名 VALUE中field保存字段名 value保存值 常见命令 命令 作用 HSET 添加/修改hash类型一对field\u0026amp;value HGET hash类型由key得filed HMSET/HMGET 对一个key批量操作 HGETALL 由key得所有field value HKEYS key中所有field HVALS key中所有value HINCRBY 字段值按指定步长自增 HSETNX 添加field 前提field不存在 List类型 类似LinkedList 但双向链表\n特征：有序 可重复 插入删除快 查询速度一般 常见命令 命令 作用 LPUSH/RPUSH 列表左/右侧插入 LPOP/RPOP 移除左/右侧第一个 LRANGE 返回一段角标范围内的所有元素 BLPOP/BRPOP 没有元素时等待指定的时间 移除时无元素 返回nil 角标 = 序号 从0开始 Set类型 类HashSet =\u0026gt; value为null的HashMap\n特征： 无序 不可重复 查找快 支持交并差集 常见命令： 命令 作用 SADD 向set添加元素 可多个 SREM 移除指定元素 SCARD 返回元素个数 SISMEMBER 是否有某元素 SMEMBERS 返回所有value 命令 作用 SINTER 求两键交集 SDIFF key1相对于key2不同的值（差集） SUNION 并集 SDIFF中key有先后顺序 SortedSet 类TreeSet（可排序的set） 数据结构不同\n每个元素具有score属性 通过属性排序=SkipList+Hash 特性： 可排序 元素不重复 查询速度快 常见命令：ZADD ZREM ZCARD ZINCRBY ZDIFF ZINTER ZUNION add时提示NX|XX NX-不存在时才插入该键 XX-存在时才插入该键 命令 作用 ZSORE 获取指定元素score ZRANK 获取指定元素排名 ZCOUNT score在某范围内的元素个数 ZRANGE 按score排序得指定排名范围内元素 ZRANGEBYSCORE 指定score范围内 默认升序排序 Z后加REV即为降序 Jedis 开启测试后通过new对象建立连接\njedis=new Jedis(ip,port);\n设置密码\njedis.auth(password)\n选择库\njedis.select(index) SpringDataRedis RedisTemplate工具类 redisTemplate.opsForValue()类似语句调用上述数据类型\n返回值类型如ValueOperations 步骤： 引入spring-boot-starter-data-redis依赖 application.yaml配置Redis 编写RedisTemplate配置类 设置@Bean test中Autowired注入RedisTemplate\u0026amp;进行Test试验 函数opsForValue()等调用value等对象（方法名有变动） StringRedisTemplate手动序列化\u0026amp;反序列化 节省内存 可以json形式存储、读取数据 or 编码为字符串类型 使用函数StringRedisSerializer 以对象形式初始化、接收 故需要手动进行序列化转换 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/redis%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003ch3 id=\"nosql\"\u003eNoSql\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e非关系型数据库 No Structured Relational\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e特点：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e表型 JSON型 图型==非结构化\n\u003cul\u003e\n\u003cli\u003eRedis为键值类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eJSON表==数据无关联\u003c/li\u003e\n\u003cli\u003e查询方式==非SQL（语法不统一）\u003c/li\u003e\n\u003cli\u003e事务ACID无法全部满足==BASE\u003c/li\u003e\n\u003cli\u003e存储==内存\u003c/li\u003e\n\u003cli\u003e使用场景：\n\u003cul\u003e\n\u003cli\u003e数据结构不固定\u003c/li\u003e\n\u003cli\u003e对一致性 安全性要求不高\u003c/li\u003e\n\u003cli\u003e性能要求\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"redis\"\u003eRedis\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e特征：\n\u003cul\u003e\n\u003cli\u003e键值型 key-\u003c!-- raw HTML omitted --\u003evalue\u003c!-- raw HTML omitted --\u003e 支持多种数据结构\u003c/li\u003e\n\u003cli\u003e单线程 命令具原子性\u003c/li\u003e\n\u003cli\u003e低延迟\n\u003cul\u003e\n\u003cli\u003e内存\u003c/li\u003e\n\u003cli\u003eIO多路复用\u003c/li\u003e\n\u003cli\u003e编码风格\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e支持数据持久化\u003c/li\u003e\n\u003cli\u003e支持主从集群 分片集群（主表\u0026amp;从表）\u003c/li\u003e\n\u003cli\u003e多语言客户端\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eredis-cli -h 192.168.211.129 -p 6379 -a 密码\u003c/code\u003e\u003cbr\u003e\n启动（不安全）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esystemctl stop redis\u003c/code\u003e关闭\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e连接虚拟机与图形化界面失败=检查防火墙\u003c/p\u003e","title":"Redis_base"},{"content":" 基本概念 RDBMS 关系型数据库 based on关系模型，多张二维表相互连接 sql操作分类 分类 全称 说明 DDL Data Definition Language 定义数据库、表、字段等 DML Manipulation 对表中数据进行增删改 DQL Query 查询表的记录 DCL Control 创建库用户 控制权限 启动与停止 net start mysql80 \u0026amp; net stop mysql80\nMySql 开机自启，在cmd中可手动停止 mysql -u root -p\n-u 提示用户为 root，-p 提示将输入密码 SQL 基本 以分号结尾，行数不论，空格与缩进不论 不区分大小写，关键字最好大写 \u0026ndash; 或 # 注释内容 多行注释 /* 内容 */ DDL DDL数据库操作 SHOW DATABASES;\n查询所有数据库 SELECT DATABASE();\n查询当前（是在哪个）数据库 创建数据库（括号内容可以不加 采用默认规则） CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; charset utf8mb4 设定为容纳4个字节的utf8 在DataGrip中可以使用SCHEMA替代DATABASE DROP DATABASE [IF EXISTS] 数据库名;\n删除数据库 USE 数据库名;\n使用数据库 DDL表操作 查询 SHOW TABLES;\n查询当前数据库所有表 DESC 表名 查询表结构 SHOW CREATE TABLE 表名 查询指定表的建表语句 创建 CREATE TABLE 表名( 字段1 字段1类型[COMMENT '中文'], 字段2 字段2类型[COMMENT '……'], …… 字段3 字段3类型[COMMENT '……'] )[COMMENT '……']; 字段1 是表头名称，如name 字段1类型： 数值类型 tinyint,smallint,mediumint,int-4字节,bigint,float,double tinyint unsigned表示无符号 即正数范围 可指定double(m,n)，m表示最长位数，n表示小数点后最长位数 字符串 char(指定长度),varchar(指定长度), char为定长字符串，varchar变长(会计算所需空间是否需要变化) 日期 date,time,datetime,year,timestamp(截至2038年) 修改 ALTER TABLE 表名 ADD 字段名 字段类型 [COMMENT 注释] [约束]; 增加字段 ALTER TABLE 表名 MODIFY 字段名 新字段类型 [COMMENT 注释]; 修改字段类型 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段类型 [COMMENT 注释]; 修改字段名\u0026amp;字段类型 ALTER TABLE 表名 RENAME TO 新表名 修改表名 删除 ALTER TABLE 表名 DROP 字段名; 删除字段 DROP TABLE [IF EXISTS] 表名; 删除表 TRUNCATE TABLE 表名; 删除并重新创建该表 DataGrip中字段翻译为列\nDML 添加数据 INSERT INTO 表名(字段名1,字段名2,…) VALUES (值1,值2,…); 指定字段添加数据 INSERT INTO 表名 VALUES (值1,值2,…); 全部字段添加数据 此处括号为分隔符号，不可省略，[]表示可以忽略 Sql 以某数据库为原点，若需修改某表，在指令中需指明该表名 字符串与时间类型用 '…' 表示 修改删除 UPDATE 表名 SET 字段名1=值1,字段名2=值2,…[WHERE 条件]; 条件可以写为 id=1 等 DELETE FROM 表名 [WHERE 条件] 不能删除某个对象中特定字段的值（只能删除行） 没有被物理删除 被标记为删除使其空间可被♻ DQL 用*表示显示所有信息，放在其它特殊检索内容前\n基本查询 SELECT 字段1，字段2，… FROM 表名; SELECT * FROM 表名 查询多个字段 SELECT 字段1 [AS 别名1],字段2 [AS 别名2],… FROM 表名; 设置别名(显示在搜索结果的表头) SELECT DISTINCT 字段列表 FROM 表名; 显示查询到的非重复结果 条件查询 SELECT 字段列表 FROM 表名 WHERE 条件列表 条件类型： 比较运算 \u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;或!=表示不等于 所有数据类型适用（包括日期） BETWEEN … AND … 含最大最小值的范围 前小后大 数据有先后顺序 IN(…) 列表中的值 LIKE 占位符 模糊匹配 _表示单字符 %表示任意个字符 IS NULL 或 IS NOT NULL 逻辑运算 AND 或 \u0026amp;\u0026amp; OR 或 || NOT 或 ! 聚合函数\u0026amp;分组查询 SELECT 聚合函数(字段列表) FROM 表名;\n常见聚合函数： 函数 功能 count 统计数量 max 最大 min 最小 avg 平均 sum 求和 SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\n“字段列表”可以写聚合函数\u0026amp;搜索的字段名（可显示表头） 执行顺序：WHERE\u0026gt;聚合函数\u0026gt;HAVING 聚合函数(某) 别名 起别名方法 聚合函数多半可以直接写为 SUM(\\*) 排序查询 SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;\n排序方式： ASC 升序(默认) DESC 降序 字段1，字段2有先后顺序 分页查询 SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;\n起始索引从0开始，为查询页的起始id\n第一页可以写为 LIMIT 查询记录数 顺序 编写顺序： SELECT$\\rightarrow$FROM$\\rightarrow$WHERE$\\rightarrow$GROUP BY$\\rightarrow$HAVING$\\rightarrow$ORDER BY$\\rightarrow$LIMIT DCL 管理用户 USE mysql SELECT * FROM user 查询用户 CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 创建用户 主机名为 % 表示可在任意主机访问 ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 修改密码 DROP USER '用户名'@'主机名'; 删除用户 权限控制 常用权限类型： 权限 说明 ALL(PRIVILEGES) 所有权限 SELECT 查询 INSERT 插入 UPDATE 修改 DELETE 删除 ALTER 修改表 DROP 删除库/表/视图 CREATE 创建库/表 SHOW GRANTS FOR '用户名'@'主机名'; 查询权限 GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 授予权限 权限列表写 ALL 作通配 REVOKE 权限列表 ON 数据库名.表名FROM '用户名'@'主机名'; 撤销权限 数据库、表用\\*作通配 函数 使用 SELECT 函数 进行函数试验\n字符串函数 常用函数：\n函数 功能 CONCAT(S1,S2,…,Sn) 拼接字符串 LOWER(str) 全小写 UPPER(str) 全大写 LPAD(str,n,pad) pad从左填充str到n长度 RPAD(str,n,pad) pad从右填充str到n长度 TRIM(str) 去头尾空格 SUBSTRING(str,start,len) 返回str从start处起的len个字符 字符串从1开始 非0 主要结合前文语法进行应用 数值函数 常见函数：\n函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) x/y的模 RAND() 0~1内随机数 ROUND(x,y) x四舍五入 y位小数 日期函数 常见函数：\n函数 功能 CURDATE() 当前日期 CURTIME() 当前时间 NOW() 当前日期与时间 YEAR(date) 获得date的年份 MONTH(date) date的月份 DAY(date) date的日 DATE_ADD(date,INTERVAL expr type) date加上时间间隔expr后的时间 DATEDIFF(date1,date2) date1到date2的天数 DATE_ADD 中 expr 可为数字 type可为 DAY 流程控制函数 常用函数：\n函数 功能 IF(v,t,f) v为true返回t 否之为f IFNULL(value1,value2) v1不为空则返回v1 否之为v2 CASE WHEN [val1] THEN [res1] … ELSE [default] END v1真则返回res1 否之为d CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END expr等于v1返回res1 否之为d val1处不能并列多个val 用此类函数做筛选不用加where，格式为：==SELECT \\*,(CASE …) AS '别名' FROM 表名== 约束 约束概述 目的：保证数据库中数据的正确有效与完整\n约束分类 约束 描述 关键字 非空约束 该字段数据不为null NOT NULL 唯一约束 该字段所有数据不重复 UNIQUE 主键约束 一行数据的唯一标识 非空且唯一 PRIMARY KEY 默认约束 未指定则采用默认值 DEFAULT 某 检查约束 保证字段满足某条件 CHECK id int PRIMARY KEY AUTO_INCREMENT主键且自动增长(多个约束用空格隔开) 作用于表中字段 创建/修改表时添加 一般把序号设为主键 外键约束 让两表数据建立连接 保证数据完整一致\n具有外键的表=子表 被关联的表=亲表\n格式：\n创建时添加 [CONSTRAINT] [外键名] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) 修改时添加 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) 外键名是给外键自定义的新名字 注意数据类型需完全相同 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 删除外键\n[ON UPDATE 模式 ON DELETE 模式] 在添加语句后指定删除/更新模式\n模式 说明 NO ACTION 有外键则不允许更新 RESTRICT 同上 CASCADE 亲子表同时更新 SET NULL 亲表删除 子表设null SET DEFAULT 子表设为默认(Innodb不支持) 多表查询 多表关系 一对多：建立外键连接 eg.员工\u0026amp;部门 多对多：建立第三表 至少包含两外键 分别关联两方主键 eg.学生\u0026amp;课程 一对一：任意一方加外键 并设置为UNIQUE 多用于单表拆分 基础字段在一表 详情字段在另一表 UNIQUE 在定义id的时候添加 eg.用户\u0026amp;用户详情 多表查询概述 并列多表时需要消除无效的笛卡尔积情况(指A*B) 分类： flowchart LR; test((连接查询)) test--\u0026gt;内连接 test--\u0026gt;外连接 test--\u0026gt;自连接 多表查询--\u0026gt;test 多表查询--\u0026gt;子查询 外连接--\u0026gt;左外连接 外连接--\u0026gt;右外连接 内连接 返回A B表的交集\nSELECT 字段列表 FROM 表1,表2 WHERE 条件 …; 隐式内连接 条件类似employee.dept_id=dept\\.id SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件 …; 显式内连接 外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 …; 左外连接 查询左表与交集部分的数据 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 …; 左外连接 右表\u0026amp;交集 自连接 SELECT 字段列表 FROM 表1 别名1 JOIN 表1 别名2 ON 条件 …; 可内连接也可外连接 联合查询 SELECT 字段列表 FROM 表1 … UNION [ALL] SELECT 字段列表 FROM 表2 …; 有ALL结果直接合并 无ALL去重 字段列表与类型相同 子查询（嵌套查询） 外部可以是INSERT/UPDATE/DELETE/SELECT 根据子查询结果的不同分类： 名称 意义 标量子查询 结果为单个值 列子查询 结果为一列 行子查询 为一行 表子查询 多行多列 可在WHERE/FROM/SELECT之后进行 列子查询 返回一列结果 常用操作符： 操作符 用途 ==IN== 集合范围之内 多选一 NOT IN 不在集合范围内 ANY 任意一个满足 SOME 同ANY ALL 所有值都满足 行子查询 常用操作符 =、\u0026lt;\u0026gt;、IN、NOT IN 可以用 (1200,1)=(salary,manager) 表示一一对应 表子查询 常用操作符 IN 事务 操作 简介：一组操作的集合 整体提交 自动开始 SELECT @@AUTOCOMMIT; 开始事务(自动提交) SELECT @@AUTOCOMMIT=0; …… COMMIT; 手动提交事务 ROLLBACK; 事务回滚 手动开始 START TRANSACTION; 开启事务 COMMIT; 提交事务 ROLLBACK; 回滚事务 特性 原子性 不可分割的最小操作单元 一致性 事务完成时所有数据保持一致状态 隔离性 数据库的隔离机制，事务进行不受外部并发操作影响 持久性 提交或回滚后，数据的改变是永久的 ==ACID模型== 并发事务问题 脏读 一个事务读到另一个事务未提交的数据 不可重复读 先后读取同一记录但数据不同 幻读 按条件查询数据，无对应数据行，但插入数据时发现该行数据已存在 事务隔离级别 分类： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED ✔ ✔ ✔ READ COMMITTED ✖ ✔ ✔ REPEATABLE READ(默认) ✖ ✖ ✔ SERIALIZABLE ✖ ✖ ✖ ORACLE默认READ COMMITTED 性能递减 安全性递增 SELECT @@TRANSACTION_ISOLATION; 查看事务隔离级别 SET [SESSION或GLOBAL] TRANSACTION ISOLATION LEVEL {隔离级别}; 设定隔离级别 SESSION为当前连接 GLOBAL为全局，不包含当前连接 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/mysql_base/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"基本概念\"\u003e基本概念\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cem\u003eRDBMS\u003c/em\u003e 关系型数据库\nbased on关系模型，多张二维表\u003cstrong\u003e相互连接\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003esql操作分类\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e分类\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e全称\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDDL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eData Definition Language\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e定义数据库、表、字段等\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDML\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eManipulation\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e对表中数据进行增删改\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDQL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eQuery\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e查询表的记录\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDCL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eControl\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e创建库用户 控制权限\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"启动与停止\"\u003e启动与停止\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003enet start mysql80\u003c/code\u003e \u0026amp; \u003ccode\u003enet stop mysql80\u003c/code\u003e\u003cbr\u003e\nMySql 开机自启，在cmd中可手动停止\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emysql -u root -p\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e-u\u003c/code\u003e 提示用户为 root，\u003ccode\u003e-p\u003c/code\u003e 提示将输入密码\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"sql\"\u003eSQL\u003c/h2\u003e\n\u003ch3 id=\"基本\"\u003e基本\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e以分号结尾，行数不论，空格与缩进不论\u003c/li\u003e\n\u003cli\u003e不区分大小写，关键字最好大写\u003c/li\u003e\n\u003cli\u003e\u0026ndash; 或 # 注释内容\n多行注释 /* 内容 */\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"ddl\"\u003eDDL\u003c/h3\u003e\n\u003ch4 id=\"ddl数据库操作\"\u003eDDL数据库操作\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSHOW DATABASES;\u003c/code\u003e\u003cbr\u003e\n查询所有数据库\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSELECT DATABASE();\u003c/code\u003e\u003cbr\u003e\n查询当前（是在哪个）数据库\u003c/li\u003e\n\u003cli\u003e创建数据库（括号内容可以不加 采用默认规则）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003echarset utf8mb4\u003c/code\u003e 设定为容纳4个字节的utf8\u003c/li\u003e\n\u003cli\u003e在\u003c!-- raw HTML omitted --\u003eDataGrip\u003c!-- raw HTML omitted --\u003e中可以使用\u003cem\u003eSCHEMA\u003c/em\u003e替代\u003cem\u003eDATABASE\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\u003ccode\u003eDROP DATABASE [IF EXISTS] 数据库名;\u003c/code\u003e\u003cbr\u003e\n删除数据库\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUSE 数据库名;\u003c/code\u003e\u003cbr\u003e\n使用数据库\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"ddl表操作\"\u003eDDL表操作\u003c/h4\u003e\n\u003ch5 id=\"查询\"\u003e查询\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSHOW TABLES;\u003c/code\u003e\u003cbr\u003e\n查询当前数据库所有表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDESC 表名\u003c/code\u003e\n查询表结构\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSHOW CREATE TABLE 表名\u003c/code\u003e\n查询指定表的建表语句\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"创建\"\u003e创建\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eCREATE TABLE 表名( 字段1 字段1类型[COMMENT '中文'], 字段2 字段2类型[COMMENT '……'], …… 字段3 字段3类型[COMMENT '……'] )[COMMENT '……'];\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e字段1 是表头名称，如name\u003c/li\u003e\n\u003cli\u003e字段1类型：\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数值类型\u003c/strong\u003e\ntinyint,smallint,mediumint,int-4字节,bigint,float,double\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etinyint unsigned\u003c/code\u003e表示无符号 即\u003cstrong\u003e正数范围\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e可指定\u003ccode\u003edouble(m,n)\u003c/code\u003e，m表示最长位数，n表示小数点后最长位数\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字符串\u003c/strong\u003e\nchar(指定长度),varchar(指定长度),\n\u003cul\u003e\n\u003cli\u003echar为定长字符串，varchar变长(会计算所需空间是否需要变化)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e日期\u003c/strong\u003e\ndate,time,datetime,year,timestamp(截至2038年)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"修改\"\u003e修改\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 ADD 字段名 字段类型 [COMMENT 注释] [约束];\u003c/code\u003e\n增加字段\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 MODIFY 字段名 新字段类型 [COMMENT 注释];\u003c/code\u003e\n修改字段类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段类型 [COMMENT 注释];\u003c/code\u003e\n修改字段名\u0026amp;字段类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 RENAME TO 新表名\u003c/code\u003e\n修改表名\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"删除\"\u003e删除\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 DROP 字段名;\u003c/code\u003e\n删除字段\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDROP TABLE [IF EXISTS] 表名;\u003c/code\u003e\n删除表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTRUNCATE TABLE 表名;\u003c/code\u003e\n删除并重新创建该表\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDataGrip中字段翻译为列\u003c/p\u003e","title":"MySql基础"},{"content":" 我叫Lulu 是一只矮脚小猫😼\n请收集柠檬助力我进化成Lululemon！ 请关注 Lulu 主人的 Youtube 和 ins 好吗好的 OK(*^▽^*) Thanks for your lemon(s)! 柠檬收集度：0/8848 我生活在韩国\n和 一个人类 小声告诉你 她叫 Claire 喔\n还有 十只猫猫 住在一起\n虽然我很可爱 可是矮脚猫有基因缺陷 请谨慎养宠!\n这就是我的世界 喜欢我的话就往下看看吧🥰\n我的人型抱枕🥰 Secret !\nlulu不是不喜欢 Claire 是她的食物和玩具太有吸引力了\nClaire 在 Youtube\n和 Instagram\n上发布我们的动态\n答应我 如果喜欢我们的话要去关注她\n认准 Claire _luvcat频道不迷路😋 Claire 是我们的管家！\n肾衰的TT姐姐 跟我一样折耳的ChuChu\nClaire 都带我们治病\n喜欢她🥰\n舔狗lulu😗 只是喜欢的真情流露\n盗窃小分队😋\n喜欢DD\nMoMo会长😗\n一口吃掉\n盗窃小分队Ⅱ\n也喜欢CoCo\n唯一的Queen——TT姐姐🤩\n勇敢lulu 不怕困难😼 lulu （和弟弟TOTO,DODO）是最 勇猛 的小猫😼\n因为基因 lulu可以 站 起来 lulu在看着你🥺\nClaire 在吃什么 可以给lulu尝一口吗\nlulu爱睡觉 lulu一天到晚睡觉\n属于折耳猫的病痛 短粗的尾巴 畸形的耳朵\n是 折耳 基因的影响😢\n软骨发育不全会带来 痛苦\n所以请不要养折耳猫！\nTo Be Continued\n","permalink":"https://Sattiluvcat.github.io/en/lulu/","summary":"lulu","title":"Lulu的一切"},{"content":" 一直很想在互联网上拥有属于自己的空间😸\n记录一些关于自己和最喜欢的小猫——Lulu！的故事\n🥰🥰\n喜欢电影和文字 如有同好请通过博文评论区跟我交流🎃🎉\n","permalink":"https://Sattiluvcat.github.io/en/about/","summary":"about","title":"关于我"}]