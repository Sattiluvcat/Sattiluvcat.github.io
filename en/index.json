[{"content":" 巴黎夜旅人 最喜欢的还是甘斯布迎着风披着夜色回家的片段 离婚之后她需要自己谋生，被迫走出依附别人的境地，但又怎么不算幸事？\n她在夜间电台刚刚找到工作，人生明明还在谷底，但是从这个瞬间开始一切都变得有希望 凌晨的风吹乱了她的风衣，但也不会再有什么影响 整部电影有一种复古又柔和的氛围，甘斯布独立自主自力更生的part感觉格外动容（大概因为当时对其它的背景也不是很熟悉… 其实看这部的时候还没听说过《圆月映花都》《德州巴黎》一众电影，只是完全被这种复古的情调冲击，之后开始慢慢补上其它的，但是那种冲击的感觉也很少出现了\n春天不是读书天 很喜欢这种自由又热烈的青春感觉，可能是因为自己从没有这么自由热烈过…当然也只是自己的原因\n\u0026ldquo;Life moves pretty fast.If you don\u0026rsquo;t stop and look around once in a while, you could miss it\u0026rdquo;\nLet\u0026rsquo;s look around✨\n落水狗 单纯是喜欢这种痛快以及很有趣的人心变换\n昆汀的电影都挺喜欢的，就算是饱受诟病的《子弹列车》其实也能看下去，看电影不就看一个感觉么？\n午夜狂奔 又是中国人民的老朋友罗伯特·德尼罗！ 很搞笑的一部，节奏非常好的公路片 德尼罗放会计走的时候，会计脸上的灰和憨厚的笑实在令人忍俊不禁（什么\n冬天的故事 来自又一位比较喜欢的导演——侯麦，应该是春夏秋冬四部曲，但实在欣赏不来其它的某些情节\n充斥着有点空洞又非常可爱的对白，节奏慢慢的，女主角看起来很有灵气 在很嘈杂的环境下看完，感觉格外清爽，侯麦的电影于我而言都是这样，虽然故事背景都是各种关系纠缠，但是很难注意到这种情感上的混乱\n","permalink":"https://Sattiluvcat.github.io/en/posts/hobbies/%E7%94%B5%E5%BD%B1top5/","summary":"喜欢电影📺","title":"个人电影Top5"},{"content":" 基础 概念 集合 并发 虚拟机 ","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--java/","summary":"Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding","title":"八股 Java"},{"content":" Spring 概述 Spring框架核心特性： IOC（控制反转 Inversion of Control）容器：实现了对象的创建和对象间的依赖关系管理 AOP（面向切面编程 Aspect-Oriented Programming）：允许开发者定义横切关注点，独立于业务逻辑代码 事务管理：提供了一致的事务管理接口，支持声明式和编程式事务 声明式：注解 \u0026amp; 编程式：自行实现代码 MVC框架：基于Servlet API构建的Web框架，采用模型-视图-控制器（MVC）架构 支持URL到页面控制器的映射与多种视图技术 IOC \u0026amp; AOP IOC与AOP简述： 区别： IOC：一种创建和获取对象的技术思想，可以通过依赖注入（DI）实现。不需new对象，而是由IOC容器来实例化对象，可降低对象间的耦合度 AOP：能够将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，以减少系统重复代码，降低模块间的耦合度 Spring AOP基于动态代理，若需代理的对象实现了某接口，则使用JDK proxy创建代理对象；若没实现接口（不能用proxy），则用Cglib生成一个被代理对象的子类作为代理 IOC 和 AOP 结合使用，可以更好地实现代码的模块化和分层管理 eg. IOC 容器管理对象的依赖关系，AOP 将横切关注点统一切入到需要的业务逻辑中 eg. IOC 容器管理 Service 层和 DAO 层（Data Access Object）的依赖关系，AOP 在 Service 层实现事务管理、日志记录等横切功能 AOP详述： 背景：在 OOP（面向对象编程） 中最小的单元就是“Class 对象”，AOP中最小的单元是“切面”（一个“切面”可以包含很多种类型和对象，对它们进行模块化管理） AOP中功能分为核心业务 \u0026amp; 周边功能（eg. 日志 事务 权限） 作用：将与业务无关，却为业务模块所共同调用的逻辑封装，减少系统的重复代码，降低模块耦合度，利于未来的可拓展性与可维护性 AOP中的一些概念： Spring AOP基于JDK动态代理 / Cglib实现，均属于运行的方式，不通过编译\u0026ndash;\u0026gt;Spring通过java代码实现 IOC 通过什么机制实现？ 反射：利用Java的**反射机制动态地加载类**、创建对象实例、调用对象方法 依赖注入：（核心）容器负责管理（应用程序）组件间的依赖关系—\u0026gt;通过配置文件或注解描述依赖关系 设计模式—工厂模式：容器通常采用工厂模式来管理对象的创建与生命周期 容器：（实现IOC的核心）通常用BeanFactory（基本）或ApplicationContext（企业级）管理Bean。 AOP 通过什么机制实现（原理）？ **动态代理**技术—\u0026gt;运行时动态生成代理对象，而非编译时（允许在运行时指定要代理的接口和行为，不修改源码而增强功能） 基于JDK的动态代理——java.lang.reflect.Proxy类与java.lang.reflect.InvocationHandler接口实现。需要代理类实现接口 基于接口的代理 基于CGLIB的动态代理——被代理的类没有实现接口时，使用CGLIB库生成一个被代理类的子类作为代理 基于类的代理 动态代理与静态代理的区别：静态代理由coder（或特殊工具）创建，通常只代理一个类；动态代理运用反射机制动态生成，代理一个接口下的多个类 代理是一种常用的设计模式，如在创建一个类对象前后添加业务逻辑，这个过程在代理类中实现（调用代理类） 怎么理解SpringIOC？ Inversion Of Control，即控制反转，一种设计思想。 传统对象创建：new ，依赖关系（如Student的Score，需要手动指定依赖） IOC：根据配置加载并实例化Bean，保存到IOC容器中—\u0026gt;ApplicationContext.getBean(Student.class); 控制：对象的创建、初始化、销毁—\u0026gt;new到Spring容器创建、setter到容器自动注入、赋值null或销毁到Spring管理生命周期 反转：反转对象的控制权（从coder到IOC容器） 依赖倒置、依赖注入、控制反转是什么？ 控制反转：反转控制权（详见上），从coder到框架控制程序执行流程 依赖注入：一个具体的编码技巧。（详见上）不通过new，而是外部创建依赖的类对象，通过构造函数，函数参数等方式注入给类使用 依赖倒置：指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象（具体实现细节依赖对象，抽象不依赖细节） 设计一个IOC，考虑哪些问题？ Bean的生命周期管理 依赖注入功能（考虑通过反射与XML配置文件实现） Bean的作用域，如单例、原型、会话、请求等（考虑Map实现） AOP功能实现（考虑动态代理机制与切面编程实现） 异常处理，如Bean创建异常，依赖注入异常等（考虑try-catch） 配置文件加载，从不同配置文件中加载Bean的相关信息（考虑XML、注解或Java配置类实现） AOP主要想解决什么问题？ 对OOP思维的补充，非侵入性的功能增强（如日志） 具体实现：在Aspect中定义增强Advice，包含具体实现，整理切入点（粒度是方法），最后织入到对象的方法中 AOP实现有哪些注解？ @Aspect 定义切面，标注在切面类上 @Pointcut 定义切点，标注在方法上，指定连接点 @Before 方法执行前执行通知，通用的是@Advice 什么是反射及其使用场景 反射特性： 运行时可访问类信息—\u0026gt;可获取类的完整结构信息，包括类名、包名、父类等 动态对象创建—\u0026gt; 可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。通过Class 或 Constructor 对象的 newInstance() 方法实现 动态方法调用—\u0026gt; 运行时可以动态地调用对象的方法，包括私有方法 访问与修改字段值—\u0026gt; 允许程序在运行时访问和修改对象的字段值，包括私有字段 运用场景：依赖注入（如Autowired）与控制反转 + 动态代理的实现（如AOP） Bean Bean的生命周期？ Spring启动时，查找并加载需要被Spring管理的Bean并实例化 Bean实例化后将对Bean的引入和值注入到Bean的属性中 若实现BeanNameAware接口，将Bean的Id传给setBeanName()方法 / 若实现BeanFactoryAware接口，将BeanFactory容器实例传入 / 若实现ApplicationContextAware接口，将Bean上下文引用传入 / 若实现BeanPostProcessor接口，调用postProcessBeforeInitialization()方法 / … Bean准备就绪，驻留在应用上下文中，直到上下文被销毁 若实现DisposableBean接口，调用其destroy()接口方法；若Bean使用destory-method声明销毁方法，则调用该方法 Bean是否单例？ 默认单例，可设置scope为prototype实现多例 Bean生命周期在单例和非单例一样吗？ 否。Bean生命周期由IOC容器控制，Spring只管理单例Bean的完整生命周期，多例的Bean在Spring创建好后不再管理生命周期 Bean的作用域有哪些？ Singleton：（对于一个类）整个应用程序中只有一个Bean实例，在整个生命周期中共享该实例 Prototype：每次请求都创建一个新Bean Request：每个HTTP请求都创建一个新实例 Session：Session范围内只创建一个实例，仅在Spring Web中程序中有效 Application：当前ServletContext中只有一个Bean实例，仅在Spring Web中程序中有效 WebSocket：Web套接字中只存在一个Bean实例 Custom scopes：开发者自定 Spring容器中存什么？ 主要存储Bean对象。根据配置文件或注解方式创建、管理Bean对象 在Bean加载/销毁前后，怎么实现某些逻辑呢？ 使用Spring的生命周期回调接口或注解： XML配置中指定init- method和destroy- method属性，后在Bean类中实现 Bean类实现InitializingBean和DisposableBean接口，并分别实现afterPropertiesSet与destroy方法 Bean类中定义带@PostConstruct和@PreDestory注解的方法 @Bean注解的init- method和destroy- method属性 Bean注入和XML注入效果相同，底层如何？ XML注入：Bean定义解析（读取\u0026lt;bean\u0026gt;标签获取Bean定义信息） —\u0026gt; 注册Bean（如注册到BeanDefinitionRegistry） —\u0026gt; 实例化和依赖注入（通过反射创建Bean实例，后根据Bean定义中的配置，通过setter、构造函数注入需要的依赖Bean） 注解注入：类路径扫描（@Component、@Service、@Repository、@Controller注解的类） —\u0026gt; 注册Bean定义 —\u0026gt; 依赖注入（检查字段上是否有@Autowired、@Inject、@Resource注解，若有则根据注解注入） 底层相似性：BeanDefinition（最终都会生成BeanDefinition对象） + 后处理器（如AutowiredAnnotationBeanPostProcessor处理Autowired注解的依赖注入 \u0026amp; XML也有） + 依赖查找（通过BeanFactory查找和注入依赖 MVC 介绍 一种软件设计规范，业务逻辑、数据、界面显示分离的方法组织代码 Model：代表一个存取数据的对象或 JAVA POJO（Plain Old Java Object，简单java对象）。它也可以带有逻辑，主要用于承载数据，并对用户提交请求进行计算的模块。模型分为两类，一类称为数据承载Bean，一类称为业务处理Bean。所谓数据承载 Bean是指实体类（如：User类），专门为用户承载业务数据的；而业务处理 Bean 则是指Service 或 Dao 对象， 专门用于处理用户提交请求的 View：用户直接交互的使用界面 Controller：将用户请求转发到相应的model，根据model的计算结果向用户提供响应，分离视图与模型 基本流程：用户从View页面提出请求，服务端Controller接收请求后解析，找到对应Model，Model处理后结果交给Controller（承上启下），根据结果找到要发回的响应View页面，渲染后发回客户端 具体流程？详见 HandlerMapping和HandlerAdapter mapping：将请求映射到Controller。BeanNameUrlHandlerMapping等可实现。根据URL、请求参数等规则确定对应的处理器 adapter：调用Controller处理请求。根据Controller类型选择合适方法调用。根据Controller接口类型，选择对应的HandlerAdapter调用它 三级缓存 Spring 如何解决循环依赖？ 循环依赖的三种情况：\n构造方法进行依赖注入时产生，如：（无法解决，因为发生在Bean实例化阶段，未创建早期对象，无法放入三级缓存） @Component public class BeanA { private BeanB beanB; @Autowired public BeanA(BeanB beanB) { this.beanB = beanB; } } @Component public class BeanB { private BeanA beanA; @Autowired public BeanB(BeanA beanA) { this.beanA = beanA; } } setter方法进行依赖注入时产生 \u0026amp; 多例（原型）模式（作用域Scope指定为Prototype） 多例（原型）：（如并发场景）在原型作用域下，每次请求都创建一个新实例，一般在请求结束后销毁 不会导致初始化失败，但每次请求都会创建很多实例—\u0026gt;性能问题 @Component @Scope(\u0026#34;prototype\u0026#34;) public class BeanA { private BeanB beanB; @Autowired public void setBeanB(BeanB beanB) { this.beanB = beanB; } } setter方法进行依赖注入时产生 \u0026amp; 单例模式（被解决） 解决方法：三级缓存—\u0026gt;Spring创建Bean时，通过三级缓存缓存正在创建的Bean与创建完成的Bean实例。步骤：\n实例化Bean：创建Bean的实例 属性注入：赋值时如果发现循环依赖，将当前Bean对象提前暴露给后续需要依赖的Bean（通过提前暴露解决），将其的工厂对象放入三级缓存 初始化Bean：完成属性赋值后，将 Bean 进行初始化并放入一级缓存，清空二三级缓存 注入依赖：继续对Bean进行依赖注入，发现循环依赖时从三级缓存中获取工厂对象 整过程例：Spring先创建A的实例，并将A的工厂对象放入三级缓存。当创建B时，B会尝试从缓存中获取A。由于A还未完全创建好，B会从三级缓存中获取A的工厂对象，并通过工厂对象获取A的早期引用。这个早期引用是A的半成品（并放入二级缓存中），但已足够B使用。随后，B完成创建（并清空 其 二三级缓存，且二级空）并返回给A，A继续其初始化过程，最后清空 其 二三级缓存，且三级空 三级缓存的数据结构是？ Map 一级缓存（singletonObjects）：存放完全初始化的Bean，可直接使用 二级缓存（earlySingletonObjects）：存放属性未完全注入的半成品Bean 三级缓存（singletonFactories）：存放Bean的工厂对象，用于生成Bean的早期引用 Spring框架用到哪些设计模式？（以下省略“模式”二字） 工厂设计模式：创建Bean对象 代理设计：AOP功能的实现 单例设计：Bean默认为单例 模版方法：以Template结尾的对数据库操作的类（eg.MongoTemplate） 包装器设计： 观察者：Spring的事件驱动模型 适配器：AOP的增强或Advice、MVC用到适配器模式以适配Controller 事务 事务什么情况下失效？@Transactional 开启事务情况 未捕获异常 非受检异常：RuntimeException或其子类 事务传播属性设置不当：事务嵌套且配置不正确，注意方法内调用具有该注解的方法 多数据源的事务管理：多数据源，事务管理配置不当/存在多个事务注解 跨方法调用事务问题：如果一个事务方法内部调用另一个方法，而这个被调用的方法没有 @Transactional 注解，此时外层事务可能失效 事务在非公开方法中失效：注解标注在非public方法上 使用this调用Spring事务是否生效？ 否。Spring事务通过代理对象控制，this 调用会绕过代理机制，不会应用事务设置 其它 Spring拓展点？ BeanFactoryPostProcessor：实例化Bean前修改Bean定义 BeanPostProcessor：Bean实例化、配置与初始化之后进行额外处理 Spring MVC中的HandlerInterceptor：拦截处理请求，在请求前、中、后执行特定逻辑 Spring MVC中的ControllerAdvice：全局处理控制器异常、数据绑定与数据校验 自定义注解：权限控制 日志记录等功能 SpringBoot ","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--spring/","summary":"Spring - SpringBoot - Mybatis - SpringCloud（简略），内容来自小林coding","title":"八股  Spring"},{"content":" 数据库构建 数据信息 主要组成：来源于所有看过的 520部 影片，包括电影名、主要演员、导演、评分、类型、语言、初次上映时间等内容 评分包括我的评分与豆瓣评分，优先写我的😤 数据来源与处理方式 Python爬虫，在“我看过的”页面进行抓取 发现豆瓣的upload_auth_token真的没变过，太神奇了··· 挂了学校 VPN 会有登录异常，太神奇了··· response = requests.get(url, headers=header) soup = BeautifulSoup(response.text, \u0026#39;html.parser\u0026#39;) # 根据F12网页结构逐条获取信息 定位到最近的一个div即可 for item in soup.select(\u0026#39;div.item.comment-item\u0026#39;): title = item.select_one(\u0026#39;div.info li.title a em\u0026#39;).text.strip() link = item.select_one(\u0026#39;div.info li.title a\u0026#39;).get(\u0026#39;href\u0026#39;) # 综合信息 comp_load = item.select_one(\u0026#39;div.info li.intro\u0026#39;).text.strip() movies.append({\u0026#39;title\u0026#39;: title, \u0026#39;link\u0026#39;: link}) 结合正则表达式对以上提到的信息进行提取，以下只贴导演、时长与类型参数的获取方式 演员名的正则表达式：r'[\\u4e00-\\u9fa5·]+(?:\\s[\\u4e00-\\u9fa5·]+)*'，即通过/分隔的中文Unicode字符 导演这里有一点小问题，一般来说应该是国家、网址之后写导演名字，此处通过翻译后比较是否是国家或者是否非中文来隔断。 因为pycountry只能处理英文来着··· 只取了第一位导演 考虑到其实并不太重要so··· 某些短片直接粗暴处理了 于我而言并无区别 duration_match = re.search(r\u0026#39;\\d+分钟\u0026#39;, info) # 选择第一个时长 duration = None director = None tags = [] if duration_match: duration = duration_match.group(0) # 匹配导演--\u0026gt;最后一个中文名 text_before_duration = info[:duration_match.start()] # 以斜杠为标志，分割导演 director_match = re.findall(r\u0026#39;[\\u4e00-\\u9fa5·]+(?:\\s[\\u4e00-\\u9fa5·]+)*\u0026#39;, text_before_duration) if director_match: director = director_match[-1] # 匹配标签 text_after_duration = info[duration_match.end():] slash_index = text_after_duration.find(\u0026#39;/\u0026#39;) if slash_index != -1: after_name_slash_index = text_after_duration.find(\u0026#39;/\u0026#39;, slash_index + 1) text_after_movie_name = text_after_duration[after_name_slash_index + 1:] for tag in text_after_movie_name.split(\u0026#39;/\u0026#39;): tag = tag.strip() if tag in tag_list: tags.append(tag) else: break return director, duration, tags 存储到MongoDB库 大多为文本数据，所以不选择MySQL方法，后续可能会在用户登录等方面使用MySQL，但文本数据更适合MongoDB 最好添加_id信息（避免后期增加id，会被自动认成主键，在前端调取信息时也很麻烦） 访问某些网站时错误报404，建议从浏览器访问一次，复制cookie到请求中即可 MongoDB存储与读取 保存为json格式即可 java中通过@Document(collection = \u0026quot;movies\u0026quot;)注解引入MongoDB数据库 后端Java 基本框架 主体模式： 用户进入\u0026ndash;\u0026gt;还是强制登录了 模糊搜索 tags搜索 查看全部 点击缩略图，调用{id}接口，跳转页面 搜索结果为PageResult，其中数据是List\u0026lt;MovieRow\u0026gt; （需要记录用户昵称等信息）一起看点击后向指定邮箱发消息 （需要记录用户昵称等信息）个人评分指定后向指定邮箱发消息 登入登出： 用ThreadLocal有点小问题，最后用了Session，监听到页面被关闭即调用登出功能 查看全部电影功能 过程 特殊功能 发送邮件： 其实也可以直接向后端传消息，但是不喜欢。 本来想实现的也是可以直接在微信端推送的功能（就是为了这盘醋包的饺子！），邮箱跟微信绑定一下又曲线救国了（不是 引入依赖\u0026ndash;\u0026gt;配置mail\u0026ndash;\u0026gt;添加邮箱服务类 即可 处理问题 中文编码不能出现在地址里\u0026ndash;\u0026gt;URLEncoder \u0026amp; URLDecoder编码解码即可 让我们说中文 Let us speak Chinese🤐 这部分问题主要是后端用http发送请求调试时出现，前后端联调情况下并不影响 bug合集 common模块的Result类通过在server模块的pom.xml文件中添加快照依赖dependency--\u0026gt;SNAPSHOT实现在server模块的调用 每个类设置自动填充getter \u0026amp; setter信息需要的注解： @Data @Builder @AllArgsConstructor @NoArgsConstructor Mysql数据库配置的druid需要根据maven的版本改变依赖的版本 如 SpringBoot3 对应 alibaba.druid 2.x 即可（太古早的版本会导致无法读到MySQL的url） MongoDB自设主键_id，默认方法中的getById即指该主键，若需按自定义id搜索，需要换用MongoTemplate 调用Python文件过程： ProcessBuilder对象调用\u0026ndash;\u0026gt;可以输入参数 接收到的是输出流（即print部分） 之前一直调用失败，最后在ProcessBuilder对象中添加了解释器路径就好使了 其实这里是模拟命令行，python3在命令行中不能用python，需要py调用来着 邮箱服务类中需配置发信地址，在邮箱服务类中定义发信方法时添加：message.setFrom(from); 避免501 Mail from address must be same as authorization user报错 @Value(\u0026#34;${spring.mail.username}\u0026#34;) // 此处引用的是配置文件中的信息 private String from; Postman发送请求报错：Error: connect ECONNREFUSED balabal 关闭系统代理，自行设置代理到端口127.0.0.1:8080 Java调用Python脚本得到的中文信息，Python中默认使用cp936字符集，即gb2312。故在Java中需要显式指定用gb2312字符接收 此处更改Python的encode decode无效 BufferedReader in = new BufferedReader(new InputStreamReader(process.getInputStream(), \u0026#34;gb2312\u0026#34;)); 代理 nginx从前端8888端口反向代理到后端8080端口 实际用不上 Vue自己设置一下即可（毕竟本地随便跑跑 不太用考虑安全性 负载均衡等 后端配置类以接受前端调用：WebConfig @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) // !! 填前端地址 .allowedOrigins(\u0026#34;http://localhost:8889\u0026#34;) .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) .allowCredentials(true) .allowedHeaders(\u0026#34;*\u0026#34;); } } bug合集 WebConfig配置类，origin是前端地址 注意前端返回后端接收的格式 在前端的页面之间传递参数时需要使用Vuex 接收参数端： export default { computed: { ...mapGetters([\u0026#39;getMovies\u0026#39;]), movies() { return this.getMovies; } } } 发送参数端： this.updateMovies(movies); // 不用异步等待 this.$router.push({ name: \u0026#39;SearchResults\u0026#39;}); 从前端开发者工具调试，注意提取的内容层级关系 前端Vue 大致形式 主要流程： 用户访问\u0026ndash;\u0026gt;首页\u0026ndash;\u0026gt;设置搜索栏与按类别搜索入口 \u0026amp; 下列4~5个电影缩略图 电影缩略图\u0026ndash;\u0026gt;点击进入电影详情页 电影详情页P1\u0026ndash;\u0026gt;上列电影详情（包括实时从豆瓣电影爬下来的海报与评分） 电影详情页P2\u0026ndash;\u0026gt;下列“一起看”与评分功能\u0026ndash;\u0026gt;多人评分计算平均分在右侧显示 搜索\u0026ndash;\u0026gt;搜索结果以缩略图形式显示，分页结果 操作 npm命令行操作 完全没接触过vue…全是靠copilot教 感谢副驾♥ 前后端联调——F12开发者模式 后端向邮箱发送请求是通过Session（即Cookie），需要在前端开启配置axios.defaults.withCredentials = true; 从localhost访问网页图片：\u0026lt;img referrerpolicy=\u0026quot;no-referrer\u0026quot; :src=\u0026quot;cover_url\u0026quot; alt=\u0026quot;Movie Cover\u0026quot; class=\u0026quot;movie-cover\u0026quot; /\u0026gt; 重点是设定referrerpolicy 前端实现分页 本来是后端实现的，但是交互太麻烦，功能也不复杂（以及是在本地跑的），最后还是用前端实现完了 坏处是不能从url跳转页面 totalPages() { return Math.ceil(this.movies.length / this.itemsPerPage); }, paginatedMovies() { const start = (this.currentPage - 1) * this.itemsPerPage; const end = start + this.itemsPerPage; return this.movies.slice(start, end); }, paginationPages() { const pages = []; if (this.totalPages \u0026lt;= 5) { for (let i = 1; i \u0026lt;= this.totalPages; i++) { pages.push(i); } } else { if (this.currentPage \u0026gt; 3) { pages.push(1); pages.push(\u0026#39;...\u0026#39;); } for (let i = Math.max(1, this.currentPage - 2); i \u0026lt;= Math.min(this.totalPages, this.currentPage + 2); i++) { pages.push(i); } if (this.currentPage \u0026lt; this.totalPages - 2) { pages.push(\u0026#39;...\u0026#39;); pages.push(this.totalPages); } } return pages; } bug合集 api.js定义路径不用引号，而是反单引号 `： export const getSuggestedMovies = () =\u0026gt; { return axios.get(`${API_URL}/suggest`); }; 上线 不购买域名 此处仅使用ip访问\n流程 购买云服务器 云服务器中使用宝塔进行管理 修改项目配置——localhost更改 云数据库（MongoDB） 在MongoDB Atlas上直接用json格式导入数据 项目打包 部署 前后端分别打包 后端打个jar包（war包不包括Tomcat，修改依赖即可） 写在最后 一个小玩意，用了一些之前学到的和想接触的东西 跟自己另外很喜欢的东西做了一点结合与创造，这就是于我而言技术的意义 总之 🎊🎉🎊\n","permalink":"https://Sattiluvcat.github.io/en/posts/hobbies/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E7%94%B5%E5%BD%B1%E4%B9%8B%E5%A4%9C/","summary":"后端SpringBoot，前端Vue与MongoDB数据库","title":"从0开始的电影之夜"},{"content":" 以下部分算法参考VF-RRT* 原理 改进部分 新点的生成——随机点方向与当前位置向量场方向\n最优RRT路径——重复生成多条RRT路径后对每条路径计算上游系数的积分，选取能耗消耗最少的一条\n剪枝优化——比较剪枝与否得到的路径评分，判断是否进行剪枝（包括能耗影响、路径总转角、总长等）\nDWA优化——评分系统中引入上游系数\n生成新节点 确定方向向量：\n随机方向向量：计算从 ( q_{\\text{near}} ) 到 ( q_{\\text{rand}} ) 的方向向量 ( v_{\\text{rand}} )，并将其归一化为单位向量. 向量场方向向量：获取 ( q_{\\text{near}} ) 处的向量场方向 ( F )，并将其归一化为单位向量 ( v_{\\text{field}} ). 计算权重：确定向量场方向对随机方向的影响权重 ( w )。权重的计算方法如下：\n计算 ( v_{\\text{rand}} ) 和 ( v_{\\text{field}} ) 之间的夹角 ( \\theta_{\\text{rand}} ). 根据上游准则和指数分布的关系，计算新的夹角 ( \\theta_{\\text{new}} ). 使用正弦定理计算权重 ( w )： [ w = \\frac{|v_{\\text{rand}}| \\sin(\\theta_{\\text{rand}} - \\theta_{\\text{new}})}{|v_{\\text{field}}| \\sin(\\theta_{\\text{new}})} ] 确定新节点方向：根据权重 ( w )，计算新的方向向量 ( v_{\\text{new}} )： [ v_{\\text{new}} = \\frac{v_{\\text{rand}} + w v_{\\text{field}}}{|v_{\\text{rand}} + w v_{\\text{field}}|} ] 以上来自GPT总结。实际程序的权重计算中，简化了相关过程。 上游系数 根据柯西-施瓦茨不等式得到，上游系数是一个衡量能耗的指标，并非定量计算结果 $$ \\mathcal{U}(q)=\\int_0^L(|F(q(s))|-\\langle F(q(s)), \\dot{q}(s)\\rangle) d s $$ 评分标准 主要考虑能耗水平、路径总长与累计转角等参数 实现 以下主要起到 demo 作用，有一些 TODO 尚未完成，并非最终版\n生成新节点\ndef vf_generate_new_node(nearest_node, random_node, extend_length, vector_field): # 获取最近节点到随机点的方向向量 direction_to_random = ··· # 获取最近节点处的向量场方向 u, v = get_vector_field(nearest_node.x, nearest_node.y, vector_field) direction_vector_field = np.array([u, v]) # TODO 方向选取的优化 # 两个方向向量的加权平均方向 average_direction_vector = (direction_to_random*4 + direction_vector_field) / 5 # 归一化平均方向向量 average_direction_vector /= np.linalg.norm(average_direction_vector) # 根据这个平均方向生成新节点 new_x = nearest_node.x + extend_length * average_direction_vector[0] new_y = nearest_node.y + extend_length * average_direction_vector[1] new_node = Node(new_x, new_y) new_node.parent = nearest_node return new_node 计算上游系数\ndef upstream_criterion(path, vector_field): total_difference = 0 for i in range(1, len(path)): # 当前位置的向量场 u, v = get_vector_field(path[i][0], path[i][1], vector_field) vector_field_magnitude = np.sqrt(u**2 + v**2) # 当前速度方向——路径求导 direction_path = np.gradient(np.array(path), axis=0)[i] path_magnitude = np.linalg.norm(direction_path) # 归一化速度方向 --\u0026gt; 需要，因为向量场本身已经归一化 --\u0026gt; 应用不等式时两者模长相等，均为1 direction_path /= path_magnitude # Cauchy-Schwarz 不等式: |a · b| \u0026lt;= ||a|| * ||b|| dot_product = np.dot(direction_path, direction_vector_field) # 👆归一化后直接取 1 即可 total_difference += ··· return total_difference 剪枝更新\ndef vf_prune_path(path, obs_list, vector_field): pruned_path = [path[0]] i = 0 while i \u0026lt; len(path) - 1: found = False for j in range(len(path) - 1, i, -1): # TODO 转角约束 if not check_collision(path[i], path[j], obs_list): # 现有优化路径+现在考虑的路径不剪枝形式，评分后比较 ··· pruned_path.append(path[j]) i = j found = True break if not found: i += 1 if pruned_path[-1] != path[-1]: pruned_path.append(path[-1]) return pruned_path 剪枝评分\ndef path_score(path, vector_field): total_difference = 0 total_angle = 0 # TODO 评分细则 for i in range(len(path) - 1): # 最大值是 len(path) - 2 u, v = get_vector_field(path[i][0], path[i][1], vector_field) direction_vector_field = np.arctan2(v, u) direction_path = np.arctan2(path[i + 1][1] - path[i][1], path[i + 1][0] - path[i][0]) total_difference += abs(direction_path - direction_vector_field) if i \u0026lt; len(path) - 2: angle = abs(np.arctan2(path[i + 2][1] - path[i + 1][1], path[i + 2][0] - path[i + 1][0]) - direction_path) total_angle += angle return total_difference + total_angle ","permalink":"https://Sattiluvcat.github.io/en/posts/else/vf-rrt/","summary":"将流场视为向量场的RRT算法","title":"VF-RRT"},{"content":" 数据库 基本 数据库 常见名词 元组——一条记录就是一个元组（一行） 码——唯一标识实体的属性（一列） 候选码——候选的可以唯一标识元组的码（且不包括多余属性——否则为超键） 主码——主键 外码——另外关系中的主码 主属性（可以当候选码的） 非主属性（不包含在任何候选码的属性） ER图——实体联系图 包括：实体 属性 联系（实体与实体间的关系） 形状：矩形 椭圆 菱形（一一对应） 范式：1NF（第一范式） 2NF 3NF 1NF:字段有原子性 数据不可再分（每格数据不可再分） 2NF：消除非主属性对码的部分函数依赖（= 完全依赖） 一张表中 X确定 Y必确定 = X\u0026ndash;\u0026gt;Y（Y函数依赖于X） X 的真子集 Xo\u0026ndash;\u0026gt;Y（Y 部分函数依赖于 X）——数据冗余 CUD 异常 CRUD create read update delete 完全依赖：(X,Y)\u0026ndash;\u0026gt;Z 但X Y单个都不可依赖 3NF:所有非主键属性间不能依赖 必相互独立 外键与级联： 级联更新\u0026amp;删除：更新/删除某主键 若其被其他表引用 则需更新/删除所有引用记录 delete vs drop vs truncate 用法：drop丢弃（table） truncate清空数据 id回到1 delete删除数据（行）id无影响 delete可以回滚 事务提交后生效（会产生日志） drop释放表空间 truncate不产生日志（不能回滚 NoSQL 与SQL的区别： 非结构化存储 vs 结构化存储（固定行和列） 通常不支持ACID vs ACID MongoDB支持 但有所区别 atom consistency isolation durability balabal vs 性能取决于磁盘子系统 优化查询 索引 表结构等获得最佳性能 横向拓展（基于分片机制——水平分割 以行为单位分割并分开存储） vs 垂直（读写分离 分库分表 ···） 特点：灵活 可拓展 高性能 类型：文档 键值 图形 宽列 字符集 utf8 utf8mb4\n字符集合 eg.ASCII UTF(Unicode) UTF-8 = 8比特UTF（一个字最多占3字节） UTF8mb4 = 一个字最多占据4字节的utf8 Mysql指定字符集优先级 server-数据库-表-字段column渐增 连接字符集：客户端与服务器沟通时相互翻译选择的字符集 JDBC（Java操控数据库的api）驱动会影响连接字符集 SQL database\u0026ndash;\u0026gt;table\u0026ndash;\u0026gt;schema(ok for table/db)\u0026ndash;\u0026gt;column\u0026ndash;\u0026gt;row\u0026ndash;\u0026gt;primary key\n注意：所有空格都被忽略 连接JOIN关键字 ON指定连接条件（最终生成临时表） left right关键词\u0026ndash;\u0026gt;即使右/左表没有满足条件的行也返回左/右表中的所有行 select something from table1 join table2 on table1.id=table2.id; 索引 事务 例题（窗口函数balabal略） MySql 基础 名词： 关系型数据库：基于关系模型的数据库 关系模型表明db中存储数据间的联系 SQL：结构化查询语言 字段 字段类型 数值 字符串 日期 DECIMAL vs FLOAT/DOUBLE \u0026ndash;\u0026gt; 避免精度损失 why：TEXT BLOB不建议？ 不常用：text ≈ 长文本的char varchar \u0026amp; bolb = 二进制大对象 缺点：不能有默认值 \u0026amp; 智能在磁盘上创建临时表 \u0026amp; 检索效率低 diff：NULL vs '' NULL代表一个不确定的值\u0026ndash;\u0026gt;不能用= != \u0026gt; \u0026lt;等运算符 \u0026amp; NULL=NULL ==\u0026gt; False 只能用is NULL / is not NULL查询 ''长度为0 不占用空间 vs NULL要占用空间 how：boolean类型？ tinyint类型\u0026ndash;\u0026gt;只能存储0 or 1 架构 what：执行sql语句的流程？ 连接器——身份认证\u0026amp;权限 查询缓存（mysql8.0后移除） 未命中后执行下述流程 分析器——检查语法··· 优化器——选择最优执行方案 执行器——执行前先判断有否权限 无权限则报错 有则从存储引擎返回数据 插件式存储引擎——数据的存储与读取 支持InnoDB MyIsam ··· 执行器与存储引擎交互 索引下推：MySql5.6 在联合索引遍历过程中，对联合索引中包含的字段先做判断 索引⭐⭐ 分类 数据结构 B+树——主键索引和二级索引默认 Hash Full-Text B+：每个节点存放按主键顺序的数据 叶子节点形成双向链表（下图来自(小林coding)[https://www.xiaolincoding.com/]） 索引与数据存储在磁盘 读取一个节点 = 进行一次磁盘I/O B树 = 没有双向链表的B+树 主键索引的树的叶子存放实际数据 二级索引的叶子存放主键值（虽然是按主键顺序 但表示还是按二级索引选用的物理量eg.学号 来表示） 二级索引查数据 = 二级索引树\u0026ndash;\u0026gt;主键树（此过程即为回表） B+优势： B+ vs B：B树非叶子节点也要存储数据（相同磁盘IO b+能查更多节点） 且没有双向链表（不能顺序查找） vs 二叉树：b+搜索复杂度$log_dN$ N个节点 每个节点最大子节点d个（一般大于100）——千万级对应3-4层 vs Hash：hash只适合等值查询 物理存储 聚簇索引（主键索引） 二级索引（辅助/非聚簇） 聚簇 = 主键：找到索引就找到了数据 有主键就是主键 无主键选第一个不含NULL的唯一列 也没有则InnoDB自创隐式自增ID列 非聚簇：用此索引不能找到数据（只找到主键） 需要回表查询 字段特性 主键索引 唯一索引（建立在UNIQUE字段上） 普通索引 前缀索引 前缀索引：针对字符类型字段的前几个字符建立 字段个数 单列索引 联合索引 联合索引：多个字段组合 eg.(product_no,name) 有先后顺序 联合索引的最左匹配：按最左优先的方式进行匹配 先找product_no 后找name 若某select只有name则该索引失效 联合索引的最左匹配遇到范围查询后失效 范围查询自身还有效 但若范围查询中有= 则还可以向后查询（准确来说用联合索引向后查的就只有=的情况） 联合索引最好把区分度大的放前面（distinct多的 如UUID） 在CS186中实现的是单列索引 键DataBox key 值（叶子节点）RecordId（唯一标识符） 也没有提前排序\n应用 缺点：占用物理空间（磁盘）+创建与维护耗时+降低增删改效率 适用索引的情况：UNIQUE字段 / 经常用于where/order by/group by的字段 不适用：大量重复/不怎么使用上述三种/表数据太少/经常更新的 优化方法：前缀索引优化 覆盖索引优化 主键索引最好是自增的 防止索引失效 前缀索引局限性：order by不能用（前缀后面的顺序不一定对） \u0026amp; 不能用作覆盖索引 覆盖索引：查询的所有字段，在B+的叶子节点上都能找到（不用回表） 主键索引最好自增——插入方便（主键字段不要太长 二级索引叶子节点可以更小） 可能索引失效的情况：（in后条件过多，导致优化器进行查询优化时需要的内存超过内存限制\u0026ndash;\u0026gt;全表扫描 可设置rangeoptimizermaxmemsize） like %·· 类似最左前缀（所以是左模糊/左右模糊时失效） 对索引列做了计算 函数 类型转换操作 联合索引的最左前缀 where中 若or前条件为索引列 or后不是 则失效：优化器在处理OR操作符时，通常会选择一种能够处理所有条件的执行计划 事务⭐⭐ 特性：ACID 特性：原子性（要么全部完成 要么全部不完成） 一致性（事务操作前后，数据满足完整性约束） 隔离性（允许多个并发事务同时对其数据进行读写和修改） 持久性（事务处理结束后，对数据的修改就是永久的） 实现：A——undo log I——MVCC/锁 D——redo log C——前者共同保证 CS186中并发采用锁机制 恢复采用ARIES模型（各种日志）\n隔离性 并行事务可能引发的问题： 不可重复读RR是针对普通查询而言的，对其它情况都用当前读。所以InnoDB中的RR只保证普通查询时前后两个数据一致，不保证select···for update与select一致\n脏读——事务B读到事务A修改了但未提交的数据（A可能回滚 B读到的就是过期数据） 不可重复读——事务A多次读同个数据 前后两次读到的数据不一样（对应修改行） 幻读——在一个事务内多次查询某个符合查询条件的「记录数量」 查询到的数量不同（对应增删行） 严重性：从上到下递减 隔离级别：从上至下递增（效率递减） 读未提交——可读到未提交的事务 读提交——只能读已提交的事务 可重复读——一个事务执行过程看到的数据保持不变（InnoDB默认级别） 串行化——加读写锁 读写冲突时 后访问的事务等前一个完成后才能执行 InnoDB可以很大程度上避免幻读 其（InnoDB）实现： 快照读通过MVCC实现 MVCC中包括Read View Read Voew能实现读提交与可重复读\n快照读（普通select语句）——MVCC 可重复读条件下 插入的数据无法查询 当前读（其它语句 如select ··· for update update时要获得最新的数据）——通过记录锁+间隙锁(next-key lock)解决 在二锁的范围内插入的数据被阻塞 无法成功插入 Read View in MVCC,how to work?通过版本链控制并发事务访问同个记录 = MVCC（多版本并发控制） ReadView四个字段： m_ids：当前数据库「活跃事务」（启动了未提交）的事务 id 列表 min_trx_id：「活跃事务」中事务 id 最小的事务 max_trx_id：创建RV时全局事务中最大的事务 id 值 + 1（RV没照到的事务） creator_trx_id：创建该 Read View 的事务的 id 聚簇索引的两个隐藏列： trx_id：当一个事务对某条聚簇索引记录进行改动时，把该事务的 id 记录在此处 roll_pointer：对聚簇索引记录改动时 把旧版本的记录写入undo log 此隐藏列作为指针指向该旧版本记录（so可以找到后恢复） 一个事务访问记录时：（自己的记录总是可见） trxId\u0026lt;min：该记录是（创建RV前）已提交事务生成的\u0026ndash;\u0026gt;可见 trxId\u0026gt;max：创建RV后的启动的事务\u0026ndash;\u0026gt;不可见 在min与max之间：属于m_ids = 未提交的事务\u0026ndash;\u0026gt;不可见 / 不属于 = 已提交的事务\u0026ndash;\u0026gt;可见 读提交\u0026amp;可重复读的实现：Read View（类似快照）「读提交」在「每个语句执行前」都生成 「可重复读」在「启动事务时」生成 explain：读提交在事务中也是每句都重新生成快照 B线程在期间更改数据也会被A线程快照到\u0026ndash;\u0026gt;事务中间数据会发生变化 CS186中实现的大概是串行化级别 一个线程（事务）添加X锁（排他锁）后 其它线程被加入阻塞队列 直到表上的X锁被释放\nMySql可重复读与幻读 记录锁+间隙锁可以防删除——主键索引被记录锁锁定 无法删除 间隙锁可以防插入\n不能防止幻读的例子： A事务先普通select（快照读） B事务插入数据并提交 A事务update插入的数据（当前读） A再次select\u0026ndash;\u0026gt;成功 A第一次select时并没有加锁 此时若A不update 直接select for update效果相同 解决：先做for update 事务提交时行级锁才会解除 锁⭐⭐⭐ 锁的分类 for all：SS兼容 SX不兼容 XX不兼容\n全局锁 + 表级锁 + 行级锁 全局锁：flush tables with read lock 主要用于全局逻辑备份 怎么又备份又不影响业务？在可重复读的级别下开启事务（MVCC支持） 表级锁 = 表锁 + 元数据锁（MDL） + 意向锁 + AUTO-INC锁 表锁：lock tables student read 其它线程不可写 该线程只可读此表（不能写 也不能操作其他表） MDL：对表进行CRUD = 加MDL读锁 对表做结构更改 = 写锁 事务提交时释放锁 why申请不到写锁 转而申请读锁也被阻塞？ 申请锁的请求形成队列 写锁优先级高于读锁（写锁等待时 该表的CRUD操作全部阻塞） 普通select不会加锁 用MVCC实现 但CS186中普通select是加了读锁的\n意向锁：IS IX 意向锁之间不会冲突 只与表锁冲突 用于判断表里是否有记录被加锁 AUTO-INC：掌管主键自增 插入完释放（避免其他事务同时插入 主键不连续自增） 轻量级锁（MySql5.1.22 ）为字段赋自增值后释放 不需等整个插入语句执行完 轻量级锁在主从复制时会出错（线程AB分别向表中插入记录 binlog记录原始语句 先记完A或B才能记别的 写入从库时重新insert 序号会变化） 设置binlog_format=row 解决（保留主库中序号） 行级锁： 记录锁：锁一条记录S or X 间隙锁范围：如update记录25 只有10 20 30 \u0026ndash;\u0026gt;锁住20~30\n间隙锁：只存在于可重复读（解决该级别幻读） + 锁不互斥（可以包含共同间隙范围） + 不包含边界 临键锁（二者结合）：包含边界 有互斥 插入意向锁：不是意向锁 插入的位置遇到间隙锁时生成 状态为等待 间隙锁释放后此锁开始作用 是一种特殊的间隙锁 类似于锁住一个点 MySql怎么加锁 串行化级别select语句会加锁\n加行级锁：索引加锁 基本单位next-key lock 事务提交后才释放 在使用记录锁或者间隙锁就能避免幻读现象的场景下会退化 分析加锁命令：select * from performance_schema.data_locks\\G;\n非唯一索引（主键+二级 非unique字段） 等值查询：两索引都加锁 但主键索引只对满足条件的索引加锁（查询结果存在 主键索引加记录锁 不存在则主键索引不加锁） 范围查询：二级索引不退化 若不加索引进行查询 = 全表扫描 = 每条记录的索引都加next-key lock = 全部锁住 死锁 由next-key lock造成\n两个线程select for update 都要插入\u0026ndash;\u0026gt;等对方间隙锁释放才可获取插入意向锁 避免死锁： 必要条件：互斥 占有且等待 不可强占用 循环等待 方法：设置等待锁的超时时间 / 开启主动死锁检测 日志⭐ why undo log？ 事务提交前有用\n保证原子性 可以回滚——记录每步操作 实现MVCC的关键因素——undo log的版本链为每条记录保存多份历史数据 why buffer pool? 作用：缓存数据 客户端可以直接读取 + 修改数据可以直接修改pool中的 并标记为脏页（与磁盘记录不一致） 缓存什么？以页为单位（16KB） CS186中 GHJ用作join两个大表 外部归并排序用作将一个大表（可能是join的结果）进行排序后存放到页上\n缓存数据页 索引页 undo页（记录undolog） 锁信息 自适应哈希索引插入缓存页 查询一条记录会把整页数据加载到pool why redo log? 过程：先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录\u0026ndash;\u0026gt;后台线程适时将脏页刷盘 先写日志后刷盘 == WAL 事务提交时 先持久化redolog undolog修改也要记录到redolog 作用：实现事务持久化 crash-safe + 写操作从随机写变为顺序写（redolog在磁盘中为追加操作 顺序写） redo自身是循环写 redo undo的区别：redo记录事务修改后状态 用于崩溃恢复；undo记录事务修改前状态 用于回滚 redolog与binlog的区别：（binlog原来是MyISAM中的 没有crash-safe能力 InnoDB实现了这个功能） binlog不记录查询语句 在每条更新语句后生成 事务提交时会把binlog统一写入binlog文件\nbin是server层实现的 redo是引擎实现的 redo是物理日志（记录做了什么修改如在·处做了·更新）bin有statement模式（只记录操作如update 逻辑日志）、row模式（记录数据如一行）、mixed（自动切换） bin是追加写 redo循环写 bin用于主从复制 备份恢复 redo用于故障恢复 主从复制实现？ 依赖binlog 记录mysql所有变化并以二进制形式保存在磁盘上 将其传到从库以实现复制（一般异步 主库不等复制） 二者建立联系 此后一直保持联系 binlog什么时候刷盘？ 事务执行过程中 先把日志写到binlog cache 提交时将其写入binlog 慢查询日志——记录执行时长超过阈值的查询语句 用途：需要优化的查询 监控应用程序的数据库交互性能 容量规划 两阶段提交 why need？binlog与redo不同时进行 若有一个没成功刷盘 都会主从不一致 过程： prepare阶段：将内部XA事务的ID（XID）写入redo 将其事务状态设置为prepare redo持久化 commit阶段：XID写入binlog binlog持久化 redo状态设置为commit 此状态write到page cache 若遇prepare态redolog 找binlog中是否有XID\u0026ndash;\u0026gt;有则提交事务 无则回滚事务 binlog组提交——多个事务提交时 多个binlog刷盘操作合并为一个 MySQL磁盘I/O很高的优化方法——延迟binlog redolog的刷盘时机 性能与架构 explain：查看sql执行计划 如是否走索引 有无外部排序 有无索引覆盖 explain的索引不对\u0026ndash;\u0026gt;使用force index强制索引\n查询速度慢 怎么解决？ 用explain分析查询语句 创建或优化索引 避免索引失效 查询优化（select *） 优化数据库表（拆分为小表） 缓存技术 主从延迟解决：强制走主库（针对大事务/资源密集型操作） 分库分表是什么\u0026amp;区别： 分库：水平扩展数据库 数据按一定规则划分到多个独立数据库 每个数据库只存储部分数据（分布式存储）\u0026ndash;\u0026gt;解决并发连接过多问题 分表：单个数据库中的表拆分为多个表\u0026ndash;\u0026gt;提高查询效率 减轻单表压力\u0026ndash;\u0026gt;解决单表数据量过大 查询性能下降问题 分库分表操作： 垂直分库（竖着切）：根据业务与功能的维度 将不同业务数据放到不同数据库——专库专用 没有解决单表数据量过大的问题 垂直分表：字段比较多的大表 将较为独立或不常用的字段拆分到单独的数据表中 核心表字段长度较短 可以加载更多数据到内存中 减少磁盘IO 水平分库（横着切）：同个表按一定规则拆分到不同数据库中（表结构不变） 效率高 但数据访问需要额外的路由工作 系统复杂度高 水平分表：拆分到同个数据库内（表结构不变） 只解决了单表过大的问题 还要竞争同个物理机的CPU 内存等 存储引擎 架构？ 插件式架构 基于表（非数据库） MyISAM vs InnoDB 行级锁 \u0026amp; MVCC ==\u0026gt; 不支持 vs 支持 事务 \u0026amp; 崩溃后的恢复 （同上）InnoDB使用redo log（同CS186） 外键 （同上） 非聚簇索引 vs 聚簇索引 缓存 键缓存（仅缓存数据页） vs buffer pool缓存数据页\u0026amp;索引页 查询缓存 nothing\nRedis⭐⭐ 性能 Redis为什么快\n高性能 高并发\n数据结构 数据类型与使用场景 常见5种：String（字符串/整数/浮点） Hash（散列） List（链表 两端push pop） Set（无序集合 不可重复） Zset（有序集合 不可重复） 后加：BitMap（2.2 版新增） HyperLogLog（2.8 版新增） GEO（3.2 版新增） Stream（5.0 版新增） String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等 List：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等 Hash 类型：缓存对象 可以用作购物车 Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注 Zset 类型：排序场景，比如排行榜、电话和姓名排序 BitMap：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等 HyperLogLog：海量数据基数统计的场景，比如百万级网页 UV 计数等 GEO：存储地理位置信息的场景，比如滴滴叫车 Stream（5.0 版新增）：消息队列，克服了List做消息队列的两个问题 数据类型实现： String内部：SDS（简单动态字符串） 可以保存二进制数据——使用 len 属性的值而非空字符串判断字符串是否结束\u0026ndash;\u0026gt;获取字符串的时间复杂度为O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。SDS拼接字符串之前会检查SDS 空间是否满足要求 List：压缩列表（元素个数少于512个 每个元素的值小于64字节 都可用list-max-ziplist-bal调+双向链表\u0026ndash;\u0026gt;quickList（3.2后） Hash：压缩列表+哈希表\u0026ndash;\u0026gt;listpack（7.0后） Set：整数集合（均为整数且个数小于512）+哈希表 ZSet：压缩列表+跳表\u0026ndash;\u0026gt;listpack（7.0） 线程模型 是单线程？ Redis 单线程指的是「接收客户端请求-\u0026gt;解析请求 -\u0026gt;进行数据读写等操作-\u0026gt;发送数据给客户端」这个过程是由一个线程（主线程）完成 但是Redis程序非单线程，启动时会启动后台线程（BIO） Redis2.6后\u0026ndash;\u0026gt;关闭文件 + AOF刷盘（x2后台线程） Redis4.0后\u0026ndash;\u0026gt;新增异步释放Redis内存（即lazyfree线程） 例如unlink key / flushdb async / flushall async，会把这些删除操作交给后台线程执行 好处：这些操作都很耗时，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞 单线程模式： 初始化\u0026ndash;\u0026gt;事件循环函数 事件循环函数： 调用处理发送队列函数，看是发送队列里是否有任务 有发送任务，则通过 write 函数，将客户端发送缓存区里的数据发送出去 如果这一轮数据没有发送完，就会注册写事件处理函数 调用 epoll_wait函数等待事件，若为连接事件\u0026ndash;\u0026gt;连接事件处理函数 / 读事件\u0026ndash;\u0026gt;读取客户端发送的内容并处理，将执行结果写到客户端发送缓冲区 / 写事件\u0026ndash;\u0026gt;通过write向客户端发送客户端发送缓冲区中的数据 单线程为什么还快？——吞吐量10万/s 大部分操作内存完成 避免多线程竞争 I/O多路复用：一个线程处理多个I/O流\u0026ndash;\u0026gt;select/epoll机制（允许内核中，同时存在多个监听Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求，有请求则交给Redis处理） 早期为什么是单线程（Redis6.0之前）？ 单线程程序无法用多核CPU\nCPU并不是制约Redis性能的瓶颈 更多受内内存大小\u0026amp;网络I/O限制 多线程复杂度高，可能存在线程切换、加锁解锁与死锁等性能损耗 为什么之后引入了多线程？ Redis主要工作是网络I/O与执行命令\n实际上是采用多个 I/O 线程来处理网络请求，随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上 但命令的处理还是使用单线程 6.0之后，默认情况下I/O 多线程只针对发送响应数据（write client socket）。可以设置io-threads-do-reads多线程处理读请求 6.0之后默认情况下额外创建6个线程（除主线程，主线程主要负责执行命令，也可以处理I/O）：后台线程x3，额外的I/O线程x3（设置io-threads 默认 4，除去主线程即为3个） 持久化 内存中执行，怎么保证持久化？\n方式：AOF日志 RDB快照 混合持久化 AOF：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里——先写后记 RDB：将某一时刻的内存数据，以二进制的方式写入磁盘 混合：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点 AOF日志：写入的文件在磁盘中，重启时读取该文件记录的操作命令，然后逐一执行（实现数据恢复） 好处： 避免额外的检查开销（如果命令语法有问题，又写入了日志 恢复数据时有问题） 不会阻塞当前写操作命令的执行（写成功后才会记录） 坏处： 数据可能丢失（执行完没来得及写入日志） 可能阻塞其他操作（AOF日志也在主线程中执行） 具体过程： Redis 执行完写操作命令后，将命令追加到 server.aof_buf 缓冲区 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件。并未写入硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入 内核决定何时写入——Redis.conf文件可配置appendfsync（always每次写操作执行完写回 everysec每秒写回 no由OS决定写回时机） AOF日志过大，会？ 会AOF重写来压缩AOF文件——读取当前数据库中的所有键值对，然后将每个键值对用一条命令记录到新的AOF文件，全部记录完后替换现有AOF 如重复记录set name balabl，只保留最新数据即可 重写AOF日志的过程？ 由后台子进程 bgrewriteaof 完成 好处：避免阻塞主进程 \u0026amp; 若使用线程，多线程间会共享内存，修改共享数据时需要加锁，亲子进程间以只读方式共享数据，若修改会发生写时复制，即亲子间有独立的数据副本（不用加锁） 重写时主进程依然正常处理命令，会将写命令写入到 「AOF 缓冲区」和「AOF 重写缓冲区」（创建子进程后启用） 子进程完成重写时向主进程发送（异步）信号（进程间通讯的一种方式） 主进程收到信号，将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，新的 AOF 的文件改名，覆盖现有的 AOF 文件 RDB快照：记录实际数据 快照时是否阻塞线程？ 执行save，在主线程生成RDB文件——会阻塞 执行bgsave，子进程生成RDB文件——避免阻塞 配置文件中设置save即为bgsave 全量快照——内存中所有数据都记录 执行快照时 数据能修改吗？——专指bgsave 可以，采用写时复制（Copy-On-Write, COW）——执行 bgsave 命令的时候，会通过 fork() 创建子进程 共享内存数据 主线程执行写操作，将被修改的数据复制副本，子进程将副本数据写入RDB文件，主进程可直接修改数据 混合持久化？ AOF丢失数据少但恢复速度不快，RDB快照频率不好确定，过低丢失数据多，过高影响性能\n如何实现？ 工作在AOF重写过程：重写子进程将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，主线程处理的操作命令被记录在重写缓冲区，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件。重写完成后替换。 AOF中前半是RDB格式全量数据，后半是AOF格式增量数据 优点：开头为 RDB 的格式，使得 Redis 可以更快的启动 + 结合 AOF 优点，减低了大量数据丢失的风险 缺点：添加了RDB格式内容，AOF 文件的可读性很差 + 兼容性差，Redis4.0前版本不能识别 集群 less⭐ 主从复制：一主多从 读写分离 主服务器读写，发生写时同步到从；从一般只读，接受主服务器的写命令并执行 异步：主服务器在本地执行完命令，就向客户端返回结果\u0026ndash;\u0026gt;无法实现强一致性（时刻一致） 哨兵模式sentinel：监控主从服务器 \u0026amp; 主从节点故障转移功能（不懂）\u0026ndash;\u0026gt;选一个新leader 切片集群cluster：（一个）切片集群有 16384 个哈希槽，类似于数据分区，每个键值对根据它的 key，被映射到一个哈希槽\u0026ndash;\u0026gt;哈希槽被映射到具体的Redis节点（IP不同的就是不同节点） 哈希槽的映射：平均分配 / 手动分配（cluster meet 节点建立连接后，cluster addslots 指定各节点上哈希槽数） 集群脑裂问题与解决 集群脑裂是啥？ 由于网络问题，集群节点之间失去联系（主从间）\u0026ndash;\u0026gt;哨兵重选主节点，产生两个主服务\u0026ndash;\u0026gt;网络恢复，旧主节点降级为从节点，需要与新主进行同步复制\u0026ndash;\u0026gt;从节点清空自己缓冲区（之前未同步的数据）\u0026ndash;\u0026gt;客户端当时写入的数据丢失 解决： 当主节点发现从节点下线或者通信超时的总数量小于阈值时，就禁止主节点写数据，把错误返回给客户端\u0026ndash;\u0026gt;等待新主机上线后写 可以设置参数 min-slaves-to-write x、min-slaves-max-lag x若从节点连接数小于第一个/延迟超过第二个，主节点禁止写 过期删除与内存淘汰 Redis的过期删除策略？\u0026ndash;\u0026gt; 惰性删除 + 定时删除 设置了过期时间的key被带上过期时间存储到过期字典 （不主动删除键）查询key时先检查是否在过期字典中，在则比对系统时间，判断是否过期——惰性删除 优缺点：占用很少的系统资源 对CPU时间友好 but 过期key一直不被访问，对内存不友好（内存不释放） 定期删除：每隔一段时间随机抽取一定量的key，检查并删除，若过期key超过一定比例则继续随机抽取···\u0026ndash;\u0026gt;限制时间上限 优缺点：balabal（限制时长频率减少cpu占用 减少过期键对空间的占用） but 难以确定删除的时长与频率 持久化时怎么处理过期键？ RDB——生成RDB时不保存过期了的键；加载时主服务器不载入，从服务器载入（但数据同步时，从服务器数据会被清空） AOF——写入时若过期键未被删除，AOF会保留，被删除时向AOF追加DEL命令；重写时不重写过期键 主从模式下怎么处理过期键？ 从库不进行过期扫描，主库删除键，在AOF文件中增加DEL指令，指令同步到从库 Redis内存满了之后？ 内存淘汰机制 内存淘汰策略有？ 不进行数据淘汰——noeviction 超过最大内存时停止提供服务，直接返回错误（Redis3.0后默认） 进行数据淘汰： 在设置了TTL的数据中淘汰： volatile-random 随机淘汰设置了TTL的任意键值 volatile-ttl 优先淘汰更早过期的键值 volatile-lru 淘汰所有设置了TTL的最久未使用的键值（Redis3.0前默认） volatile-lfu 淘汰所有设置了TTL的最少使用的键值 所有数据范围： allkeys-random/allkeys-lru/allkeys-lfu LRU vs LFU Least Recently Used 与 Least Frequently Used\nLRU是？ 链表，被使用的移到链表头，要删除时删除链表尾元素即可 问题：需要链表，带来额外空间开销；需要移动数据，大量数据要操作时会耗时 Redis的LRU实现 在 Redis 的对象结构体redisObject（管理某数据类型的数据对象）中添加额外的字段记录此数据的最后一次访问时间 \u0026ndash;\u0026gt; 随机采样，淘汰最久没用的 缺点：缓存污染不能解决（一次性缓存删不了） LFU？ Redis4.0后引入，记录访问次数 Redis的LFU？ 也记录在redisObject的lru字段中\n多记录「数据的访问频次」的信息 \u0026ndash;\u0026gt; 24 bits 的 lru 字段中高16bit记录访问时间戳，低8位记录访问频次 缓存设计 避免缓存雪崩？ 打散缓存TTL 设置缓存不过期——后台更新缓存 避免缓存击穿？ 热点key问题，热点key过期\u0026ndash;\u0026gt;类似缓存雪崩\n互斥锁\u0026ndash;\u0026gt;未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么返回空值或默认值 热点key不设置过期时间 避免缓存穿透？ 非法请求限制 设置空值/默认值 布隆过滤器 如何设计缓存策略以动态缓存热点数据 总体思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据 缓存更新策略？详见 旁路缓存 读穿/写穿 写回 保证旁路缓存的第二步 删缓存 成功的方法： 通过消息队列，重试缓存删除（删除成功则移出队列）\u0026ndash;\u0026gt;业务代码侵入 订阅 MySQL binlog（更新后会更新binlog） + 消息队列 + 重试缓存的删除\u0026ndash;\u0026gt;避免入侵 but 引入组件多 采集binlog日志信息，发送到MQ队列 \u0026ndash;\u0026gt; 编写一个简单的供缓存删除消息者（需要接收/发送 删除缓存 消息的）订阅的binlog日志 \u0026ndash;\u0026gt; 根据更新的log删除缓存，通过ACK机制确认处理这条更新log 实战 如何实现延迟队列？——下单后超过一定时间未支付则取消 Zset，其中Score属性可以存储延迟执行的时间（最晚的时间，查找时排序选择score小于系统时间的） Redis的大key问题 什么是大key value大的key\u0026ndash;\u0026gt;String 类型的值大于 10 KB / Hash、List、Set、ZSet 类型的元素的个数超过 5000个 可能的问题？ 由于大key操作更耗时而产生\n客户端超时阻塞：操作耗时，客户端视为很久不响应 网络阻塞：获取大key产生的网络流量大\u0026ndash;\u0026gt;如果一个 key 的大小是 1 MB，每秒访问量为1000，那么每秒会产生 1000MB 的流量 工作线程阻塞：del删除大key时会阻塞 内存分布不均：部分有大 key 的 Redis节点占用内存多，QPS 也会比较大 Redis管道？ 客户端提供的批处理技术，用于一次处理多个 Redis 命令\u0026ndash;\u0026gt;一次性发送多个命令，处理后一起返回 优缺点：解决多个命令执行时的网络等待 but 发送的命令过大，或管道内的数据太多会导致网络阻塞 Redis事务支持回滚吗？ NO。类似的Discard命令只能主动放弃事务执行，清空暂存的命令队列（没完成的扔掉，完成了的已经写入\u0026ndash;\u0026gt;不保证原子性） 如何实现分布式锁——setNX 加锁：setNX+ 过期时间+区分客户端（唯一标识） 解锁：判断用户+删除锁键 （Redis实现分布式锁的）优缺点：高效、实现方便、避免单点故障 but 超时时间不好设置、主从异步复制 锁不可靠（主获得锁，未复制时若主宕机，新的主还可以获取锁） 如何合理设置超时时间：基于续约的方式设置，设置超时时间后启动守护线程，其在一段时间后，重新设置锁的超时时间 集群情况如何保证分布式锁的可靠性 RedLock红锁 基于多个Redis节点 让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么认为客户端成功地获得分布式锁，否则加锁失败 加锁失败后，客户端向所有 Redis 节点发起释放锁的操作，释放锁的操作和在单节点上释放锁的操作一样 杂七杂八⭐⭐ 进程与线程的区别？ 进程是OS层面 是程序的一次执行过程 一个进程内可能有多个线程 线程是CPU调度的基本单位 共享进程的地址空间与内存资源 Java中 不同线程拥有独立的JVM栈（java虚拟机） 本地方法栈 程序计数器 进程通信需要管道、信号量等 线程通信通过共享资源的读写操作实现 Map底层实现： HashMap：JDK1.8之前 数组+链表（解决哈希冲突问题——拉链法） vs JDK1.8后 链表长度大于阈值（一般为8）时 数组长度小于64就进行数组扩容 大于时将链表转换为红黑树 LinkedHashMap：继承HashMap 加入双向链表 使键值对可以保持插入顺序 HashTable：由数组和链表组成 类似HashMap的初始形式 TreeMap：红黑树 解释型与编译型： 编译型语言，通过编译器将源代码一次性翻译成可被执行的机器码。执行快 开发慢 解释型语言。通过解释器一句一句的解释，边解释边执行。开发快，执行慢 Java：编译与解释并存。Java程序要先编译生成字节码（.class文件） 后字节码通过Java解释器来解释执行 JIT vs AOT(ahead of time compilation)JDK9引入新的编译模式 AOT：程序执行前将其编译为机器码，属于静态编译 避免JIT预热等开销 可以提高启动速度 + 减少内存占用 + 增强Java程序安全性 but：无法支持Java动态特性，如反射 动态代理 动态加载 JNI等 JIT：具有更高的极限处理能力，能够降低请求的最大延迟 ","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"Mysql Redis相关内容","title":"八股——数据库"},{"content":" Notes Proj0 运行CommandLineInterface.java时报错：Exception in thread \u0026quot;main\u0026quot; java.lang.NullPointerException at java.base/java.io.Reader.等 将resources文件夹修改为资源根目录 Proj1 运行sqlite3载入db文件失败 cmd中直接运行sqlite3 lahman.db python在cmd中运行无反应： 检查环境变量（已添加） 运行py test.py即可，py代表python3 left join适合对右表中不存在的但是想在结果中显示的数据进行处理（左表中需存在） 求和：sum 统计数量：count 子查询：eg.查询某值大于某个人该值的列表——某个人该值作为子查询部分，在order前添加 and lslq\u0026gt;(select cast(sum(H-H2B-H3B-HR+2*H2B+3*H3B+4*HR) as float)/sum(AB) as ones from batting,people where people.playerID=\u0026#39;mayswi01\u0026#39; group by batting.playerID) order by lslq desc Proj2 用B+树为存储的数据编写index 提升查询效率（select * from table语句）\nB+树——根据索引进行查找（的典型数据结构之一）——符合磁盘（and···）分页存储的特性 不使用二分查找——$log_2N$层 可以用多子替换二叉树的二子 支持顺序查找 插入稍难（溢出页）——ISAM = 在排序的堆文件中存储数据条目 堆文件后有高扇出（保证树的高度不过高）的静态树索引（具有索引） B+树：所有数据存储在叶子节点上（相比于B树）——层数矮但可以容纳大量数据 若root已满 但需要放入数据时——拆分root成为第二层，推举其中一个数据成为新root中的数据 保证（占用不变性）：除了root外，所有节点至少半满（删除操作中不保证占用不变性——直接删除） 批量插入：先对需插入的数据进行排序，填充叶子节点至（eg.大于半满）状态后，创造其对应的上层parent节点 减少IO次数 \u0026amp; 不需随机插入（例如：左边插入结束后 不需再次访问） 聚簇与非聚簇——聚簇对于范围搜索非常高效 但大量插入后性能会下降（退化） 局部性优势——可以顺序访问堆文件 处理变长键——以字节为单位进行衡量 Proj2：注意处理边界情况 若批量添加条件难以判断可以尝试简化为逐个添加 keys rids rightSibling metadata等意义 Proj3 LRU（least recently used最近最少使用页面置换）+顺序扫描 = 顺序淹没 时钟算法类似 MRU（most recently used） buffer pool 缓冲池——跳过操作系统的缓存管理 由数据库系统制定管理策略（包括预取 MRULRU···） 关系代数——操作性描述（diff to SQL） 关系代数 运算符： $\\pi$——选取一列projection $\\sigma$——选取n行selection $\\rho$——重命名renaming $\\cup$——并集 去除重复项union $-$——1中有2中无setdifference $\\times$——交叉积 $\\cap$——intersection 交集 $\\bowtie$——joins 各种形式的连接 $\\pi$——选取一列projection：选择单独列会进行去重 $\\cup$——并集 去除重复项union：对应列的类型相同 = UNION（in sql） $-$——1中有2中无setdifference：对应列的类型相同 = EXCEPT in sql $\\rho$——重命名renaming:1-\u0026gt;newname 第1列（位置）改名为newname 排序\u0026amp;哈希 双缓冲：输入输出缓冲区 双线程进行IO与计算 part1实现 重置：左块遍历完后需要重置左块 当前右页重置 整个右页记录重置——每个新左块需要与所有右页记录比较 不要对右页做不必要的延长（next()）——left表示左表 right表示右表 part1 task2——实现Grace Hash Join（结合两个大型数据库——按连接键joint keys eg.用户id） 若左partition或右partition数量小于等于B-2 执行buildandprobe 在GHJ中记录根据哈希值被分区。如果所有记录都相同，会被分到同一个分区。该分区超过了内存限制，从而GHJ失败 GHJ过程： 分片成小chunk（不同的哈希函数实现） 选择较小的数据集作为 build 阶段的数据集，以减少内存使用 遍历 build 数据集中的每一条记录，根据连接键计算哈希值，并将记录插入到哈希表中，哈希表的键是连接键的哈希值，值是记录本身 遍历 probe 数据集中的每一条记录，根据连接键计算哈希值，并在哈希表中查找匹配的记录 如果找到，则将 probe 记录和 build 记录连接，并将结果添加到输出结果集 task3——外部归并排序，处理无法一次性加载到内存中的大数据集——将其分割成小块 （内存中）后排序 最后合并（完成处理） 将多个已排序的 Run 合并成一个新的已排序的 Run task4——Sort Merge Join（排序后结合两个大型数据库） 确保每个 leftRecord 都能与所有可能的 rightRecord 进行比较——相等时返回left+right 当 leftRecord 和 rightRecord 不相等时，需要重置 rightIterator 并获取下一个 leftRecord，然后继续比较 因为 rightIterator 可能已经遍历到末尾，需要重置以便从头开始与新的 leftRecord 进行比较 part2实现 实现动态规划+左深树（=最优性原理），（优化查询）以更好的顺序将表联接在一起\n单表：计算顺序查询的时间——任意索引查询的时间——选出时间最短的方法 多表： 外层循环遍历 prevMap 中的每个表集合 内层循环遍历 this.joinPredicates 中的每个连接词 确保找到所有可能的连接，并计算出最低成本的连接操作 pass1Map：一个映射，每个表名映射到其对应的查询操作符（eg.group by） 知识点 (针对多表查询的情况)因为在此proj中只有JOIN连接符 需要选择最佳的连接算法 过程如下👇\n实现了GHJ, Sort and SMJ 但最终的连接符在SNLJ BNLJ中选择（衡量标准：磁盘IO次数） 操作符的结果以迭代器的形式传给下一个操作符\nSNLJ：笛卡尔积——for循环扫描驱动表 for循环扫描被驱动表 结合 在有索引的条件下性能更好\nBNLJ：“基于块的嵌套循环连接” 驱动表取一块放到join buffer pool，被驱动表逐条跟块比较，合适的放入。减少磁盘I/O 针对多表搜索： 先循环查找每个表最佳的搜索方法（顺序搜索/索引搜索） 后循环使用前一轮的结果和当前表进行连接，并选择最低成本的连接方法 Proj4 事务transaction\u0026amp;并发concurrency 串行调度——一个事务完成后 资源释放 冲突可串行 = 可串行 严格两阶段锁——级联中止情况不存在 包括共享锁 排他锁 多粒度锁——不同的锁可以锁住页面 表 数据元组等不同粒度——意向锁 为了锁住A 需要获得A所有祖先适当的意向锁——避免放置可能导致冲突的锁 part1实现 task1 锁的权限范围 = 加了这种锁之后操作者的权限范围（读写锁的权限范围\u0026gt;读锁的） part2实现 task3 resourceName = 分层架构中的一个（可能是数据库 表 or 页） transaction 事务 ensureSufficientLockHeld确保持有足够的锁——处理最基础的请求锁情况 确保当前事务持有恰当的锁 且其祖先能够获取指定的请求锁类型 promote 将事务在上下文上持有的锁类型升级为更严格的锁类型 将锁类型从较不严格的类型（例如 S）更改为更严格的类型（例如 X），而不释放任何锁 escalate 将事务在上下文的所有子级上持有的锁合并为在上下文本身上的单个锁 作用：释放所有子级锁，并在上下文上获取单个锁（S 或 X） 如果当前锁类型是 X 或 IX，则新的锁类型为 X；如果当前锁类型是 S 或 IS，则新的锁类型为 S 需要：获取事务持有的所有锁、所有子级锁\u0026ndash;\u0026gt;如果当前锁类型与新的锁类型不同，则进行锁升级 task4：释放时用LockContext 不用LockManager\u0026ndash;\u0026gt;其不会验证多粒度约束 用LockContext对象承接通过LM得到的所有锁 而后release 反向释放锁——从子级到parent级的顺序\u0026ndash;\u0026gt;parent一般比子级权限更宽泛 若parent先释放 其他事务可能在子级锁定的情况下获得parent级锁\u0026ndash;\u0026gt;冲突 List\u0026lt;Lock\u0026gt; locks = lockManager.getLocks(getTransaction()); for (int i = locks.size() - 1; i \u0026gt;= 0; i--) { Lock lock = locks.get(i); LockContext lc = LockContext.fromResourceName(lockManager, lock.name); lc.release(getTransaction()); } 知识点 释放锁：严格两相锁——只有在事务结束时才能释放锁（不严格的可以随时释放） 释放顺序：从下至上 若反可能死锁（违反了获取锁的顺序 eg.T1-getAlock getBlock unlockA T2-getAlock T1-wantAlock T2-wantBlock ==\u0026gt;deadlock） 获取锁：从上至下锁住 不管是获得子级还是parent级 都需要通过canBeParentLock检验 Proj5 事务恢复——Aries Log Records\n提交不强制——记录操作 撤销未提交事务（原应在系统重启时abort） 重做事务（它的更新尚未写入到磁盘中） 日志序列号LSN——“已刷新LSN” 到达磁盘的最后的日志 事务表（包括事务ID 状态 最后LSN） + 脏页表（记录与磁盘不同步的页面 包括页面ID 恢复LSN） 最后LSN——该事务使用的操作的最后一个日志记录 恢复LSN——第一个造成脏页的日志记录 = 预写日志 + 模糊查询点fuzzy checkpoint task3 回滚到保存点\u0026ndash;\u0026gt;复用rollback task4 模糊检查点——先放入（判断是否fit）当不能满足时\u0026ndash;\u0026gt;remove 并清空序列 最后再放入 若先检查后放入\u0026ndash;\u0026gt;新放入的这个record的大小不能保证满足 遍历 dirtyPageTable 并复制条目 如果复制当前记录会导致结束检查点记录太大 将其记录到记录中 刷新到LSN 清空DPT 将过大的记录放入DPT 遍历 transaction 表，并复制 status/lastLSN 同上操作 输出 1 个最终结束检查点 task5 重启恢复\nlamda表达式：transactionTable.computeIfAbsent(transNum, k -\u0026gt; new TransactionTableEntry(newTransaction.apply(transNum))); k-\u0026gt;表示Map中的键 👆table是一个Map变量 computeIfAbsent 如果transNum键存在 即用该键 若不存在 则用k-\u0026gt;指向的键 CLR-补偿日志记录\u0026ndash;\u0026gt;记录撤销过程的操作（避免撤销时崩溃） 在FREE_PAGE或UNDO_ALLOC_PAGE状态 证明更新已刷新到disk 需要删除脏页记录 知识点 实现WAL引入LSN 表示操作顺序（日志记录）——no force\u0026amp;steal no force:仅在需要从缓冲池中删除页面时才写回磁盘\nsteal:允许在事务完成之前将修改后的页面写入磁盘（性能最好）\nprevLSN：存储同一事务中的最后一个操作（该事务的前一步LSN） flushedLSN：跟踪已刷新到磁盘的最后一条日志记录的 LSN pageLsn：存储上次修改数据页页面的操作的 LSN pageLSNi≤flushedLSN才能将第i页刷入磁盘（flushed此时代表刷入盘的日志记录的LSN） 撤销： （撤销时将CLR写入日志）CLR（Compensation Log Record） 是一种新型记录，表示我们正在撤消特定操作，本质上与 UPDATE 记录相同，但它表示写入操作是由于之前发生了 abort 而发生的 恢复的数据结构：事务表+脏页表 事务表：XID 状态 lastLSN 脏页表：页码 recLSN（脏页面的第一个操作） recLSN \u0026gt; on disk pageLSNP;recLSN ≤ in memory pageLSNP 这两个表都存储在内存中;因此从崩溃中恢复时，必须使用日志来重建表。简化此操作的方法——检查点 ARIES算法： 分析阶段——恢复事务表与脏页表 redo——重做以保证持久性 undo——撤销崩溃期间运行的事务中的操作，确保原子性 aries算法详解 分析阶段： 背景：一个问题是它需要数据库扫描整个日志。在生产数据库中，这是不现实的——checkpointing加快分析 一条 \u0026lt; BEGIN CHECKPOINT \u0026gt; 记录，说明检查点何时开始，\u0026lt; END CHECKPOINT \u0026gt; 记录，说明我们何时完成将表写入日志。写入日志的 table 可以是 和 之间任何点的 table 状态 只需扫描两个检查点之间的日志 原则： 如果记录是 UPDATE 记录，且页面不在 DPT 中，将页面添加到 DPT 并将 recLSN 设置为等于 LSN 如果记录是 END 记录， 从 Xact Table 中删除事务 其它的直接加入事务表（running会改为aborting） redo： 从 DPT 中最小的 recLSN开始恢复 原则：(不恢复的情况) log从前向后遍历 (LSN表示在磁盘的log中当前读到的LSN) recLSN \u0026gt; LSN。表示弄脏页面的第一次更新发生在此操作之后。这意味着我们当前正在进行的操作已经进入磁盘，否则它将是 recLSN pageLSN （disk） ≥ LSN。表示进入磁盘的页面的最近一次更新发生在当前操作之后，同样如上 该页面不在 DPT 中，意味着所有更改（以及此更改）都已刷新到磁盘 只重做所有 UPDATE 和 CLR 操作——即发生了更改的操作 undo： 原则：撤消阶段将从日志的末尾开始，一直持续到日志的开头。它撤消在崩溃时处于活动状态（正在运行或中止）的每个事务的每个 UPDATE 并写入 CLR 记录 注意：CLR 记录还有一个附加字段 undoNextLSN 。存储要为该事务撤消的下一个操作的 LSN（即正在被撤消的操作的prevLSN） 遇到CLR语句：记录CLR undoNextLSN记为原CLR的undoNextLSN指向的语句的prevLSN（不是很懂但是） 总结：首先通过重新创建事务和脏页表并redo任何未刷盘的修改来重建崩溃前的数据库状态。然后，我们中止崩溃前运行的所有事务，并通过undo撤销这些事务的所有影响 Proj6 MongoDB\n文档型数据库——NoSQL 构架 数据库\u0026ndash;\u0026gt;集合\u0026ndash;\u0026gt;文档（Binary JSON形式存储） 相当于Mysql 数据库\u0026ndash;\u0026gt;table\u0026ndash;\u0026gt;行 字段feild相当于Mysql的列 文档间结构可以不同 基操 插入文档：db.集合.insertOne({bala: \u0026quot;bala\u0026quot;}) 查询：find(something) 可以在其后添加各种后缀精确查询 若要显示精确的字段：({查询条件},{字段:1,字段:0}) 1\u0026ndash;\u0026gt;显示 0\u0026ndash;\u0026gt;不显示 显示时排序：.sort({字段:1}) 1\u0026ndash;\u0026gt;升序 -1\u0026ndash;\u0026gt;降序 显示时跳过某文档：.skip(序号) 如升序时填1则跳过最小的 or运算符：{$or:[{name:\u0026quot;English\u0026quot;},{name:\u0026quot;French\u0026quot;}]}\u0026ndash;\u0026gt;中括号 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/cs186/","summary":"6个proj与相关知识点","title":"CS186"},{"content":" 功能完善 拦截器 Utils中实现添加拦截器Interceptor功能，在config中添加MVCConfig以添加拦截器并设置排除拦截的地址 session 存储用户基本信息即可\n多台Tomcat不共享session空间（存储当前用户信息）\u0026ndash;\u0026gt;切换不同Tomcat时数据丢失 需要数据共享 内存存储 键值 ==\u0026gt;Redis替代 Redis 保存用户时以随机token作为key 设置有效期 另外用户访问时持续更新时长\u0026ndash;\u0026gt;在拦截器中设置 取出Hash类型的所有字段\u0026ndash;\u0026gt;entries 缓存 数据交换缓冲区 临时存储数据 读写性能较高\n注意：添加缓存时根据Redis中类型转换变量类型 Redis使用String类型——以JSON形式存储，需转换 缓存更新策略 内存淘汰 Redis内存不足时自动淘汰部分数据 一致性差 无维护成本 超时剔除 为缓存数据添加TTL时间 下次查询时更新缓存 一致性一般 主动更新 Cache Aside \u0026amp; Read/Write Through \u0026amp; Write Back 一致性好 主动更新 Cache Aside Pattern 更新缓存无效写操作较多（若查询很少）——\u0026gt;删除缓存 查询时再更新缓存 保证缓存与数据库操作同时成功/失败——\u0026gt; 单体系统：缓存与数据库变一个事务 分布式系统：TCC等分布式事务方案 先删缓存再改数据库or先修改数据库（线程安全性）——\u0026gt;先改数据库后删缓存 封装成事务 缓存穿透 客户端请求的数据在缓存和数据库中都不存在\n缓存空对象：在Redis中缓存键值对null 造成额外的内存消耗——设置TTL解决 可能造成短期不一致 布隆过滤：客户端到Redis之间设置布隆过滤器 判断存在则放行 不存在则拒绝请求 ≈ 数据库中数据通过Hash转换后在过滤器中以二进制位形式存储 优点：内存占用较少 没有多余key 缺点：实现复杂 可能误判（判为存在） 选择缓存空对象\n其它解决方案：增加id复杂度 \u0026amp; 做好数据的基础格式校验 \u0026amp; 用户权限校验 \u0026amp; 热点参数限流 缓存雪崩 同一时段内大量缓存key同时失效/Redis服务宕机 导致大量请求到达数据库——\u0026gt;巨大压力\n给不同key的TTL设置随机值 利用Redis集群提高服务的可用性 缓存业务添加降级限流策略（牺牲部分服务） 给业务添加多级缓存（浏览器 nginx JVM…都设置缓存） 缓存击穿 “热点key问题” 被高并发访问\u0026amp;缓存重建业务（查询数据库并更新缓存）较复杂的key突然失效 无数请求访问会给数据库带来巨大冲击\n互斥锁——（查询缓存未命中后）获取互斥锁成功后才可进行缓存重建，若获取失败 休眠一会后重试 优点：无额外内存消耗 \u0026amp; 保证一致性 \u0026amp; 实现简单 缺点：线程需要等待 性能受影响 \u0026amp; 可能死锁 逻辑过期——存储热点key的value时在value中增加逻辑过期值expire（实际上不设置TTL） 手动回收 查询缓存 检查逻辑时间是否已过期 已过期，获取互斥锁成功，开启新线程来更新expire，本线程返回过期数据，新线程更新完毕释放锁 已过期，获取互斥锁失败，返回过期数据 优点：线程无需等待 性能较好 缺点：不保证一致性（返回旧数据） \u0026amp; 有额外内存消耗 \u0026amp; 实现复杂 使用逻辑过期 创建线程池 private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10); 秒杀 全局ID 针对优惠券\n订单表不用自增ID：id规律性明显 \u0026amp; 受单表数据量限制 分布式系统下生成全局唯一ID的工具 高可用 递增性 安全性 高性能 唯一性 ID组成：符号位 + 时间戳（31位） + 序列号（32位） 设置每天一个key 避免超过上限 超卖 产生：对库存进行操作完成前 有线程访问 即会产生超卖 锁： 悲观锁：线程安全问题一定发生，操作数据前先获取锁eg.Synchronized lock 乐观锁：不一定发生，只在更新数据时判断是否有其他线程对数据进行了修改 乐观锁：两种方案 版本号法：数据库中添加version字段，修改时需校验version与之前查到的是否一致，一致时同时更新版本号 CAS法：直接把库存当版本即可 成功率过低 一人一单 加悲观锁——Synchronized 对同一个用户加锁，intern方法保证只对该值加锁 不是新创建对象（toString会新创建对象） 当锁在事务中时，锁释放后事务尚未提交 ==\u0026gt; 其他线程仍有可能访问到未更新的内容 锁在方法上时，会对所有this对象都加锁and···，范围太广 选定把锁加在方法调用上 synchronized (userId.toString().intern()) 锁加在方法调用上时，this的对象并非代理（Impl）对象，Spring的事务会失效，解决方法选择获取代理对象 注意有几种使Spring的事务失效的可能 有几种解决方案\nsynchronized (userId.toString().intern()) { IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } * 主方法中添加注解`@EnableAspectJAutoProxy(exposeProxy = true)` * 添加AspectJweaver依赖 集群设备访问 失效 测试时设置虚拟机设置（VM options）修改为多个端口号 分布式锁 满足分布式系统/集群模式下多进程可见\u0026amp;互斥的锁\n要求：多进程可见 + 互斥 + 高可用 + 高性能 + 安全性 + ··· 对比：MySql Redis Zookeeper 维度 MS R Zk 互斥 自身的互斥锁 setnx等互斥命令 节点唯一性 有序性实现 高可用 好 好 好 高性能 一般 好 一般 安全性 断开连接自动释放锁 锁超时时间设置 临时节点 断开连接则释放 实现：设置锁的同时保证互斥（设置锁\u0026amp;设置过期时间 语句合二为一） 业务完成后需手动释放锁 SET lock thread1 NX EX 10 问题：误删（eg.某线程业务阻塞 锁超时释放 其他线程即可获取锁 此后原业务再释放即释放了其它线程的锁） 解决：删除锁时对比value是否是本线程——修改释放锁逻辑即可 value存储某固定UUID+线程标识 新问题：判断标识与释放锁必同时进行（否则过程中发生阻塞后也会有问题——Java自身导致的） 解决：保证原子性——Lua脚本（不用Redis的事务机制） 一个脚本中编写多条命令 -- 从1开始计数 local key=KEYS[1] -- 非key的都用ARGV保存 local threadId=ARGV[1] 隐患：（极小概率）——Redisson解决 不可重入——同个线程不可多次获取同一把锁 不可重试 超时释放——业务执行耗时较长 锁也会释放 主从一致性 Redisson 设置：引入依赖——配置config——注入后直接使用 @Configuration public class RedissonConfig { @Bean public RedissonClient redissonClient() { Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://192.168.balabal:6379\u0026#34;).setPassword(\u0026#34;123456\u0026#34;); return org.redisson.Redisson.create(config); } } 可重入锁原理👇：同一线程可以多次访问一个锁——Redis用Hash结构保存，value为访问次数，当最后value==0时释放锁（若非0，则重置有效期后继续执行业务——不在最外侧）\nLua脚本编写 可重试：订阅等功能实现——等待、唤醒、获取锁失败👇\n超时续约：watchDog 每隔一段时间重置超时时间（leaseTime=-1时自动进入）👇\nRedisson分布式锁过程👇（读源码）下图来自：黑马程序员Redis入门到实战教程 主从一致性（主从同步有延时/同步失败时）——设置多Node 必须在所有Node都获得锁程序才获得锁（也可以继续给Node配Slave节点）\n异步优化 （Lua脚本）Redis进行判断购买条件与“扣减库存” tomcat根据其传回的信息判断是否添加到阻塞队列并返回订单id mysql异步下单 两线程进行 阻塞队列 BlockingQuene——队列为空时 阻塞进程；队满时插入 阻塞进程 Spring Security 鉴权 权限：访问 执行 控制 共享 RBAC\u0026ndash;\u0026gt;role-based access control RBAC0：用户\u0026ndash;\u0026gt;角色\u0026ndash;\u0026gt;许可（均为多对多） == 3+2张表（对应关系表） RBAC1：引入角色继承机制（角色间的等级关系） RBAC2：在0的基础上引入对角色的约束\u0026ndash;\u0026gt;一个用户不能同时具有两种特定的权限 RBAC3：约束+继承 注解 eg.PreAuthorize\u0026ndash;\u0026gt;提前鉴权验证 基于RBAC鉴权模型添加统一功能 \u0026ndash;\u0026gt; AOP（切面 = 切点 通知 连接点 ···） 拦截指定方法并增强，无需侵入业务代码 模块化 非侵入式 可重用性 松耦合 提高性能与可拓展性 （spring boot）启动类添加注解EnableAspectJAutoProxy 定义接口anno 添加Target Retention注解——target的是method 在runtime有效运行 切面类编写 添加Aspect Component注解——切面类方法的具体实现 (配置AOP时 把目标类\u0026amp;切面类都bean（添加注解@Component交予容器管理）) 指定pointcut地址（目标方法地址） 消息队列 待施工···\n封装 泛型 其它 JMeter 运行jmeter.bat即可 拆箱装箱问题 Boolean-boolean Integer-int等\n知识点总结 JWT+Interceptor JWT组成：Header Payload Signature（前二Base64url解码后是JSON格式 签名通过前二+密钥with签名算法得到） Payload 部分默认不加密 JWT如何进行身份验证？ 用户向服务器发送用户名、密码以及验证码用于登陆系统。 如果用户校验正确，服务端返回已经签名的 Token，即 JWT 用户每次向后端发请求都在 Header 中带上 JWT （此处可省略）用户端最好将JWT保存到localstorage 而非Cookie（CSRF风险） 服务端检查 JWT 并从中获取用户相关信息 防止JWT被篡改——签名比对 加强安全性方法 Payload 要加入 exp （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长 JWT 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险 不要将隐私信息存放在 Payload 中 密钥不要泄露。JWT 安全的核心在于签名，签名安全的核心在密钥 JWT优势： 无状态：服务器不需要存储每次会话的客户端信息（传来JWT后用加密算法比对签名即可） 避免CSRF（跨站请求伪造）：CSRF 攻击依赖 Cookie ，Session 认证中 Cookie 中的 SessionID 是由浏览器发送到服务端的，只要发出请求，Cookie 就会被携带（身份就被确定） 适合移动端——Session认证需要Cookie 故不适合（移动端特点：无状态 兼容性强（cookie跨域问题） 安全性差） JWT常见问题： 注销登录后JWT依然有效：存入Redis（违背无状态）+ 保持令牌有效期短并经常轮换 续签JWT：（申请两个jwt）客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。如果服务端判断 accessJWT 过期，客户端将 refreshJWT 传给服务端。如果有效，服务端生成新的 accessJWT 给客户端。否则，客户端重新登录 体积过大：减少payload信息 + 换用传统的token（save in redis） Interceptor：属于Spring MVC（Filter属于Servlet 对所有访问都增强 此只对SpringMVC访问增强） 动态拦截方法调用的机制，在SpringMVC中动态拦截Controller方法的执行 引申 SpringMVC工作流程： 客户端（浏览器）发送请求， DispatcherServlet拦截请求。 DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 URL 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器），并会将请求涉及到的拦截器和 Handler 一起封装。 DispatcherServlet 调用 HandlerAdapter适配器执行 Handler 。 Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet， ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器） Cache Aside Pattern+超时剔除 旁路缓存——适合读多写少场景\n服务端同时维系DB与cache（redis） 并以DB结果为准 写：先更新DB 后删除cache 读：从cache中读 读不到从DB中读并把数据写到cache中 缺点： 首次请求数据一定不在cache里——热点数据提前放入cache 写操作频繁时cache中数据会被频繁删除 影响缓存命中率 超时剔除：向redis中添加缓存数据的时候设置TTL时间，到期后自动删除缓存，下次查询时更新缓存 引申 三种缓存读写策略：（其它的） 读写穿透：以cache为中心 写：cache中不存在 直接更新DB / cache中存在 先更新cache 后cache更新DB 读：cache读到就返回 / 读不到先从DB加载 写入到cache中后返回 缺点：首次请求一定不在cache中 写回：异步缓存写入，以cache为中心 OS的设计，Redis没有异步更新DB的功能，适合写多的场景\n类似读写穿透 但只更新cache不更新DB 异步批量更新DB Redisson分布式锁+乐观锁 分布式锁：多进程条件下 控制某个资源在同一时刻只能被一个应用所使用（线程用synchronized即可）\n源码（看门狗 Lua脚本啥的） 分布式锁的要求： 互斥性：同一时刻只能有一个节点持有锁 可重入性：允许持有锁的节点在释放锁后再次获取锁 安全性：确保即使节点崩溃或网络故障，锁不会被永久占用 高性能：锁的获取和释放应该是高效的操作 Redisson过程： 获取锁（Lua+订阅功能）：当一个线程尝试获取锁时，Redisson会在Redis中创建一个字符串类型的键值对，键是锁的名称，值是线程的唯一标识（通常是线程ID）。如果获取锁成功，Redisson会设置一个过期时间，以防止锁被长时间占用。过期时间通常使用随机值，以避免锁过期时间冲突。如果获取锁失败，Redisson会等待一段时间，然后重试。这个等待时间通常是随机的，以减少锁争用 释放锁（Lua）：当一个线程释放锁时，Redisson会检查锁的持有者是否与当前线程匹配。如果匹配，Redisson会删除锁的键值对，释放锁。如果持有锁的线程在锁过期后仍然未释放锁，其他线程可以尝试获取锁 乐观锁\u0026amp;悲观锁 悲观锁：认为共享资源每次被访问的时候就会出现问题\u0026ndash;\u0026gt;共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程 eg.synchronized ReentrantLock 易发生线程阻塞 乐观锁：只在提交修改的时候验证数据是否被其它线程修改过——版本号/CAS算法（eg.AtomicInteger LongAdder） 如何实现？ 版本号：数据表中添加version字段 要修改时，线程A读取version，提交更新时，比较当前数据中的version是否与自己读到的version的值相同，若相同则version++，不同则重试更新 CAS（Compare And Swap）——原子操作——三个操作数： V：要更新的变量值(Var) E：预期值(Expected) N：拟写入的新值(New) 仅当V==E时，原子执行用N替代V，不等时说明V已被更新，告知此线程并允许重试 CAS如何实现：Unsafe类 依赖于CPU的原子指令 由JNI调用Cpp内联汇编实现 (Unsafe类的CAS方法是native方法，表明这些方法由本地代码（通常是 C 或 C++）实现，直接调用底层的硬件指令来实现原子操作。具体实现与OS CPU相关) 底层通常是while循环 eg.getAndAddInt\u0026ndash;\u0026gt;自旋锁 // 原子地获取并增加整数值 public final int getAndAddInt(Object o, long offset, int delta) { int v; do { // 以 volatile 方式获取对象 o 在内存偏移量 offset 处的整数值 v = getIntVolatile(o, offset); } while (!compareAndSwapInt(o, offset, v, v + delta)); // 返回旧值 return v; } CAS算法问题： ABA——初次读取为A 中间可能有其它线程把数据改为B 准备赋值时检查到仍为A\u0026ndash;\u0026gt;CAS误以为其没被修改过 解决：变量前添加版本号/时间戳\u0026ndash;\u0026gt;JDK 1.5 后的 AtomicStampedReference 类添加了 循环时间长开销大（cause自旋锁） 解决：若JVM支持处理器的pause指令可解 可延迟流水线执行指令 避免内存顺序冲突 只能保证一个共享变量的原子操作 解决：jdk1.5后的 AtomicStampedReference 类解决了（封装为一个类） 引申 (CAS) 内存顺序冲突：多个CPU同时修改同个缓存行的不同部分引起其中一个CPU操作无效 自旋锁快释放时 持锁线程有store命令 自旋线程会发出各自load命令，而此处并没任何 happen-before 排序，所以处理器是乱序执行。\u0026ndash;\u0026gt;pause可以减少并行load数量 Redis+Lua 异步场景：Redis进行判断购买条件与“扣减库存” tomcat根据其传回的信息判断是否添加到阻塞队列并返回订单id mysql异步下单\nLua脚本判断是否重复下单 是否有库存 分别返回不同的数字 条件通过的加入阻塞队列 第二线程：阻塞队列中分别对每个订单进行处理（mysql），此时跟Redisson联动获取锁对mysql进行更改（创建订单） 无论是否报异常 都要释放锁 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/%E7%82%B9%E8%AF%84proj/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"功能完善\"\u003e功能完善\u003c/h2\u003e\n\u003ch3 id=\"拦截器\"\u003e拦截器\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eUtils中实现添加拦截器Interceptor功能，在config中添加MVCConfig以添加拦截器并设置排除拦截的地址\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"session\"\u003esession\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e存储用户基本信息即可\u003c/p\u003e","title":"点评Proj"},{"content":" 计算机网络微课堂（有字幕无背景音乐版） 概述 概念 计算机网络 由结点node\u0026amp;链路link构成 计算机网络可由交换机连接 多个计算机网络可由路由器连接成互连网（协议不定） 全球范围的互连网 = 互联网（统一采用TCP/IP协议） ISP 互联网服务提供商 组成与功能 组成 硬件+软件+协议 硬件：主机（end system端系统） 通信设备balabal 协议由硬件软件共同实现 边缘部分+核心部分 边缘 = 直接为用户服务 （从逻辑功能）资源子网+通信子网 资源子网 主要是主机 功能 数据通信（最基本最重要） 资源共享——硬件 软件 数据 分布式处理——eg.复杂任务多计算机处理 提高可靠性——eg.互为替代机 负载均衡 通信方式 电路交换eg.电话 通信时始终占用端到端线路资源 but 释放/建立连接需要额外时间开销 利用率低 报文交换eg.电报 无需提前建立连接 存储转发（通信线路可灵活分配） 线路利用率高 支持差错控制 but 报文不定长 不利管理 + 长报文存储转发时间、缓存开销大 + 长报文易出错 存储转发 = 先存储后转发 分组交换（现代网络采用） 定长——方便存储转发管理 + 转发时间更少（相对报文交换）+不易出错 控制信息占比增加（报文）+ 存在存储转发时延（电路交换）+ 分成多个分组 传输过程中可能出错 虚电路交换：虚拟电路建立连接 + 通信双方不独占线路 通信方式性能对比 电路交换 建立连接后再进行数据传送 最后连接释放 报文交换 中间节点需接收完整报文后再进行解析与转发 分组交换 分组进行报文交换 分类 分布范围 广域网WAN + 城域网MAN + 局域网LAN + 个域网PAN WAN多采用以太网 MAN 几乎全部采用以太网技术（城域网多归为局域网） 局域网可通过路由器接入广域网 个域网 eg.蓝牙 Zigbee等设备 传输技术：广播式网络 \u0026amp; 点对点网络 拓扑结构： 总线形 广播式 存在总线争用问题 环形结构 广播式 令牌顺环形传递 有令牌才发数据 eg.令牌环网 星形结构 中央设备实现数据点对点传输 eg.以太网交换机连接的设备 网状结构 数据通过各中间节点逐一存储转发 eg.由many路由器构建的广域网 使用者：公用网 \u0026amp; 专用网 传输介质：有线 \u0026amp; 无线 性能指标 信道：向某一方向发送信息的通道（一条发送信道+一条接受信道 = 一个通信线路） 速率：连接到网络上的节点在信道上传输数据的速率 常用单位：bit/s bps（也会用B 1B=8b） 带宽：某信道能传送的最高数据率 吞吐量：单位时间通过某网络（or信道/接口）的实际数据量 时延：数据从网络/链路的一端到另一端所需的时间 发送时延 = 传输时延 传播时延：电磁波在信道中传播花的时间 时延带宽积 = 传播时延 x 带宽 往返时延RTT = 发送方发送完数据的时间到完全接收确认信息的时间 信道利用率 = 有数据通过的时间/利用信道的总时间 利用率过低 = 浪费带宽 过高 = 易网络拥塞 分层结构 同个功能可由不同层实现 结构不固定\n常见计网体系机构： OSI参考模型 + TCP/IP模型 + 五层结构（教学 分层结构概念：计网的各层及其协议的集合 概念： 实体：第n层的活动元素（硬件 软件） = 第n层实体 不同机器上同一层为对等层 同层实体为对等实体 协议（网络协议Network Protocol）：控制对等实体间通信规则的集合 水平 服务 下层为紧邻的上层提供的功能调用 接口（服务访问点SAP） 实体通过接口请求下一层实体的服务 协议 数据传输过程：协议添加在首部or尾部 eg.YSCS协议（压缩传输） 协议数据单元PDU=服务数据单元SDU + 协议控制信息PCI \u0026ndash;\u0026gt; 整体下一层的SDU 协议三要素：语法 语义 同步 同步（时序）——时间实现顺序的详细说明 OSI参考模型 分层：（如下） 分层任务： 第0层：物理传输媒体 物理层：相邻节点间比特的传输 数据链路层：差错控制 + 流量控制（协调两节点的速率）（以帧为单位进行数据传输） 网络层（把分组从源节点转发到目标节点）（以分组为单位进行数据传输） 路由选择：决定分组到目的节点的最佳路径 分组转发：选择合适端口转发分组 网际互连：异构网络互联（不同构造的网络） 其他功能 包括差错控制 流量控制… 传输层（端到端通信 端即端口 = 进程到进程）（以报文段segment为单位） 复用与分用 几个高层实体复用一条底层连接 在接收端分用 其他功能 包括差错控制 流量控制… 会话层（管理进程间会话） 表示层（解决不同主机上信息表示不一致的问题 应用层（实现特定的网络应用）（以报文为单位进行数据传输） TCP/IP模型 分层：网络接口层（≈物理层+数据链路层）+ 网络层 + 传输层 + 应用层（≈else层） 原因： 表示层\u0026amp;会话层可以不用（需要时可在应用层进行处理） 网络层下主要是硬件部分（厂商可自由发挥so合并） 特点： 网络层不进行差错控制 only保证最大能力交付 传输层负责数据正确可靠性 物理层 不隔离广播域 冲突域\n通信基础基本概念 综合： 信源发送信号（数据的载体）到信宿 信号：数字信号 or 模拟信号 信号值离散 or 连续 码元：每个信号就是一个码元 信号周期 = 码元宽度 若一个码元可能有4种状态 = 4进制码元 = 一个码元携带2bit数据 速率：波特率 + 比特率 波特率：码元/秒 = 波特Baud 比特率：比特/秒 信道的极限容量 噪声：对信号产生干扰 奈奎斯特定理 无噪声（理想）低通信道\n极限波特率 = 2W（单位：波特） W为信道频率带宽（单位：Hz） 说明： 若波特率过高 = 导致码间串扰（接收方无法识别码元） 缺点：并未对码元可以携带多少比特做解释 香农定理 有噪声 带宽有限\n极限比特率 = $Wlog_2(1+S/N)$（此处信噪比无单位） $S/N$ 信噪比 = 信号功率/噪声功率 以dB为单位表示为$10log_{10}S/N$ 结合Nyquist可知，带宽、信噪比确定的信道上，一个码元可携带的比特数有上限 编码与调制 概念 信源\u0026ndash;\u0026gt;变换器\u0026ndash;\u0026gt;信道\u0026ndash;\u0026gt;反变换器\u0026ndash;\u0026gt;信宿 变换器：将二进制数据转换为信号 转换为数字信号 = 编码 转换为模拟信号 = 调制（eg.光猫） 反变换器：将信号转换为二进制数据 数字信号转换 = 解码 模拟信号转换 = 解调 编码 方法 不归零编码NRZ——低电平（表示）0，高电平（表示）1，中间不跳变 归零编码RZ——低电平（表示）0，高电平（表示）1，中间归零 反向非归零NRZI——遇0跳变，遇1不跳变，中间不跳变（看起点决定0/1） 曼彻斯特编码——遇0上/跳，遇1下/上跳，中间会跳变（看中间） 差分曼彻斯特——遇0跳变，遇1不跳变，中间会跳变（看起点） 特点 自同步能力——信源信宿可以根据信号实现节奏同步（知道断点在哪） 1无 3增加冗余位时可支持自同步 浪费带宽——每个信号（0/1）中间需要变化时就会浪费带宽 2 4 5浪费 3浪费一点 抗干扰能力 1 2 3弱 调制 调制方法 调幅AM幅移键控——调整正弦波振幅 调频FM频移键控——调整正弦波频率 调相PM相移键控——调整正弦波相位 正交幅度调制QAM——m种幅值 n种相位复合 QAM-32指调制出32种信号 = 每个码元可以携带32bit信号 传输介质 有线常用传输介质 双绞线：两导线绞合而成 有屏蔽层 = 屏蔽双绞线STP 无屏蔽层 / 非屏蔽双绞线UTP 抗干扰能力较好（绞合\u0026amp;屏蔽层） 局域网网线 同轴电缆：内导体\u0026amp;外导体屏蔽层 内导体越粗 电阻越低 信号衰减越少 抗干扰能力好（屏蔽层） 早期局域网 光纤：纤芯（高折射率）\u0026amp;包层（低折射率）= 单模光纤（一条光线传输）/ 多模光纤（多条光线） 单模光纤适合长距离 多模光纤适合短距离 抗干扰能力非常好 信号传输损耗小（中继器少） 命名规则 以太网For有线传输介质\n速度+Base+介质信息 Baseband基带传输 传输数字信号采用曼彻斯特编号 无线传输介质 无线电波（长波）——穿透能力强（绕射性好） 传输距离长 信号指向性弱 手机信号 WiFi 微波通信（短波）——频率带宽高 信号指向性强 保密性差 物理层接口特性 机械特性 + 电气特性 + 功能特性 + 过程（规程）特性 物理层设备 中继器Repeater 传输距离太长 数字信号会失真\nonly两端口 一个接收信号 \u0026ndash;\u0026gt; 整形再生 \u0026ndash;\u0026gt; 另一端口 仅支持半双工通信（一次只能处理一个方向） 两个端口对应两个网段 集线器hub 多端口中继器\n各节点不可同时发送数据 冲突域：若两主机同时发送数据会冲突 则其处于同个冲突域 在发数据前需信道争用 都不能无限串接 数据链路层 隔离冲突域（eg.网桥）\n概述 概念 链路Link：从一个结点到相邻结点的一段物理线路 数据链路：链路 + 实现通信协议的软硬件 以帧为单位传输处理数据 三个问题 封装成帧：为网络层协议数据单元添加帧头帧尾（成为帧） 差错检测：发送方将检错码封装在帧尾 检测是否有误码 检错码根据发送内容 检错算法而不同 可靠传输：即使检出错误，发送方也能保证接收方得到正确信息 封装成帧 帧头帧尾 作用：帧定界 + ··· 让接受层确定一帧的起始点 有的协议不通过帧头帧尾提供帧定界功能 以太网V2的MAC帧通过帧间间隔实现 透明传输 定义：数据链路层对上层交付的传输数据没有任何限制 实现：面向字节的物理链路使用字节填充方法实现 \u0026amp; 面向比特的物理链路使用比特填充方法实现 在特殊字符前添加转义字符 比特流中可采用零比特填充法 帧的长度 为提高运输效率 应使帧的数据部分长些 每种数据链路层协议都规定了👆的长度上限MTU（最大传送单元Maximum Transfer Unit） 差错检测 相关概念 比特差错：比特在传输过程中 0可能变为1··· 误码率BER：一段时间内 传输错的比特占总比特数的比例 校验方法 奇/偶校验：添加1位奇偶校验位 使所有数据中（包括其自己）1的个数为奇/偶 漏检率高 循环冗余校验CRC：约定一个生成多项式 发送方基于数据与多项式计算得冗余码 接收方通过其计算 生成多项式各项系数构成比特串eg.$1x^4+0x^3+1x^2+1x^1+0*x^0$ 对应$10110$ 特点 只能检测 不能定位（定位开销大 不采用） CRC硬件实现容易 可靠传输 概念 传输差错包括比特差错 分组丢失 分组失序 分组重复（一般出现在数据链路层上层）··· 可靠传输服务各层均可选择实现 不局限于此层 实现机制 可被应用到各层协议中\n停止-等待协议SW 属于自动请求重传ARQ Automatic Repeat reQuest\n基本过程：发送方发送分组\u0026ndash;\u0026gt;接收方校验正确给发送方发送ACK接收信号\u0026ndash;\u0026gt;接收方再次发送。若校验错误 接收方返回NAK否认信号 发送方重传 改进： 超时重传：设定超时计时器 若到达重传时间发送方未接收到信号则重传 设定重传时间略大于平均往返时间 数据链路层点对点往返时间较为确定——重传时间较好设定 设置编号：避免分组重复（接收方返回信号丢失后重传原数据） 只需保证与上次发送的数据不同——一个比特即可 （避免确认分组迟到）接收端返回信号进行编号——与发送方的编号一致 数据链路层一般不会出现 信道利用率$U$：往返时延$RTT$远大于数据帧发送时延$T_D$时，信道利用率非常低 回退N帧协议GBN 又名滑动窗口协议\n基本过程：发送方设置发送窗口，同时将窗口内的所有分组发送（需编序号）\u0026ndash;\u0026gt;接收方接收到后发送成功接收信息\u0026ndash;\u0026gt;接收窗口滑动按序号接收\u0026ndash;\u0026gt;发送方收到确认后 发送窗口向前滑动 发送窗口尺寸的取值范围：小于等于序号（eg.0~7 则最大为7） 若等于8 接收方无法分辨新旧数据分组 接收方窗口尺寸=1 差错：发送的信息中某分组错误，整个窗口的数据由于不能匹配被接收方丢弃\u0026ndash;\u0026gt;发送方也重传未被接收的帧eg.从有误码的帧开始（发生超时重传时）==\u0026gt;回退N帧 优化： 累计确认：接收方可以在收到几个数据分组后对按序到达的最后一个分组发送确认$ACK_n$，表示n前的都接收了 发送方收到多个重复确认时 可在重传计时器超时前开始重传 选择重传协议SR 不能再进行累计确认 需要逐一确认 实现发送方仅重传错误分组\n基本要求：发送窗口尺寸$W_T\u0026lt;=2^{n-1}$ \u0026amp; 接收窗口尺寸调整 一般设置与发送窗口尺寸相同（或小于） 若发送方大于，eg.发送方设置为5（最大为4）接收方0号丢失，发送方向后滑到5 6 7 0号，则0号混淆 过程：发送方收到未按序到达的确认分组信号时，对其进行记录，避免超时重发，且不可整体向前滑动（必卡在未收到确认的信号之后） 点对点协议PPP 最广泛的点对点数据链路层协议\n为传输的各种数据报提供标准方法：封装成帧+链路控制协议LCP+一套网络控制协议NCPs NCPs每个协议支持不同的网络层协议 帧格式 0x7E十六进制==\u0026gt;01111110二进制 透明传输实现： 面向字节的异步链路——插入转义字符的字节填充法 面向比特的同步链路——插入0的比特填充法 差错检测：对每个收到的PPP帧进行CRC检验 不通过的帧丢弃 向上不提供可靠传输 媒体接入控制MAC Medium Access Control\n基本概念：共享信道需协调多个发送与接收站点对一个共享传输媒体的占用 类型：静态划分信道 / 动态接入控制 静态多在物理层中应用 动态包括受控接入（以下两分类）与随机接入eg.共享式以太网 集中控制：主站轮询 分散控制：令牌轮流 静态划分信道 信道复用：一条物理线路同时传输多路用户信号 常见复用技术： 频分复用FDM：占用不同的频带资源 时分复用TDM：占用不同时隙 每个时隙周期出现 波分复用WDM：占用不同波长 码分复用CDM：（多用于多址接入 码分多址CDMA）各用户可同时在同样的频带上通信 使用不同码型 每个比特时间被划分为m个短间隔（码片Chip） 每个站被指派唯一的m bit码片序列 若要发送比特1 则发送自己的码片序列 0 则发送码片序列反码 每个站的码片序列必相互正交且不同==\u0026gt;接收站对收到的叠加信号与各站的码片序列相乘，得到-1则该站发送了0，得+1则发送了1，其它则未发送 动态接入控制——随机接入 CSMA/CD （早期以太网）载波监听多址接入/碰撞检测 多址接入MA：多站连接在一条总线上 竞争使用 载波监听CS：每个站发送帧前先检测总线上是否有其他站点在发送，若有96比特时间空闲，则发送 CD：每个正在发送帧的站边发送边检测碰撞，若发生则立即停止发送，过段时间继续 争用期：主机最多经过多久可检测到本次发送是否遭受碰撞 最小帧长：若过小，发送方不知发生了碰撞 最大帧长：若过大，其它主机长时间无法发送信号，接收端也可能溢出 截断二进制指数退避算法：退避时间 = 基本退避时间（争用期） x 随机数r r从0,1,…,$2^k-1$中随机取，$k=min[重传次数,10]$ 退避时间随重传次数增加而增大（动态退避） 可减小发生碰撞的概率 信道利用率——$S=\\frac{T_0}{T_0+\\tau}$ $T_0$为发送成功时间 $2\\tau$为争用期 CSMA/CA （无线）CA 碰撞避免\n帧间间隔：（802.11标准规定）所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧 短帧间间隔SIFS：分隔开属于一次对话的各帧 DCF帧间间隔DIFS：在DCF方式中用来发送数据帧 \u0026amp; 管理帧 相关问题与解答： why：源站检测到空闲后还要等待DIFS？ 让优先级更高的帧（其他站上）先发送 why：目的站正确接收数据帧后还要等待SIFS？ 完成从接收到发送的状态切换 why：其他站要退避随机时间？ 避免同时发送 使用退避算法的情况： 发送数据帧之前检测到信道忙 每次重传数据帧 每次成功发送后要连续发送下一帧（避免一个站点长时间占用信道） 退避算法：站点为退避计时器设置一个随机的退避时间，计到零开始发送，若信道转忙则冻结等其转闲后经过DIFS后继续计数 进行第i次退避时，退避时间在0,1,…,$2^{2+i}+1$中随机选择并乘基本退避时间 基本退避时间 = 一个时隙的长度 第六次退避后 不再增加（达到255） 减少选择相同退避时间的概率 允许对信道进行预约 发送数据帧前发送短控制帧 = 请求发送RTS RTS碰撞则执行退避算法重传RTS 目的站收到且空闲 发送响应控制帧 = 允许发送CTS 发送站收到并等待SIFS后可发送 其他站收到CTS后推迟接入 虚拟载波监听：监听到RTS/CTS/数据帧，即可知道信道被占用的持续时间 减少隐蔽站带来的碰撞问题 MAC地址 IP地址 ARP协议 MAC地址是以太网的MAC子层使用的地址——数据链路层中 IP地址是TCP/IP体系结构网际层使用的地址 ARP协议属于TCP/IP的网际层 可以通过IP地址获取到MAC地址\nMAC地址 链路层首部封装\n（多个主机在同个广播信道上）需要唯一的数据链路层地址 每个帧中需携带标识发送主机和接收主机的地址——MAC地址 一般被固化在硬件上 = “硬件地址” = “物理地址”（win系统中）但不属于物理层 每个网络适配器都有一个全球唯一的MAC地址——对各接口的唯一标识（而非设备） （IEEE 802局域网）MAC地址格式：组织唯一标识符OUI（三字节） + 网络接口标识符（三字节） OUI由注册管理结构分配 后3字节由厂商分配 通常将每4个比特用一个16进制数表示 = 12个的16进制数 MAC地址的第1字节的b0位（第0位）取0表示单播地址 取1表示多播地址 MAC地址的第1字节的b1位（第1位）取0表示全球管理 取1表示本地管理 MAC地址类型👆： 全球+单播：厂商生产网络设备时固化 全球+多播：标准网络设备支持的 本地+单播：网络管理员分配 覆盖全球单播 本地+多播：用户配置主机软件 表明其对多播组的从属关系 地址发送顺序：第一字节-\u0026gt;第六字节 b0-\u0026gt;b7 单播/广播/多播MAC地址：接收方地址（广播填全F 多播填多播组地址） 若多播组地址在接收方的多播组列表中 则接收 IP地址作用（网络层） 若要接入因特网 = IP地址+MAC地址 / 若不接入 只需MAC地址\n组成：网络编号+主机编号 主机编号：标识同一网络上不同主机/路由器各接口 数据包转发过程： 每个链路结束 目的MAC地址与源MAC地址都会改变 IP地址始终如一 每个设备只知下一设备的IP地址 不知MAC地址——地址怎样转变？ARP协议 ARP协议 广播\n封装在MAC帧中 所有主机检查是否请求的是自己的MAC地址 若否则忽略 若是，（添加到自己的ARP高速缓存）则单播发送自己的MAC地址 原请求端将其保存到自己的ARP高速缓存中 ARP只能在一个网络/一个链路中使用 不可跨网络 集线器与交换机 集线器：逻辑上仍是总线网 + 只在物理层工作（不进行碰撞检测）+ 一般有少量的容错能力 集线器HUB在物理层扩展以太网：集线器连接其它集线器 以太网交换机：多接口（全一般双工）+ 能同时联通多对接口 + 工作在数据链路层（包括物理层） 帧交换表（自学习算法建立）：查找帧的目的MAC地址对应的接口号 帧的转发方式：存储转发 \u0026amp; 直通交换（基于硬件的交换矩阵） 对比：集线器会扩大冲突域 交换机会隔离冲突域 以太网交换机自学习\u0026amp;转发帧 自学习：盲目泛洪（发给所有接口）——记录接收接口的号（及其MAC）与发送的接口号（及其MAC） 到期自动删除记录 以太网交换机生成树协议STP 提升以太网可靠性：添加冗余链路（负面效应：网络环路（问题👇） 广播风暴——大量消耗网络资源 无法正常转发其他数据帧 主机收到重复的广播帧 帧交换表反复振荡（同一MAC地址但接口一直变化） （改良）生成树协议STP——自动计算并构建一个逻辑上没有环路的网络——树形 网络物理拓扑发生变化时，生成树需重新计算 VLAN虚拟局域网 多个以太网交换机互连起来的交换式以太网 所有站点属于同一广播域\n广播域过大弊端：广播风暴 + 难以管理维护 + 潜在的安全问题 分割广播域方法：路由器隔离（工作在网络层） / VLAN VLAN：将设备划分为与物理位置无关的逻辑组的技术 VLAN实现机制 IEEE 802.1Q帧——在MAC帧中源MAC地址后插入4字节VLAN标记 交换机收到普通的以太网帧时 插入标记 = “打标签” 转发时 可能删除 = “去标签” 交换机端口类型：（交换机各端口的缺省VLAN ID 👇称为PVID） Access——一般连接用户计算机 只能属于一个VLAN PVID与端口所属VLAN的ID同 若帧中VID与端口PVID同 则去标签并转发 否则不转 Trunk——交换机间/交换机与路由器间的互连 可以属于多个VLAN 用户可设置其PVID值 发送：对VID=PVID的帧——去标签后转发 / 不等的帧——直接转发 接收：接收未打标签的帧 根据接收帧的那个端口的VLAN打标签 Hybrid——Trunk Access能用的地方都能用 其它与trunk类似 除发送处理方法：查看帧的VID是否在端口的去标签列表中（其余同👆） 应用如下👇 网络层 实现网络互连（路由器）——数据包传输\n三个问题：向运输层提供的服务 + 网络层寻址 + 路由选择 TCP/IP协议栈的网络层使用网际协议IP so 被称为网际层 提供的服务 面向连接的虚电路服务 可靠通信由网络保证 必建立网络层的连接（虚电路VC）——通信双方沿已建立的虚电路发送分组 目的主机地址在建立后不再需要 在分组首部携带VC编号即可 存储转发方式 通信结束后 释放VC 无连接的数据报服务 因特网使用——网络造价低\n可靠通信由用户主机保证 不需建立网络层连接 每个分组可走不同路径 每个分组首部需携带目的主机的完整地址 监测到拥塞时可合理丢弃IP分组\nIPv4地址 概述 因特网上每个主机/路由器的每个接口分配全世界unique的32bit标识符\n发展：分类编址\u0026ndash;\u0026gt;划分子网\u0026ndash;\u0026gt;无分类编址 表示方法：点分十进制表示方法——每8bit分为一组 用.隔开 分类编址 五类地址👆 ABC类可分配给主机/路由器的各接口 主机号全0 = 网络地址 不能分配给主机（···） 主机号全1 = 广播地址 不能分配···——该网络上所有地址都可收到目的地址为广播地址的信息 A类：最小网络号0保留不指派 最大网络号127作为本地环回测试地址不指派 最小本地环回测试地址：127.0.0.1 （主机号不能全0全1） B类：最小网络号128.0（除首位全0）最大网络号191.255（除二位全1） C类：类似B类👆 网络号范围192~223 划分子网 子网掩码——表明IP地址的主机号中有几个比特被借走作为子网号 连续1 = 网络号（不变）+子网号（占原来主机号的位置） 连续0 = 主机号 运算即得所在子网的网络地址 默认的子网掩码：未划分子网时使用的子网掩码 eg.255.0.0.0（A类） 无分类编址 无分类域间路由选择CIDR\n编写方法：斜线记法 eg.128.14.35.7/20 20表示网络前缀所占的比特数（后面的是主机编号） 将网络前缀都相同的连续的IP地址组成CIDR地址块 聚合C类网数量 = 地址数量 / C类网前缀数量 $2^8$ 主机号依然不可全0全1\n路由聚合（构造超网）——eg. 一个路由可以保存其连接的网络的地址的共同前缀 发送给其他路由 = 路由聚合后的目的网络地址（主机号设为0） IPv4地址的应用规划 定长的子网掩码FLSM：用同个子网掩码划分子网 每个子网需要的IP地址数量不同时 会造成浪费 变长的子网掩码VLSM：不同子网掩码划分——每个子网分配的IP地址数量不同 起点位置选择子网中块数量（初步分配的地址数量eg.6台主机+1路由器地址+1广播1网络=9 则选16）的整数倍 可以从主机多的子网开始分 IP数据报的转发与发送 =主机发送+路由器转发 以下忽略ARP与以太网交换机的工作过程\n数据报传递方式：直接交付（以太网交换机可交付） \u0026amp; 间接交付（需路由器中转） 主机发送过程：主机A将自己的IP与子网掩码做\u0026amp;运算，得到网络地址—-\u0026gt;将目标IP与子网掩码\u0026amp; 若网络地址不同\u0026ndash;\u0026gt;需要路由器转发（不在同一子网） how主机知道路由器？ 给每个主机设置默认网关 即对应路由器的IP地址 路由器转发过程：检查IP数据包首部是否出错（差错校验）（错则丢弃并通知源主机）\u0026ndash;\u0026gt;根据数据报的目的地址在路由表中查找匹配条目（与路由条目中的地址掩码\u0026amp;，检查网络号是否匹配）\u0026ndash;\u0026gt;转发 若不匹配则丢弃并通知源主机 采用最长前缀匹配 注意：广播数据报路由器不会转发（隔离广播域） 静态路由配置及路由环路问题 静态路由配置：人工配置路由表（指定目的网络地址与下一跳的接口） 不能及时适应网络状态（拓扑 流量等）的变化 可能导致路由环路的原因： 配置错误 聚合了不存在的网络 网络故障 特殊概念 默认路由：具有相同下一跳的不同目的网络的路由条目 可以将目的网络写作0.0.0.0/0（静态） 其它的所有目的网络都转向此接口 特定主机路由：设置目的网络地址为目的主机的IP 子网掩码有32位1（静态） 下一跳还是在特定主机连接的路由器接口 可能的路由环路 配置错误（配置了循环的下一跳接口）：IP数据报首部设置生存时间TTL 进入路由器后减一 若某次进入后TTL=0 则丢弃 聚合不存在的网络（本应将错误IP丢弃）：可添加针对不存在的网络的黑洞路由 即下一跳设置为null0 网络故障（某IP地址的网络出现故障 路由器自动丢弃对应路由表条目）：添加针对该网络的黑洞路由 路由选择协议 概述 静态路由选择：人工配置——小规模网络 不能及时适应网络状态变化 动态路由选择：自动获取路由信息（by路由选择协议） 特点与👆反 因特网路由选择协议特点：自适应（动态） + 分布式（路由器间交换路由信息） + 分层次（因特网划分为许多较小的自治系统AS） 因特网的分层次路由选择协议：（网关 = 路由） 自治系统内部采用内部网关协议IGP AS间采用外部网关协议EGP 常见的内部网关协议： 路由信息协议RIP——基于距离向量 内部网关路由协议IGRP——基于距离向量 增强型内部网关路由协议EIGRP——结合距离向量与链路 开放式最短路径优先OSPF——基于链路 中间系统到中间系统IS-IS——基于链路 常见EGP：边界网关协议BGP 路由器基本结构：路由选择部分（周期性与其它路由器交流并更新） + 分组转发部分 转发表from路由表 路由报文可更新路由表 具有输入输出缓冲区 RIP 最先得到广泛使用的IGP 用UDP协议直接封装报文 后由IP协议封装\n要求：AS内每个路由器维护自己到其它每个网络的距离记录——距离向量D-V（一组距离） 用跳数Hop Count作为度量 直连网络\u0026ndash;路由器 = 1；非直连网络\u0026ndash;路由器 = 经过的路由器数+1 一条路径最多15个路由器 = 只适用小型互连网 特点： 若有多条距离相等的路由 可进行等价负载均衡 包含要点：仅与相邻路由器交换信息 + 交换路由表 + 周期性交换 基本工作过程 = 路径规划（收敛则找到最短路径）\n更新规则：判断到达网络是否更新\u0026ndash;\u0026gt;下一跳是否相同\u0026ndash;\u0026gt;相同时更新消息 不同时比较路径长短 等于时添加做负载均衡 问题：“坏消息传得慢”（发生故障后👇） = 路由环路/距离无穷计数问题 D-V算法固有问题 减少问题的措施：限制最大路径距离 路由表发生变化时就发送更新报文（触发更新） 不让同一路由信息通过此接口反向传送（水平分割） OSPF 采用Dijkstra提出的SPF（最短路径算法） 基于链路 + 不会产生路由环路 + 不限制网络规模 收敛快 实现： 通过交互问候（Hello）分组 维护邻居关系 封装在IP数据报中 发往组播地址224.0.0.5 每个路由器产生LSA链路状态通告 包括直连网络链路状态信息 \u0026amp; 邻居路由器的 被封装在链路状态更新分组LSU中 洪泛法发送 每个路由器用LSDB链路状态数据库存储LSA 通过洪泛法 最终所有路由器的LSDB一致 基于LSDB进行SPF计算 构建路由表 五种分组类型：Hello 数据库描述 链路状态请求 链路状态更新 链路状态确认 周期时间/更新信息/回应其它路由器请求时 发送链路状态更新分组 多点接入网络中：选举指定路由器DR \u0026amp; 备用的指定路由器BDR 所有的非DR BDR只与其建立邻居关系 将一个AS划分为若干的区域 有自己的标识符 所有接口在区域内 = 区域内路由器IR 区域边界路由器ABR 与其他区域联通（两接口 一对外一对内） 主干路由器BBR 主干区域内的路由器 自治系统边界路由器ASBR 与其它自治系统交换信息 BGP 自治系统内度量采用的代价不同 故自治系统间不可用代价作为度量\n每个AS需有至少一个BGP发言人 不同AS的发言人交换路由信息前需建立TCP连接 端口号179 交换BGP报文以建立BGP会话 以此交换路由信息 交换网络可达性信息 后找出到达各AS较好的路由——无环连通图 四种报文（BGP-4）：打开 更新 保活 通知 IPv4数据报首部格式 IP数据报\n固定部分20字节 + 可变部分40字节 固定部分中每个区域都以4字节为单位（要么4要么8要么····） 解释： 版本：通信双方采用的IP协议版本必相同 首部长度：最小取值为5（仅有20字节固定部分） 最大15（20固定+40可变） 可选字段：长度1字节~40字节 填充字段：确保首部长度为4字节的整数倍 区分服务：区分不同等级的服务质量 总长度 = 首部 + 数据载荷 解释：根据以太网MTU将数据载荷分片以封装成帧 标识：同一数据报的各分片应具相同标识 标志：3bit DF位（1不许分片 0允许分片） MF位（1后还有分片 0此为最后分片） 保留位（必为0） 片偏移：分片数据报的数据载荷相对原数据报偏移的单位（以8字节为单位表示 eg.偏移32个字节则在此写4） 解释： 生存时间TTL：原来以秒为单位 现在以跳数为单位 （路由器转发时减一若为0则丢弃 协议：指明数据部分是哪种协议单元（ICMP-1 IGMP-2 TCP-6 UDP-17 IPv6-41 OSPF-89） 首部检验和：差错检查 比CRC简单 = “因特网检验和” IPv4所有路由器都要检查 IPv6不再检查 网际控制报文协议ICMP 更有效地转发IP数据报 提高交付成功地机会\n特点：主机/路由器用ICMP发送差错报告报文\u0026amp;询问报文 + 被封装在IP数据报中 差错报告报文 终点不可达：不能交付数据报 向源点发送 源点抑制：路由器/主机由于拥塞丢弃数据报 向源点发送（源点发送速率放慢） 时间超过：TTL 丢弃时向源点发送 分片不完整时 全部丢弃 参数问题：首部中检验与字段发现误码 改变路由（重定向）：路由器将改变路由报文发送给主机 不发送的情况：对ICMP差错报文不发 第一个分片的后续报片 具有多播地址的数据报 特殊地址（127.0.0.0等） 询问报文 回送请求与回答——测试目的站是否可达（收到的主机必须回答） 时间戳请求和回答——时钟同步 测量时间 应用 分组网间探测PING（packet Internet groper） 应用层直接使用网际层的ICMP 不通过运输层的TCP or UDP 跟踪路由traceroute 测试IP数据报从源主机到目的主机经过哪些路由器（原理：时间超过差错报告） 应用层直接使用网际层的ICMP 不通过运输层的TCP or UDP Unix中在运输层使用UDP 虚拟专用网VPN网络地址转换NAT VPN virtual private network VPN中各主机分配的地址是某机构可自由分配的专属地址（IPv4地址紧缺） “IP隧道技术” 分类：内联网VPN \u0026amp; 外联网VPN NAT network address translation 使用内部专用地址的专用网络用户共享少量外部全球地址以访问因特网 过程：NAT路由器为发送端分配一个全球IP地址 并修改数据报的源地址 并记录内外网地址对应关系 可以将运输层端口号与IP一起转换=一个全球IP地址可使多个（内部）主机与外通信 IP地址同 端口号不同 网络地址源端口号转换NAPT else：外网主机不能首先发起通信（NAT屏蔽了内网主机的网络地址）——NAT穿越技术 运输层 运输层概述 提供面向连接的TCP \u0026amp; 无连接的UDP 运输应用进程 不同进程用不同端口接收（非物理意义上的端口） 运输层端口号 复用 分用 端口号 需用统一方法对TCP/IP体系的应用进程标识——端口号区分（16比特） 端口号只具有本地意义——本计算机应用层的各进程 熟知端口号 登记端口号 短暂端口号 发送方复用 接收方分用 应用报文（不同端口）\u0026ndash;\u0026gt;UDP复用/TCP复用\u0026ndash;\u0026gt;用户数据报（UDP封装）/报文段（TCP封装）\u0026ndash;\u0026gt;IP复用 成为IP数据报\u0026ndash;\u0026gt;接收方对IP分用成用户数据报/报文段\u0026ndash;\u0026gt;分用成应用报文 应用层的不同协议在运输层使用不同协议的不同端口号（eg.http-\u0026gt;TCP 80 https-\u0026gt;TCP 443） 在网络层都使用IP协议 UDP TCP对比 UDP 用户数据报协议——无连接（过程） 支持单播多播广播 对应用层报文不合并不拆分 误码 丢失不处理 数据报首部仅8字节 TCP 传输控制协议——三报文握手建立连接 四报文挥手释放连接 仅支持单播 面向字节流 不保证传输的数据大小完全一致（交付时不检查传输了多少数据） 不会误码 丢失等 TCP流量控制 让发送方发送速率不过快 来得及接收——滑动窗口实现\n普通的滑动窗口算法（类帧） 接收方发送ACK ack=n表示n之前的数据已收到 设置零窗口持续计时器——到时时向接收方发送零窗口探测报文段 得到窗口大小 TCP拥塞控制 理想的拥塞控制——网络吞吐量=输入负载 输入负载过高 吞吐量不变 无拥塞控制时 输入负载过大吞吐量反而减小 方法 维护拥塞窗口变量——超时重传时判定为网络拥塞 发送方将拥塞窗口作为发送窗口\n维护慢开始门限ssthresh状态变量——大于拥塞窗口时 采用慢开始算法 小于时采用拥塞避免算法 等于时均可使用 不拥塞时拥塞窗口增大 拥塞时减小 慢开始算法：每接到一个确认 指数级增大窗口 拥塞避免算法：窗口只加一 若超时重传——慢开始门限设为一半 窗口设置为1 快重传算法：（尽快重传）发送方收到三个连续的重复确认就重传 接收方立即发送确认 收到失序报文段立即发出重复确认 部分丢失不会认为是拥塞\n快恢复算法：收到3个重复确认后执行 发送方将慢开始门限与拥塞窗口调整为当前窗口的一半 执行拥塞避免 TCP超时重传时间的选择 略大于往返时间\n利用每次的往返时间RTT样本 计算加权平均往返时间👇 超时重传时间RTO：$RTO=RTT_S+4*RTT_D$ $RTT_D$ RTT偏差的加权平均👇 （针对超时重传时测不准RTT问题）Karn提出不采用超时重传的RTT样本 时延突然增大——修正：出现超时重传时$RTO$变为原来2倍 TCP可靠传输实现 以字节为单位的滑动窗口实现——类似报文段（不赘述）\n发送方窗口大小根据接收方确定 但同时刻不一定总一样大 TCP未明确规定如何处理不按序到达的数据 通常先临时存放 收到缺失的数据时再按序交付（应用进程） 接收方必须有累计确认\u0026amp;稍待确认 全双工通信 TCP运输连接管理——连接建立 解决的问题：确知对方存在 + 协商参数 + 分配运输的实体资源 具体过程 三报文握手\nTCP服务器被动等待TCP客户的连接请求 客户主动发起连接请求 过程： TCP服务器创建传输控制块 从关闭状态进入监听状态——被动打开连接 客户创建传输控制块 向服务器发送连接请求报文段 进入同步已发送状态 SYN=1 seq=x 表示其为连接请求报文段 不能携带数据——主动打开连接 服务器发送对TCP连接请求的确认 进入同步已接受状态 SYN=1 ACK=1 ack=x+1 seq=y 也不能携带数据 客户发送对确认的确认 进入连接已建立状态（数据load部分可以携带请求内容） ACK=1 seq=x+1 ack=y+1 服务器接收后 进入连接已建立状态 客户与服务器的seq由各自决定 但ack序号与对方的seq有关（+1） 不能两握手的原因：避免失效的连接请求报文段传输到服务器（服务器直接开启连接已建立状态 但客户不会理睬 浪费资源） 连接释放 四报文挥手\n过程： 客户发送连接释放报文段 进入终止等待1状态——主动关闭 FIN=1 ACK=1 seq=u ack=v seq是客户发送的最后字节序号+1 ack是客户收到的（服务器发送的）最后字节序号+1 服务器发送普通确认报文段 进入关闭等待状态 并通知上层应用 ACK=1 seq=v ack=u+1 ——此时进入半关闭状态 客户不发送只接受 服务器继续发送没有发完的数据 服务器发送连接释放报文段 进入最后确认状态（应用数据发完 让其关闭）——被动关闭 FIN=1 ACK=1 seq=w ack=u+1 seq表示服务器自己发送的最后数据 ack是对客户发来的信息的重复确认 客户发送普通确认报文段 进入时间等待状态 ACK=1 seq=u+1 ack=w+1 seq要消耗一个序号 服务器接收后进入关闭状态 客户发送后经过2MSL时间进入关闭状态 MSL——最长报文段寿命 若客户直接关闭 确认报文段若遗失 服务器无法关闭 保活计时器：服务器每收到一次客户数据就重重启保活计时器——若保活周期内未收到 则发送探测报文段——连续发送探测不回复 则服务器关闭连接 TCP报文段首部格式 固定首部20字节 + 扩展（可变）首部最大40字节 组成： 源端口——16bit 标示 发送 报文段的 应用进程 端口号 目的端口——16bit 接收报文段的应用进程端口号 序号——32bit 本报文段数据load的第一个字节序号 确认号——32bit 若为n 表示n-1号及以前的数据都接收 需要n号数据 *ACK位为1时才有效 数据偏移——数据load起始处到报文段起始处有多远 = TCP报文段首部长度（以4字节为单位） 窗口——发送方的接收窗口大小 流量控制 校验和——检查首部与数据load（计算时要在报文段前加12字节伪首部） SYN同步标志位 终止标志位FIN 复位标志位RST（复位TCP连接）——取1时 表示TCP连接出现异常 需重新建立连接 可用来拒绝非法报文段 拒绝打开TCP连接 推送标志位PSH：若为1 该报文段会尽快上交应用进程 紧急功能：紧急标志位URG（取1有效）+紧急指针（指明紧急数据长度） = 紧急数据放到发送缓存最前 立刻封装后发送——接收缓存中同 扩展首部：选项部分可添加很多选项👇 填充部分将保证首部能被4整除 应用层 概述 最顶层\n各层应用 客户/服务器方式与对等方式 C/S方式与P2P方式 client/server \u0026amp; peer to peer\nC/S 客户计算机\u0026amp;服务器计算机\n客户请求服务 服务器提供服务 服务器始终运行 等待请求 \u0026amp; 具有固定端口号 \u0026amp; 运行服务器的主机具有固定的IP地址 服务集中型——会出现服务器跟不上客户机请求的情况——使用计算机群集（服务器场）构建虚拟服务器 P2P 对等方互为请求与服务方 双方直接通信——服务分散型 可扩展性（规模增大 性能不降低） 动态主机配置协议DHCP 通过DHCP自动获取网络配置信息 C/S类型\n用UDP用户数据报传输——计算机加入新网络时可自动获取网络配置信息 主要过程：客户寻找DHCP服务器（广播）——服务器提供IP地址租用——客户接收租约——服务器确认租约——客户对IP地址续约——客户随时解除租约 客户未获得IP地址时 使用0.0.0.0 挑选地址时 使用ARP确保挑选的地址未被占用 使用前 客户用ARP检查 DHCP中继代理：给与客户主机直接相连的路由器配置DHCP服务器的IP地址 使其成为中继代理——将寻找的数据报单播给服务器 否则会丢弃客户的寻找DHCP服务器数据报 域名系统DNS 域名便于记忆 但需用IP地址进行访问 = DNS对域名解析成目标服务器的IP地址\n采用层次结构的命名树作为域名 使用分布式的域名系统==\u0026gt;大多域名在本地解析 UDP封装 层次树状结构的域名系统 eg.···.三级域名.二级域名.顶级域名 不区分大小写 完整域名不超过255字符 特点：各级域名由上级域名管理 分类： 顶级域名TLD分类：国家 通用（com gov等） 反向域（IP地址反向解析为域名） 转换：分布在各地的域名服务器实现转换 根域名服务器 顶级域名服务器 权限域名服务器（二级三级等） 本地域名服务器（默认···） 权限域名服务器——管理某个区的域名 本地——代理作用 转发报文到其它域名服务器的等级结构 解析过程：递归查询 / 迭代查询 递归：主机-\u0026gt;本地-\u0026gt;根-\u0026gt;顶级-\u0026gt;权限-\u0026gt;反向回 迭代：主机-\u0026gt;本地-\u0026gt;返回顶级地址 主机-\u0026gt;顶级··· 主机-\u0026gt;权限 主机到本地采用递归 其余采用迭代 高速缓存：存放最近查询过的域名与IP地址——为每个项目设置计时器 超时项删除——不需DNS查询 文件传送协议FTP C/S方式 可用ftp://balabal域名访问\n提供交互式访问 允许客户指明文件类型与格式 存取权限 屏蔽系统细节 适合在异构网络任意计算机间发送文件 工作原理： 客户与FTP服务器建立传送控制命令的TCP连接（FTP端口号20） （客户告知）服务器发起传送文件的TCP连接——主动模式（数据连接）（端口号21） 客户发起传送文件的TCP连接——被动模式（数据连接）（FTP随机端口号） 电子邮件 C/S\n组成：用户代理（email客户端软件） + 邮件服务器 + 电子邮件所需协议（包括发送与接收协议） 服务器向用户发送——POP3协议（其它为SMTP） 全部建立TCP连接 常用的发送协议——SMTP 常用的接受协议——POP3 SMTP 发送方周期性扫描邮件缓存 建立TCP连接（端口号25） 发送14条SMTP命令 接收方返回21种SMTP应答 针对发送方地址 接收方地址 邮件内容 结束符等都需交互 电子邮件发送 格式：信封+内容（首部+主体） SMTP只能传送ASCII码数据——MIME多用途因特网邮件扩展 发送方非ASCII内容经过MIME转译为ASCII后给SMTP 接收方同 MIME增加了邮件首部字段 内容格式 传送编码等 也应用于HTTP 接收 常用读取协议：POP邮局协议 IMAP因特网邮件访问协议——TCP 端口POP110\u0026amp;IMAP143 IMAP4允许用户操控邮件服务器中的邮箱——联机协议 万维网email 使用HTTP协议与邮件服务器交互 万维网WWW 运行在因特网上的分布式应用 利用超链接将不同网站的网页链接\n使用统一资源定位符URL指明位置 格式：\u0026lt;协议\u0026gt;://\u0026lt;主机\u0026gt;:\u0026lt;端口\u0026gt;/\u0026lt;路径\u0026gt; 万维网文档：HTML+CSS+JavaScript——通过浏览器渲染 html超文本标记语言——网页结构与内容 css层叠样式表——审美 js脚本——控制网页行为 HTTP HTTP超文本传输协议——定义服务器怎样请求WWW文档 \u0026amp; 服务器怎样传回浏览器 HTTP/1.0采用非持续链接 每次请求文件都需建立TCP 1.1采用持续连接 非流水线方式——收到一个请求的响应后才发送下一个请求 流水线：收到响应前 可不断发送请求 请求报文格式👇：（面向文本 每个字段都是ASCII码串 长度不确定） 报文格式：状态码202——正常 400——请求错误 cookie——记录用户信息（浏览器与www服务器建立TCP） 在服务器为用户生成唯一的cookie识别码 给浏览器返回识别码 else 缓存与代理服务器——web缓存（客户机 中间系统（代理服务器）上都可） 最近的请求与响应暂存在disk ","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"所有图片来自：计算机网络微课堂（有字幕无背景音乐版），链接见文章","title":"计算机网络"},{"content":" Bi-RRT 原理 基本名词 状态空间：系统全部可能状态的集合 RRT原理 RRT(Rapidly exploring Random Tree 快速随机搜索树)是一种全局规划算法\n已知：\n初始状态（起点位置）$q_{start}$ 目标状态（终点位置）$q_{goal}$ 搜索步长 ${\\rho}$ 系统状态空间 $C$ 自由状态空间 $C_{free}$ $C_{free}{\\subset}C$，是 $C$ 中不会发生碰撞的状态集合 目标状态空间 $C_{goal}$ 有 $k$ 个节点的快速随机搜索树 $T_k$ 过程：\n生成随机点：在自由状态空间 $C_{free}$ 中随机采一个状态点 $q_{rand}$，同时保证 $q_{rand}{\\notin}T_k$ 查找最近点：遍历现有的随机搜索树 $T_k$ 寻找与 $q_{rand}$ 最近的节点 $q_{near}$，满足：$DIS(q_{near},q_{rand})\u0026lt;=DIS(q_i,q_{rand})$，其中 $q_{rand}{\\in}T_k$ 计算新节点：从 $q_{near}$ 向 $q_{rand}$ 方向拓展距离 ${\\rho}$ 得到 $q_{new}$，检查该路径是否会发生碰撞。 若会发生碰撞，返回1. 不会发生碰撞，则将 $q_{new}$ 添加到 $T_k$ 中 计算公式： $$q_{\\text {new }}=q_{\\text {near }}+\\varepsilon \\frac{q_{\\text {rand }}-q_{\\text {near }}}{\\left|q_{\\text {rand }}-q_{\\text {near }}\\right|}$$ 到达检查：若节点 $q_{new}$ 实现 $DIS(q_{new},q_{goal})\u0026lt;{\\rho}$，证明已经到达终点，添加 $q_{goal}$ 到 $T_k$ ，搜索结束。若 $DIS(q_{new},q_{goal})\u0026gt;{\\rho}$，返回1. 得到路径：从 $q_{goal}$ 开始反向回溯亲节点直到 $q_{start}$，形成完整路径 $L$ graph LR 生成随机点--\u0026gt;生成新节点 生成新节点--\u0026gt;碰撞检查 生成新节点-----\u0026gt;到达检查 到达检查--\u0026gt;|不成功|重新生成随机点 碰撞检查---\u0026gt;|不成功|重新生成随机点 碰撞检查--\u0026gt;|成功|扩展树 扩展树--\u0026gt;重新生成随机点 到达检查---\u0026gt;|成功|结束 Bi-RRT原理 从起点、终点同时开始随机搜索树的构建\n另外已知：\n从起点开始构建的随机搜索树的新节点为 $q_{new-start}$ 从终点开始构建的随机搜索树的新节点为 $q_{new-goal}$ 从起点开始构建的随机搜索树为 $T_{k-start}$ 从终点开始构建的随机搜索树为 $T_{k-goal}$ 将上文RRT构建过程的4.到达检查修改为如下检查:\n若节点 $q_{new-start}$ 实现 $DIS(q_{new-start},q_{new-goal})\u0026lt;{\\rho}$， 证明已经到达终点，添加 $q_{new-goal}$ 到 $T_{k-goal}$ ，搜索结束。若 $DIS(q_{new-start},q_{new-goal})\u0026gt;{\\rho}$，返回1. 将上文RRT构建过程的5.得到路径修改为如下过程:\n从 $q_{new-goal}$ 开始同时向起点、终点回溯亲节点直到 $q_{start}$ 与 $q_{goal}$，形成完整路径 RRT-Connect原理 与Bi-RRT大致相同\n相对于Bi-RRT，RRT-Connect虽然也是起终点同时开始两条路径，但是从起点方向生成随机点， 用终点的随机搜索树向其进行拓展，反之亦然 分析 出入 （生成随机点）程序实际在 $C$ 中随机采样，也未避免其在 $T_k$ 中；可能造成冗余，在狭窄复杂环境中可能会导致收敛速度减慢 其他问题 （生成随机点）在整个自由状态空间任何位置以相同概率生成随机点，缺少对目标点的指向性 （计算新节点）任何节点的拓展距离都相同，缺少空间敏感性 eg.在空旷位置可以适当增长拓展距离 （计算新节点）遇到障碍时回退到1.生成随机点，可以考虑不回退，通过更换方向避障 （到达检查）用 $DIS(q_{new},q_{goal})\u0026lt;{\\rho}$ 进行到达检查，可能在终点 附近需要不同的标准 改进点 （生成随机点）引入人工势场/其他方法提高随机点指向性 \u0026amp; 在自由状态空间中生成随机点 （查找最近点）最近点的度量方式在基础算法中是最基础的几何距离，可以更改度量方式 剪枝处理——生成的路径有较多折角与累赘路径，可进行剪枝处理 对得到的路径 $L$，从 $q_{goal}$（视为当前起始点 $q_{now}$）开始分别与其后的节点连接并进行碰撞检查 若在连接 $q_{now}$ 与某节点 $q_{collision}$ 时发生碰撞，回退到 $q_{collision}$ 的亲节点 $q_{no-collision-near}$， 并连接 $q_{now}$ 与 $q_{no-collision-near}$ 形成新路径的一部分 从 $q_{no-collision}$ 开始重复3.1.，直到某个 $q_{now}$ 连接到 $q_{goal}$ （到达检查）根据实例对到达检查精度进行修改 路径折角多，可通过样条曲线对路径进行光顺 \u0026amp; 生成路径时进行转角优化 源码中转角通过角度常量进行简单约束，可考虑结合运动方程 实现 生成随机点 def get_random_node(x_min, x_max, y_min, y_max, goal_point=None): # 此处在目标点方向增加生成概率 if goal_point is not None and random.random() \u0026lt;= 0.2: x = goal_point[0] y = goal_point[1] else: x = random.uniform(x_min, x_max) y = random.uniform(y_min, y_max) rnd_node = Node(x, y) return rnd_node 查找最近点 def get_nearest_node_index(node_list, rnd_node): dlist = [] # 遍历随机搜索树 for node in node_list: dis = calc_p2p_dis(node, rnd_node) dlist.append(dis) minind = dlist.index(min(dlist)) # 返回距离最近的点 return minind 计算新节点 def generate_new_node(nearest_node, random_node, extend_length): new_node = Node(nearest_node.x, nearest_node.y) d = math.sqrt((random_node.x - nearest_node.x) ** 2 + (random_node.y - nearest_node.y) ** 2) if extend_length \u0026gt; d: extend_length = d dx = random_node.x - nearest_node.x dy = random_node.y - nearest_node.y if dx * dx + dy * dy == 0: return random_node # 新节点计算公式 new_node.x += extend_length / math.sqrt(dx * dx + dy * dy) * dx new_node.y += extend_length / math.sqrt(dx * dx + dy * dy) * dy # 建立节点的连接（亲节点） new_node.parent = nearest_node return new_node 碰撞检查（圆形/矩形障碍物） def check_collision(node1, node2, obstacleList): for [ox, oy, size] in obstacleList: round = Node(ox, oy) # 增加障碍物的半径为size_new 避免实际情况下的碰撞 size_new = size if node2 is None: return False if calc_p2p_dis(node1, round) \u0026lt;= size_new: return True # 发生碰撞 if calc_p2p_dis(node2, round) \u0026lt;= size_new: return True # 若点线距小于“半径”且该线段可能出现在圆内 if calc_p2l_dis(node1, node2, round) \u0026lt;= size_new and calc_triangle_deg(node1, round, node2) \u0026lt;= 90 and \\ calc_triangle_deg(node2, round, node1) \u0026lt;= 90: return True elif len(obstacle) == 4: # 矩形障碍物用内置函数判断 rect_shape = box(obstacle[0], obstacle[1], obstacle[2], obstacle[3]) if not isinstance(node1, list): line = LineString([(node1.x, node1.y), (node2.x, node2.y)]) else: line = LineString([(node1[0], node1[1]), (node2[0], node2[1])]) if line.intersects(rect_shape): return True return False # 不碰撞 Bi-RRT到达检查与路径生成 # 每次生成一轮（两个）新节点后都对整个路径进行遍历，检查两个路径中可否各有一个点相连生成路径 for node1 in node_list1: for node2 in node_list2: if calc_p2p_dis(node1, node2) \u0026lt;= extend_length and \\ check_collision(node1, node2, obs_list) == False: # 生成从起点到相交点的路径 path1 = [] node = node1 while node is not None: path1.append([node.x, node.y]) node = node.parent path1.reverse() # 反转路径，使其从起点开始 # 生成从终点到相交点的路径 path2 = [] node = node2 while node is not None: path2.append([node.x, node.y]) node = node.parent # 合并两条路径 path = path1 + path2 此处可以优化为只用新生成的点来试验能否连上（已完成 与上文程序类似 省略）\n剪枝 def prune_path(path, obs_list): pruned_path = [path[0]] i = 0 while i \u0026lt; len(path) - 1: found = False # 从终点开始验证 找到第一个不碰撞的（反之有漏洞 for j in range(len(path) - 1, i, -1): if not check_collision(path[i], path[j], obs_list): pruned_path.append(path[j]) # 更新起点 i = j found = True break if not found: # 确保路径前进 i += 1 if pruned_path[-1] != path[-1]: pruned_path.append(path[-1]) return pruned_path 效果 单向RRT\u0026amp;不剪枝\n单向RRT\u0026amp;剪枝\n双向RRT\u0026amp;剪枝\n适用 基于随机采样的树形路径规划算法\n适用于非凸高维状态空间 \u0026amp; 动态环境 可以快速生成可行路径 容易处理包含障碍物、差分运动约束的场景 差分运动约束——每个约束条件由其中两个变量作差构成 需得出满足所有约束条件的解 无需梯度信息 适用未知环境（目标函数未知） Bi-RRT* 原理 在Bi-RRT的基础上增加重写（rewrite）与重布线（rewire）功能\n另外已知：\n生成的随机点 $q_{rand}$ 随机搜索树上距离随机点最近的树节点 $q_{near}$ 从树节点延伸出来的新节点 $q_{new}$ 重写操作搜索范围 $R_{write}$ 重布线操作搜索范围 $R_{wire}$ 随机搜索树上每个节点 $q$ 关联的成本 $C(q)$，定义为： $$C(q)=C(q_{parent})+DIS(q_{parent},q)$$ 过程：\n重写Rewrite 潜在亲节点集合：在Bi-RRT方法的步骤3.计算新节点确认 $q_{new}$ 有效性后，在以 $q_{rand}$ 为圆心， $R_{write}$ 为半径的范围内寻找随机搜索树 $T_k$ 上所有节点，并将节点集合视为 $q_{rand}$ 潜在的亲节点集合 $Q_{near}$ 更新亲节点：计算通过 $Q_{near}$ 中每个亲节点到 $q_{new}$ 的成本 $C(Q_{new})$ 选择成本最小的节点为 $q_{new}$ 的新亲节点，更新 $T_k$。即满足： $$C\\left(q_{\\text {new }}\\right)=\\min \\left{C\\left(q_{\\text {near }}\\right)+\\operatorname{DIS}\\left(q_{\\text {near }}, q_{\\text {new }}\\right) \\mid q_{\\text {near }} \\in Q_{\\text {near }}\\right}$$ 重布线Rewire 计算成本：重写Rewrite的2.操作后，以 $q_{new}$ 为圆心， $R_{wire}$ 为半径的范围内寻找随机搜索树 $T_k$ 上所有节点 $Q_{near}\u0026rsquo;$，逐个比较将这些节点的亲节点设置为 $q_{new}$ 的成本与原成本 $C(q_{near}\u0026rsquo;)$ 更新亲节点：满足下式时将 $q_{near}\u0026rsquo;$ 的亲节点更新为 $q_{new}$： $$C(q_{new})+DIS(q_{new},q_{near}\u0026rsquo;)\u0026lt;C(q_{near}\u0026rsquo;) \\mid q_{{near}}\u0026rsquo; \\in Q_{{near}}\u0026rsquo;$$ 继续Bi-RRT的4. 5.步骤 分析 优化 相比Bi-RRT，以每个新节点为中心，在小区域内更新亲节点选择最优情况（以新节点为主要优化对象），放大到全路径实现整体优化 改进方案 更新成本函数定义，可以引入外部变量对成本进行把控 搜索区域范围大小可更新，搜索区域形状等也可根据实际需要具体调整 RRT算法对障碍物的动态、静态并无要求，只通过避碰函数进行障碍物判断（其他时候无影响），可以引入动障碍进行试验 实现 重写Rewrite\ndef rewrite_index(node_new, node_list, obstacle_list): r = 8 # 搜索范围 min_cost = float(\u0026#39;inf\u0026#39;) min_node_index = None for i, node in enumerate(node_list): # 确定潜在亲节点集合 if calc_p2p_dis(node_new, node) \u0026lt; r and not check_collision(node_new, node, obstacle_list): # 计算成本函数 potential_cost = node.cost + calc_p2p_dis(node_new, node) # 根据成本函数更新亲节点索引 if potential_cost \u0026lt; min_cost: min_cost = potential_cost min_node_index = i return min_node_index 重布线Rewire\ndef rewire(node_new, node_list, obstacle_list): r = 30 # 搜索范围 for node in node_list: # 排除node_new的亲节点 if node != node_new.parent and calc_p2p_dis(node_new, node) \u0026lt; r: potential_cost = node_new.cost + calc_p2p_dis(node, node_new) # 根据成本函数更新亲节点 if potential_cost \u0026lt; node.cost and check_collision(node, node_new, obstacle_list) is False: # if potential_cost \u0026lt; node.cost: node.parent = node_new node.cost = potential_cost 效果 Bi-RRT*\n相较Bi-RRT，路径折角减少，优化效果较为明显 Bi-RRT*加剪枝\n相较Bi-RRT加剪枝，明显减少路径节点，路径更简单 适用 解决RRT难以求解最优的可行路径的问题\n引入路径成本 通过最小化路径成本提升路径质量 渐进地向全局最优解收敛 Bi-RRT*+DWA DWA原理 引入机器人运动方程 相当于对机器人运动路径的模拟\n已知变量 假设为全向移动机器人 机器人移动速度：$v_x, v_y$ 速度空间：$v, \\omega$，以下列出可能限制速度的因素： 自身能到达的所有矢量速度： $$ V_{\\mathrm{s}}=\\left{(v, \\omega) \\mid v \\in\\left[v_{\\min }, v_{\\max }\\right] \\wedge \\omega \\in\\left[\\omega_{\\min }, \\omega_{\\max }\\right]\\right} $$ 受电机性能影响——设定加速度的最大最小值（包括刹车）后在一定时间内能到达的速度： $$V_d=\\left{(v, \\omega) \\mid v \\in\\left[v_c-\\dot{v}_b \\Delta t, v_c+\\dot{v}_a \\Delta t\\right] \\wedge \\omega \\in\\left[\\omega_c-\\dot{\\omega}_b \\Delta t, \\omega_c+\\dot{\\omega}_a \\Delta t\\right]\\right}$$ 障碍： $$V_a=\\left{(v, \\omega) \\mid v \\leq \\sqrt{2 \\operatorname{dist}(v, \\omega) \\dot{v}_b} \\wedge \\omega \\leq \\sqrt{2 \\operatorname{dist}(v, \\omega) \\dot{\\omega}_b}\\right}$$ 评价函数： $$G(v, \\omega)=\\sigma(\\alpha * \\operatorname{heading}(v, \\omega)+\\beta * \\operatorname{dist}(v, \\omega)+\\gamma * \\operatorname{vel}(v, \\omega))$$ $heading(v,\\omega)$ 方位角评价函数——轨迹末端朝向与目标点间的角度差距 $dist(v,\\omega)$ 距离评价函数——路径末端与最近障碍物的距离 $velocity(v,\\omega)$ 当前机器人的线速度 $\\alpha \\beta \\gamma \\sigma$为权重系数 原理 速度空间动态窗口：在受限制的速度空间内进行采样，选择不同的$v,\\omega$ 在一定时间段内根据运动学模型可生成多种轨迹 评价函数选择路径：通过评价函数对所有可能轨迹打分 选择最优路径 Bi-RRT*+DWA原理 根据已知障碍物通过Bi-RRT*方法生成路径 机器人沿路径开始运动，选择$\\Delta t$，对机器人前方$\\Delta L$长度的路径进行碰撞检测 若碰撞检测通过，不采用DWA方法；若不能通过，进入DWA状态进行动态障碍物避碰 DWA避碰状态下，以最近的路径点为goal，并不断更新，直到进入到达域 分析 剪枝后的路径进行dwa优化效果更好 否则每个目标点寻找的耗时长\n运动方程：以上机器人运动方程需要用水下机器人的运动方程进行优化，影响速度、角速度的因素可以根据水下机器人的转角限制、运动限制等进行限定 障碍物限定条件：速度限定中，受障碍物影响的限定方程现在采用最简单的$x=\\frac{1}{2}av^2$，可以根据实际情况进行优化，也可以考虑结合check-collision函数 评价函数：评价函数暂时选择方位角、与最近障碍物的距离与线速度三方面进行评价，可以考虑引入其它物理量并对权重系数通过相关公式等进行优化 算法结合：两算法可以通过其它方法进行结合 也可以根据其它物理量的评价（如与障碍物的距离）决定当前情况是否引入DWA/退出DWA 参数优化：根据机器人实际情况调整相关参数（如最大速度等） 实现 计算动态窗口\nVs = [self.config[\u0026#39;min_speed\u0026#39;], self.config[\u0026#39;max_speed\u0026#39;], -self.config[\u0026#39;max_yawrate\u0026#39;], self.config[\u0026#39;max_yawrate\u0026#39;]] Vd = [x[3] - self.config[\u0026#39;max_accel\u0026#39;] * self.config[\u0026#39;dt\u0026#39;], x[3] + self.config[\u0026#39;max_accel\u0026#39;] * self.config[\u0026#39;dt\u0026#39;], x[4] - self.config[\u0026#39;max_dyawrate\u0026#39;] * self.config[\u0026#39;dt\u0026#39;], x[4] + self.config[\u0026#39;max_dyawrate\u0026#39;] * self.config[\u0026#39;dt\u0026#39;]] dw = [max(Vs[0], Vd[0]), min(Vs[1], Vd[1]), max(Vs[2], Vd[2]), min(Vs[3], Vd[3])] return dw 评估函数计算并选出最优路径\nx_init = x[:] min_cost = float(\u0026#34;inf\u0026#34;) best_u = [0.0, 0.0] best_trajectory = np.array(x) # evaluate all trajectory with sampled input in dynamic window for v in np.arange(dw[0], dw[1], self.config[\u0026#39;v_reso\u0026#39;]): for y in np.arange(dw[2], dw[3], self.config[\u0026#39;yawrate_reso\u0026#39;]): trajectory = self.calc_trajectory(x_init, v, y) to_goal_cost = self.calc_to_goal_cost(trajectory, goal) speed_cost = self.config[\u0026#39;speed_cost_gain\u0026#39;] * (self.config[\u0026#39;max_speed\u0026#39;] - trajectory[-1, 3]) ob_cost = self.calc_obstacle_cost(trajectory, obstacles) final_cost = to_goal_cost + speed_cost + ob_cost if min_cost \u0026gt;= final_cost: min_cost = final_cost best_u = [v, y] best_trajectory = trajectory return best_u, best_trajectory 运动学方程\nx[2] += u[1] * self.config[\u0026#39;dt\u0026#39;] x[0] += u[0] * np.cos(x[2]) * self.config[\u0026#39;dt\u0026#39;] x[1] += u[0] * np.sin(x[2]) * self.config[\u0026#39;dt\u0026#39;] x[3] = u[0] x[4] = u[1] return x 效果 避障 完整规划 ","permalink":"https://Sattiluvcat.github.io/en/posts/else/bi-rrt/","summary":"关于Bi-RRT的改进，包括与DWA结合的方法","title":"Bi-RRT及改良"},{"content":" 概要 产品原型：展示项目的业务功能\n技术选型： 前端已完成 知识点 JavaScript 三种变量：var——全局\u0026amp;可变 let——局部\u0026amp;唯一 const——全局\u0026amp;不可变 特殊运算符：==不同类型进行类型转换后再比较 ===（全等）不进行类型转换即比较（不同类型必报错） 类型转换： 除0与NaN转换为false外其它全为true 除空字符串转为false外均为true parseInt转换为int类型 JSON格式：先属性后函数 else——XHR xml http request Maven java项目管理与构建 基于项目对象模型POM\n作用 依赖管理：管理项目依赖的资源——jar包 避免版本冲突 pom.xml中配置依赖信息dependency（会指明存储地址） maven_repo作为本地仓库可查看已有的依赖信息 中央仓库 统一项目结构：不同IDE下项目结构都标准统一 项目构建：跨平台eg.Linux-Windows自动化项目构建 编译、测试等功能在maven中已集成为插件 流程 创建maven模块\n坐标：组织名groupId-模块名artifactId-版本号version ——唯一定义资源位置 组织名：通常域名反写 模块名：通常项目名称 编译后产生target文件夹 存放字节码 导入Maven项目——右侧栏Maven项添加对应项目的pom.xml 依赖管理 依赖配置——dependency指明组织名 模块名 版本 依赖传递——直接/间接依赖 可通过exclusion排除被传递来的依赖 依赖范围——默认在主程序main、测试程序test、参与打包运行package范围内均有效 可通过scope指定范围（与坐标并列）eg.test/provided（主+测）/runtime（测+包） 生命周期——三套 同一套生命周期中 有先后顺序 在前的先运行 clean 清理 default 核心工作（调试 测试等） site 生成报告 发布站点 分模块开发 将工具类、实体类等拆分为单独的模块——需要调用时引入该模块 继承与聚合 继承：定义parent工程——引入公共依赖 子工程使用parent parent工程设置打包方式（使用）packaging为pom 只能单继承 但可以多层继承 继承——版本锁定：parent工程中锁定依赖的版本（但并不引入） 需要引入依赖的子工程无需指定版本号 运用dependencyManagement进行版本指定（确定坐标） parent工程中可以用：(方便在统一位置查看) \u0026lt;something.version\u0026gt;*.*.**\u0026lt;/something.version\u0026gt; 定义版本 something下\u0026lt;version\u0026gt;${something.version}\u0026lt;/version\u0026gt;调用 聚合：问题——拆分出来的类在main打包前需要全部先install到本地 解决：创建聚合工程（= parent工程）——不包含业务功能 只有一个pom modules \u0026amp; module关键字指定所有需要一起打包的模块 指定顺序无影响 格式：\u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; 私服 局域网内的仓库\n步骤：maven——conf——settings.xml\nsevers标签配置私服访问用户\u0026amp;密码 \u0026lt;server\u0026gt; \u0026lt;!-- 还有maven-snapshots也需要配置 --\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;username\u0026gt;satti\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;something\u0026lt;/password\u0026gt; \u0026lt;/server\u0026gt; mirrors\u0026amp;profiles标签配置连接私服访问地址 \u0026lt;mirror\u0026gt; \u0026lt;!-- 若配置过aliyun镜像 需先将其去掉 --\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-public\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;allow-snapshots\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-public\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-public/\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;/profile\u0026gt; pom文件中配置上传url地址 \u0026lt;distributionManagement\u0026gt; \u0026lt;!-- release版本的发布地址--\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;maven-releases\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-releases/\u0026lt;/url\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!-- snapshot领本的发布地址: --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;id\u0026gt;maven-snapshots\u0026lt;/id\u0026gt; \u0026lt;url\u0026gt;http://192.***.***.***:****/repository/maven-snapshots/\u0026lt;/url\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;/distributionManagement\u0026gt; 通过生命周期deploy上传到私服 之后可以直接从私服中下载依赖（之前上传的模块） SpringBoot 自动进行请求响应：@RequestMapping即可 保证形参与在PostMan中的定义名称相同 不可保证的变量前添加@RequestParam(name=\u0026quot;\u0026quot;,require=false)前缀 require=false表示不一定需要此变量 传递参数过多时可将其封装到某实体类中——形参为该类 自动进行类型转换 SpringBootWeb 基本内容 SpringBootApplicaton启动类——通过其运行整个程序 配置文件：main——resource——application.properties 实现 请求处理类 类前注明@RestController 处理请求的方法前注明@RequestMapping(\u0026quot;/something\u0026quot;) http协议 Hyper Text Transfer Protocol超文本传输协议 规定浏览器vs服务器的数据传输规则\n特点： 基于TCP协议——安全 基于请求-响应模型——一次请求得一次响应 无状态协议——每次请求相互独立（多次请求不能共享数据 but 快） 请求协议：请求行 + 请求头（+ 请求体） 请求行（第一行） = 请求方式 + 资源路径 + 协议 请求头：(格式key: value) 常用：Host（主机名）User-Agent（浏览器版本） 请求参数（JSON格式）——GET存放在请求行中 POST在请求体中 响应协议：响应行 + 响应头（+ 响应体） 响应行：协议 + 响应状态码 + 描述 状态码：1**——响应中 2**——成功 3**——重定向 4**——客户端错误 5**——服务器错误 客户端错误——eg.请求不存在的资源404/未被授权403/语法错误400 服务器错误——eg.程序抛出异常 响应头：(格式key: value) eg.Content-Encoding响应压缩算法 如gzip 响应体：存放请求参数 协议解析 TomCat 轻量级web服务器\nweb服务器：对http协议操作进行封装 \u0026amp; 部署web项目 对外提供网上信息浏览服务 安装目录： bin——可执行文件 work——工作目录 lib——依赖的jar包 webapps——部署项目 程序简单解析 starter——起步依赖 springboot有内嵌tomcat 请求响应 架构： BS Browser/Server 浏览器/服务器架构 CS Client/Server 客户端/服务器架构（需安装） postman——接口测试 统一接口（返回值） 对所有类型都适配 主题内容包括code（响应码）+msg+data（返回数据） public static Result success(Object data){ //外部定义code msg data（Object类型） return new Result(1,\u0026#34;success\u0026#34;,data); } 分层解耦 web开发三层架构 controller控制层——接收前端请求并处理响应 service业务逻辑层——具体逻辑 dao数据访问层（data access object持久层）——数据增删改查 内聚——模块内部功能联系 耦合——模块间依赖/关联（高内聚低耦合） IOC\u0026amp;DI——类上添加注解@Component（注册Bean） 控制器类改为@Controller 业务类前改为@Service 数据访问类改为@Repository IOC容器提供该类的bean对象并赋值 DI：在类内部对象前添加@Autowired依赖注入——使用Bean 会话 用户访问web：会话开始 某方断连：会话结束 一次会话可以包括多次请求响应 会话跟踪：追踪请求来自同一浏览器（以便在同一会话的多次请求间共享数据）\n会话跟踪方案：客户端Cookie 服务端Session 令牌 Cookie（HTTP协议支持）移动端无法用 \u0026amp; 用户可禁用 \u0026amp; 不能跨域 跨域——协议 IP 端口 Session 服务器集群时无法直接用 \u0026amp; Cookie的缺点 令牌——反上述缺点 but 需要自己实现 JSON Web Token(JWT)——json格式传输 Header + Payload有效载荷（自定义内容） + Signature数字签名（防止Token被篡改） Header\u0026amp;Payload：Base64编码（A-Z a-z 0-9 + /）——表示二进制（可解码） Signature：登录成功后生成令牌 后续请求都须携带 可设定有效期 Filter过滤器 拦截资源请求 一般完成登录校验 统一编码处理 敏感字符处理等\n实现： 创建Filter类（immport javax.servlet.*）添加注解@WebFilter(urlPatterns=\u0026quot;/bal\u0026quot;) init（调用一次） doFilter destroy（调用一次）方法 需要开启：添加注解@ServletComponentScan doFilter添加放行功能 chain.doFilter(request,response)——放行到下一个过滤器 其后添加放行后的逻辑 Bean 声明Bean对象未指定名称——默认为类的首字母小写（获得Object对象） 作用域：单例——singleton（启动时创建一个） 非单例——prototype（同名只创建一次实例） 起步依赖 自动配置 起步依赖——依靠maven的依赖传递 自动配置（某些配置类、bean对象自动存入IOC容器（不需要声明对象）） SpringBootApplication扫描当前包与子包检查类的调用（不同包下自定义类不能注入） @ComponentScan(balabal)组件扫描 @Immport导入 自动配置原理：（源码跟踪AutoConfiguration.Imports）添加Conditional注解（有多个子注解） SpringBoot进行条件装配 Ctrl点方法查看源码 Mybatis 持久层框架（数据库操作） 简化JDBC（对数据库进行操作的规范）开发\n使用： 定义接口类 添加注解@Mapper 内部实现Mysql操作（使用注解@Delete/Select等） 使用时需要注入 运行时会自动生成接口的实现类对象（代理对象） 并交给IOC容器 通过#{balabal}传递方法中的参数 若需拼接（eg.模糊匹配）用concat('%','balabal','%') 调用（定义该类型变量）时添加注解@Autowired @Autowired private EmpDao empDao; JDBC——使用Java操作关系型数据库 数据库连接池——分配管理数据库连接（SpringBoot默认Hikari） 允许重复使用现有的数据库连接（不重新建立）——资源重用 提升系统响应速度 释放空闲时间过长（被占用但未与数据库连接）的连接——避免连接泄露 lombok——通过注解自动生成构造器等方法、日志变量 @Data=@Getter/Setter/ToString/EqualsAndHashCode @NoArgsConstructor无参 @AllArgsConstructor除static修饰的字段外带各参构造方法 增删改查：定义public int delete/insert等返回此操作会影响的记录数（用void则忽略） 增（主键返回）添加注解@Options(keyProperty=\u0026quot;id\u0026quot;,useGeneratedKeys=true)将生成的主键赋值给emp（定义的类的对象）的id 查 实体类属性名与SQL字段名相同时 mybatis会自动封装 可给字段名起别名/mybatis驼峰命名映射开关 配置日志信息：application.properties中添加mybatis.configuration.log-impl=StdOutImpl 预编译SQL——缓存语法检查、优化SQL、编译SQL过程，（条件一定时）直接执行 用占位符定义（之后传参） 避免SQL注入——通过输入影响预定的SQL语句 xml映射文件——定义比较复杂的SQL语句（让代码更简洁） 映射配置文件名与Mapper接口名一致，且放在相同的包下(同包同名) 映射配置文件的namespace属性与Mapper接口的全类名一致 XML映射文件中sql语句的id与Mapper接口中的方法名一致 SDK Software Development Kit软件开发工具包 事务管理\u0026amp;AOP 事务 注解@Transactional 以方法为单位作为事务（多在多次执行数据修改的方法上应用） 发生RuntimeError异常即回滚（默认） 通过rollbackFor=指定异常类型 传播行为Propogation指定 在启动类中需要添加允许注解开启事务的注解😋 AOP 面向切面编程——动态代理（主流） eg.计算每个方法的执行耗时\n声明AOP类@Aspect eg.包装需要计算耗时的方法 时间通过log输出 返回原方法运行的结果Object AOP类中方法添加注解@Around(\u0026quot;\u0026quot;)声明运用在哪些方法上（还有其它通知类型） Apache POI Java中操作ms office软件\n写入\n读取\n语法补充 try-finally 可用作记录日志（finally部分） else 用HashMap承接需要查找的条件 数据库查询时直接操作map（MyBatis） 取今天的最早时刻：LocalDateTime begin = LocalDateTime.now().with(LocalTime.MIN); 后端 项目结构Base sky-pojo中存放Entity（实体 与数据库中的表对应）、DTO（数据传输对象 各层间传输数据）、 VO（视图对象 前端展示数据）、POJO（普通java对象 仅属性\u0026amp;对应的getter setter） 一般用VO传回前端 DTO接收前端数据 sky-common——com.sky——exception下存放异常类 报错集锦 初始版本编译：“找不到符号” jdk版本不匹配：设置中修改为jdk18 \u0026amp; 将maven——运行程序——JRE版本更新 \u0026amp; 项目结构SDK版本更新 点击登录没反应 nginx启动 知识点 前后端联调 前端请求如何传输到后端？ Nginx反向代理——前端发出动态请求Nginx转发到后端服务器Tomcat 优点：提高访问速度\u0026amp;负载均衡（大量的请求按指定方式均衡分配给每台服务器）\u0026amp;保证后端服务安全 负载均衡策略：weight/ip_hash/least_conn/… # 处理管理端发送的请求 location /api/ { proxy_pass http://localhost:8080/admin/; # 反向代理 #proxy_pass http://webservers/admin/; # 负载均衡 } Swagger 生成接口文档\u0026amp;在线接口调试——Knife4j封装 开发阶段\n扫描包——设置静态资源映射 访问地址 常用注解——添加参数说明 注解 说明 @Api for类 对类的说明 @ApiModel for类 VO等 @ApiModelProperty for属性 @ApiOperation for方法 功能完善 登录功能 MD5加密——密码散列函数 不能解密（只能加密后比较结果）\n数据库保存加密后的密码，用户登录时将输入的密码进行加密后比较 员工\u0026amp;分类管理 约定：用户端发出请求以/user为前缀 管理端为/admin\n若前端数据与实体类中对应属性差别较大时 用DTO封装better 方法上注解——@PostMappingPost类型请求响应 controller设置新方法 调用service中定义的函数 在service对应的实现类中实现功能 将数据保存到对应的持久层mapper（数据库操作） 测试：一般采用接口文档测试（测试时检查token有效期等） 功能： 增：设置Employee对象承接传来的参数 若属性名一致，可直接进行属性拷贝`BeanUtils.copyProperties(employeeDTO,employee); 规范设置eg：employee.setStatus(StatusConstant.ENABLE); 查——xml 传出total（总记录数） record（查询到的记录信息） select * from employee \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null and name!=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; 改（状态修改） 通过路径参数传参：/employee/status/{status} 接收（Long等类型）参数的变量添加注解@PathVariable 修改信息 = 显示已有+修改 要用对象调用方法！（不是类名） 静态方法可以直接用类名调用\n完善： 报错信息处理(返回msg)：捕获异常并判断是否含有某些特定字句（自设）GlobalExceptionHandler中添加同名方法 ThreadLocal应用——为每个线程提供单独的存储空间 实现线程隔离（值） 定义一个类存储使用到ThreadLocal的方法 日期统一格式 公共字段自动填充——AOP方法 定义接口类（对外）与切面类（具体实现） 用Object类型承接传入的参数 用Method setCreateTime = obj.getClass().getDeclaredMethod(\u0026quot;方法名\u0026quot;, LocalDateTime.class)调用方法 方法名可设置常量避免出错 通过invoke反射进行赋值 eg.setCreateTime.invoke(entity,now); trick： 含@builder注解的类可以如下赋值 Employee employee=Employee.builder() .id(id).status(status) .build(); 添加配置属性类（注解@ConfigurationProperties定义可能用到的属性） 若需使用主键值 在插入语句中需注明useGeneratedKeys=\u0026quot;true\u0026quot; 菜品管理 添加DishVO类 增加分类变量（可直接返回前端） 在service实现层中进行事务管理 xml中foreach基本语法：传入数据形如(1,2,3) 需要提取1 2 3 select setmeal_id from setmeal_dish where dish_id in \u0026lt;foreach collection=\u0026#34;dishIds\u0026#34; item=\u0026#34;dishId\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{dishId} \u0026lt;/foreach\u0026gt; 营业状态 1参数 避免创建新表/类\n基于Redis字符串存储 用户端与管理端有同名类时 通过RestController(\u0026quot;名字\u0026quot;)设置Bean名以区分 Swagger中设置不同分组——docket设置groupName分开用户端\u0026amp;商家端（都要加@Bean） 用户登录 生成jwt令牌并校验 特殊 mapper层mysql语句中 后一个id变量与setmealId变量的值相同 但名称沿用类中名称 @Delete(\u0026#34;delete from setmeal where id=#{id}\u0026#34;) void delete(Long setmealId); 接收（Long等类型）参数的变量添加注解@PathVariable 缓存信息 减少数据库查询操作——Redis\n逻辑：每个分类下的菜品保存一份缓存数据——保存一对keyvalue 注意修改信息后需要重建缓存 Spring Cache 基于注解的缓存功能 仅提供一层抽象 底层可以切换不同的缓存实现（Redis EHCache等） @EnableCaching 开启缓存注解 加在启动类上 @Cacheable 方法执行前查询有否缓存 有则返回无则调用方法并添加 @CachePut 添加数据到缓存 @CacheEvict 删除n条缓存数据 Spring Cache语法：Spring EL 如@CachePut(cacheNames=\u0026quot;一个名字\u0026quot;,key=\u0026quot;#形参.要取的形参的信息（如id）\u0026quot;) 如key=#result.某 result即为当前方法的返回值 如key=#p0 传入的第一个参数（第二个即用p1） a0相同效果 最后生成的key的格式如：一个名字::1 删除语法：@CacheEvict调用 AllEntries=true 购物车 设置冗余字段 如图片/名称等 减少对多个数据库的访问 超时订单处理 Spring Task定时任务+WebSocket 统计 Aoache Echart 可以用stream读取List中某信息，eg.List中存储DTO，分别读取出num和number建立新List 在mysql中查询得到的结果名称需与DTO中变量名相同，否则不能存储 List\u0026lt;GoodsSalesDTO\u0026gt; goodsSalesDTOList=orderMapper.getTop10(beginTime,endTime); List\u0026lt;String\u0026gt; list = goodsSalesDTOList.stream().map(GoodsSalesDTO::getName).collect(Collectors.toList()); String name = StringUtils.join(list, \u0026#34;,\u0026#34;); 知识点 HttpClient 发送请求 进行响应\n使用： GET：创建httpclient对象\u0026ndash;\u0026gt;创建请求对象\u0026ndash;\u0026gt;通过httpClient发送请求并通过CloseableHttpResponse接收\u0026ndash;\u0026gt;显示接收到的信息（状态码 响应体）\u0026ndash;\u0026gt;关闭response与httpClient资源 POST：需要提供请求体 SpringTask 按约定的时间自动执行——定时任务框架 cron表达式：（可生成） 普通：0 0 9 12 10 ? 2024——2024年10月12日 星期？省略 9点 使用：导入spring-context坐标——启动类添加注解@EnableScheduling——自定义定时任务类 添加注解@Component——方法上添加注解@Scheduled(cron=\u0026quot;一些\u0026quot;) 无返回值 WebSocket 实现浏览器与服务器的全双工通信 一次握手创建持久性连接并双向通信 使用：websocket.html作为客户端——导入maven坐标——导入服务端组件WebSocketServer——导入配置类 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/%E5%A4%96%E5%8D%96proj/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"概要\"\u003e概要\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e产品原型：展示项目的业务功能\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e技术选型：\n\u003cimg loading=\"lazy\" src=\"img.png\" alt=\"alt text\"  /\u003e\n\n\u003cul\u003e\n\u003cli\u003e前端已完成\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"知识点\"\u003e知识点\u003c/h2\u003e\n\u003ch3 id=\"javascript\"\u003eJavaScript\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e三种变量：\u003ccode\u003evar\u003c/code\u003e——全局\u0026amp;可变 \u003ccode\u003elet\u003c/code\u003e——局部\u0026amp;唯一 \u003ccode\u003econst\u003c/code\u003e——全局\u0026amp;不可变\u003c/li\u003e\n\u003cli\u003e特殊运算符：==不同类型进行类型转换后再比较 ===（全等）不进行类型转换即比较（不同类型必报错）\u003c/li\u003e\n\u003cli\u003e类型转换：\n\u003cul\u003e\n\u003cli\u003e除0与NaN转换为false外其它全为true 除空字符串转为false外均为true\u003c/li\u003e\n\u003cli\u003eparseInt转换为int类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eJSON格式：先属性后函数\u003c/li\u003e\n\u003cli\u003eelse——XHR xml http request\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"maven\"\u003eMaven\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003ejava项目管理与构建 基于项目对象模型POM\u003c/p\u003e","title":"外卖Proj"},{"content":" 王道计算机考研 操作系统 操作系统 定义 系统资源的管理者\u0026amp;提供方便的接口与环境\u0026amp;最接近硬件的软件\n功能：处理机(CPU)管理\u0026amp;存储器管理\u0026amp;文件管理\u0026amp;设备管理 程序运行 将相关数据从磁盘放入内存 = 存储器 进程被CPU管理 = 处理机 接口\u0026amp;环境 flowchart LR 接口--\u0026gt;GUI 接口--\u0026gt;程序接口 用户接口--\u0026gt;程序接口 用户接口--\u0026gt;脱机命令接口 接口--\u0026gt;命令接口 命令接口--\u0026gt;脱机命令接口 命令接口--\u0026gt;联机命令接口 联机命令接口---交互式命令接口 交互式命令接口--\u0026gt;cmd 批处理--\u0026gt;.bat 脱机命令接口---批处理 GUI 图形化用户接口 硬件拓展 无软件支持的计算机 = 裸机 覆盖了软件 = 扩充机器（虚拟机） 四个特征 并发 共享 是最基本的特征 互为存在条件\n并发 宏观上同时发生 微观上交替（= 同时段发生）\n单核CPU同一时刻只能执行一个程序=并发 多核可以实现并行（同一时刻进行多个程序） 共享 资源共享 系统资源可供内存中多个并发进程共同使用 两种资源共享方式：\n互斥共享 一时段一进程 eg.摄像头 同时共享 一时段多进程 虚拟 物理实体变为逻辑上的对应物\nflowchart LR 虚拟技术--\u0026gt;空分复用技术 虚拟技术--\u0026gt;时分复用技术 空分复用技术--\u0026gt;eg.虚拟存储器 时分复用技术--\u0026gt;eg.虚拟处理器 没有并发性 虚拟性 = 不存在 异步性 多个程序并发 资源有限时进程执行以未知速度推进\n没有并发性 异步性 = 不存在 发展与分类 flowchart TB subgraph 手工操作 缺点1--\u0026gt;独占全机 缺点1--\u0026gt;资源利用率低 资源利用率低--\u0026gt;计算机快\u0026amp;人工慢 end 手工操作--\u0026gt;批处理阶段 subgraph 批处理阶段 subgraph 单道批处理系统 主要结构--\u0026gt;磁带\u0026amp;监督程序 缺点2--\u0026gt;内存中仅能运行一道程序 end 单道批处理系统--\u0026gt;多道批处理系统 subgraph 多道批处理系统 输入计算输出错峰运行 缺点3--\u0026gt;运行过程时不能调试 end end 批处理阶段--\u0026gt;分时操作系统 subgraph 分时操作系统 特点--\u0026gt;以时间片为单位轮流服务用户 优点--\u0026gt;及时响应解决人机交互问题 缺点4--\u0026gt;不能优先处理紧急任务 end 分时操作系统--\u0026gt;实时操作系统 subgraph 实时操作系统 在严格时限内处理事件---可以优先响应 特点1--\u0026gt;及时性\u0026amp;可靠性 分类--\u0026gt;硬实时系统 硬实时系统---严格时限 分类--\u0026gt;软实时系统 软实时系统---偶尔接受迟滞 end 实时操作系统--\u0026gt;网络操作系统 实时操作系统--\u0026gt;分布式操作系统 实时操作系统--\u0026gt;个人计算机操作系统 subgraph 不重要 网络操作系统 分布式操作系统 个人计算机操作系统 end 运行机制 指令 = 机器指令 非cmd\n两种 flowchart LR 内核程序Kernal--\u0026gt;特权指令 应用程序--\u0026gt;非特权指令 特权指令--\u0026gt;内核态 非特权指令--\u0026gt;用户态 内核程序 = 最接近硬件的部分 特权指令 = 管理者操作 内核态/用户态 = CPU状态（用PSW存储状态） PSW 程序状态字寄存器 内核态=核心态=管态 用户态=目态 切换状态：\n内核到用户：特权指令修改PSW 用户到内核：触发中断 硬件自动完成 中断与异常 中断作用 唯一让CPU从用户态变为内核态的途径 = 保障并发\n中断类型 内中断（异常）：中断信号来自CPU内部 当前执行指令\n指令自身非法/遇到特权指令 eg.trap程序引发/fault错误条件 Kernal可能修补/abort致命错误 外中断（中断）：与当前指令无关 eg.时钟中断 eg.I/O中断 基本原理 CPU检测到中断后查询中断向量表 找到中断处理程序的内存位置\n系统调用 一组系统调用组成程序接口\n应用程序通常通过库函数进行系统调用 有些库函数不调用 有些语言直接进行系统调用 eg.汇编语言 向系统内核提出请求对共享资源进行操作 即系统调用 发出trap指令提出请求（用户态） 执行trap后引发内中断进入核心态 体系结构 大/宏内核操作系统：所有内核功能（Linux UNIX等）\neg.进程 存储 设备 + 微内核部分 性能高 内核代码庞大 结构混乱 微内核操作系统：与硬件关系最紧密的功能（Windows NT） eg.时钟管理 中断处理 原语（设备驱动 CPU切换） 优缺点反之 引导 过程 CPU从主存（ = RAM + ROM（BIOS））执行ROM引导程序 将磁盘中主引导记录（MBR）读入内存 执行磁盘引导程序 扫描分区表 从活动分区（主分区）读入分区引导记录（PBR） 执行程序 主分区即安装了操作系统的分区 从根目录找到启动管理器并执行 完成开机🥳 虚拟机 Virtual Machine (VMware \u0026amp; Virtual Box)\n虚拟机管理程序（VMM monitor）\n第一类VMM 运行在硬件上（CPU 磁盘 内存进行划分） 用户空间分为虚拟用户态\u0026amp;虚拟内核态（但实际均为用户态） 若执行特权指令 由内核中的VMM进行虚拟执行 第二类VMM 运行在宿主操作系统（Host OS）上（如Vmware） VMM大部在用户态 VM驱动部分在内核态 对比：第一类性能更好 可容纳更多虚拟机 运行在最高特权级(Ring 0) 但可迁移性不强 第二类反之 进程管理 进程基础知识 基本 定义 程序：静态 = 指令集合 进程：动态 = 程序的执行过程\n进程组成 PCB（Process Control Block）进程控制块 For操作系统\n进程存在唯一标志 保存：PID UID \u0026amp; 进程控制与管理信息 \u0026amp; 资源分配清单 \u0026amp; 处理机信息 PID（进程ID 唯一不重复） 程序段：程序代码 For进程\n程序运行：程序-\u0026gt;硬盘（exe）-\u0026gt;内存PCB-\u0026gt;CPU取出指令 数据段：运行过程中产生的数据 For进程 进程实体（进程映像）=PCB+程序段+数据段 静态 进程 进程实体的运行过程 动态 特征 动态性：最基本的特征 并发性：内存中有多个进程实体 独立性：获得资源的基本单位 异步性 结构性：每个进程都有一个PCB\n状态与转换 创建态 就绪态 运行态 阻塞态 终止态\n就绪态——等待处理机调度 运行态——占用整个CPU运行 阻塞态——运行态进程请求等待某事件发生 下CPU（进程主动） 事件发生后改为就绪态（被动） 进程的组织 链式：队列指针 索引：索引表指针\n进程控制 实现进程状态转换\n原语实现——具原子性 = 不可中断\n特权指令 关中断指令\u0026amp;开中断指令实现原子性 关中断开启——不再检查中断信号 创建/撤销进程时使用的原语：PCB更新——资源分配——合适的队列\n申请空白PCB——找到对应PCB 为新进程分配资源——若运行 剥夺CPU并分配 初始化PCB——终止所有子进程 PCB插入就绪队列——资源归还并删除PCB 阻塞/唤醒原语——成对使用（因何阻塞必因何唤醒）\n切换进程的原语：将现行运行环境存入PCB\n进程通信IPC 两进程间的数据交互 不同进程的内存地址不重叠 通信需要操作系统支持\n共享存储 设定共享存储区 映射到进程的虚拟地址空间\n互斥访问 由进程自己实现 基于存储区：灵活性高 高级通信 基于数据结构：低级通信 消息传递 消息包括消息头\u0026amp;消息体 操作均由原语完成\n直接通信：两进程明确消息的接收方与发送方 在内存中存储发送了的消息 形成消息队列 间接通信：发到内存中的信箱 另一进程从信箱读取 信箱公用 管道通信 某时段内单向传输（半双工通信） I/O进程不固定数量\n一种共享文件pipe 内存中一个大小固定的内存缓冲区 队列 先进先出 线程与多线程 同个进程中可能有多个线程 程序执行的最小单位（相当于小进程）\n提升并发度 不用切换进程（同进程内线程切换）系统开销小 每个线程有自己的线程ID与TCB线程控制块 几乎不拥有系统资源（来自所属的进程） 通信方便 同进程内不需系统干预 线程实现方式 用户级线程（早期）——由线程库实现\u0026amp;管理 程序实现 与操作系统无关 并发程度很低（阻塞） 内核级线程（KTL） 进程与对应的内核级线程都在内核态的操作系统 内核级线程一一管理用户级线程 线程切换管理成本更高 多线程模型 一对一：一内核一用户 多对一：一内核多用户（退化） 多对多：多内核多用户（内核更少） 线程状态与转换 就绪——运行——阻塞 线程组织与控制 TCB(≈PCB)=线程标识符（TID）+程序计数器PC+其他寄存器+堆栈指针+线程运行状态+优先级 调度时保存PC+其他寄存器+堆栈指针 调度 处理机调度 确定处理任务的先后顺序\n三个层次 高级调度（作业调度）——从外存调入内存开始任务 低级调度（进程调度）——最基本 快速 内存到CPU 中级调度（内存调度）——从外存调到内存 从挂起队列调回内存（内存不足） 进程调度时机 不能调度的eg.处理中断 原语 处于内核程序临界区（操作系统内） 可调度eg包括主动与被动 方式： 非抢占方式——反之 抢占方式——更紧急的任务优先执行 当前任务中止 适用分时、实时操作系统 包括：选择进程+进程切换 调度器（调度程序）scheduler与闲逛进程idle 触发调度器eg.创建新进程+进程退出+进程阻塞+I/O中断（maybe唤醒阻塞进程） 抢占式调度：时钟中断触发 非抢占式：only阻塞/退出才触发 闲逛进程idle——优先级最低 占一个完整的指令周期（提醒作用） 调度算法评价指标 CPU利用率=利用时间/总时间 系统吞吐量=单位时间内完成作业的数量 周转时间=作业提交至系统-\u0026gt;作业完成的时间 平均周转时间=各作业周转时间和/作业数 带权周转时间=周转时间/实际运行时间（\u0026gt;=1） 平均带权周转时间=带权和/作业数 等待时间=等待处理机状态时间和 for进程：等待被服务的时间 for作业：建立进程后的等待时间+作业在外存后备队列的等待时间 响应时间=提交请求-\u0026gt;首次响应的时间 调度算法 先来先服务FCFS first come first serve 非抢占式 公平 but 长作业有利 短作业不利 不会饥饿（长期得不到服务） 短作业优先SJF shortest job first——当前已到达 运行时间最短 =短进程优先 非抢占（抢占版为最短剩余时间优先算法SRNT 新达到进程/进程完成时 剩余时间最短者抢占当前进程 SRNT平均等待时间、平均周转时间最少 若所有进程几乎同时到达 SJF平均等待时间、平均周转时间最少 时间短 but 不公平 长作业不利 会饥饿 maybe饿死 高响应比优先HRRN highest response ratio next——每次调度时先计算响应比 响应比同先来先服务 响应比=(等待时间+要求服务时间)/要求服务时间 非抢占式 考虑了要求服务时间 不会饥饿\n（适用于交互式系统的调度算法👇） 时间片轮转RR round-robin——根据到达顺序轮流执行一个时间片 only用于进程调度 可抢占式——时钟中断 公平 but 切换频繁\u0026amp;不区分紧急程度 时间片过大——增大进程响应时间 过小——进程切换过于频繁 不会饥饿 优先级——设置优先级：系统\u0026gt;用户 前台\u0026gt;后台 更偏好I/O型（I/O可以和CPU并行工作） 也可用于I/O 非抢占 有抢占式版本 考虑优先级 but 可能导致饥饿 多级反馈队列——设置多级就绪队列 优先级从高到低 时间片从小到大 规则： 新进程先进第1级队列 FCFS分配时间片 时间片用完还未结束 则进入下级队尾（最下级的就进入本级队尾） k级队列为空时 再为k+1级分配时间片 被抢占的进程进入此队队尾 用于进程调度 抢占式（有非抢占式版本） 相对公平 响应快 短进程完成较快 避免用户作假 灵活调整偏好程度 maybe饥饿 多级队列——按进程类型设置不同优先级 队列间可采取固定优先级/时间片划分 各队列可采用不同调度策略 进程同步 互斥等 进程同步与互斥 进程同步——进程的次序（对抗异步性——未知速度） 进程互斥——临界资源（一时段一程序访问）互斥 进入区（检查可否进入 设置正在访问标志）——临界区——退出区（解除标志）——剩余区 临界区空闲则让进 忙则等待 有限等待——能在有限时间内进入临界区 让权等待 进程互斥的软件实现 单标志法——一个flag=允许进入临界区的进程号 空闲让进不符 双标志先检查法——进程数个flag 表达本进程是否进入临界区 忙则等待不符（检查与上锁不是同时发生） 双标志后检查法——先上锁后检查 空闲让进 有限等待不符 Peterson——自己flag为true \u0026amp; 上其它锁 \u0026amp; 若其它flag为true且上锁则自己while空循环等待 进程互斥硬件实现 中断屏蔽——开/关中断指令实现 简单高效 but 不适用多处理机（only单处理机）\u0026amp;特权指令 TS指令 TestAndSetLock——执行过程不允许中断 让权等待不符——无法进入的程序会占用CPU并循环TSL指令 SWAP指令（即XCHG）——类TSL指令 互斥锁 主要缺点：忙等 需要连续循环忙等的互斥锁 = 自旋锁 适用多处理机系统 信号量机制 用户进程用一对原语对信号量操作\n信号量：变量（整数/记录型变量） 整型信号量——仅初始化、P、V操作 存在忙等 记录型信号量——灵活使用阻塞态 就绪态等 value表示资源的剩余数量 遵循让权等待 一对原语：wait(S) signal(S) 简称为P、V操作 必成对出现 信号量机制应用 实现进程互斥——value定为互斥信号量mutex（进入临界区的名额） 初值为1 进程同步——保证操作顺序——设置同步信号量S 初值0（反互斥之道而行之） 先V（进程一结束后）后P（进程二开始前）——V释放资源 P获取资源 前驱关系 PV例题 生产者消费者问题 bg：生产者生产一个产品放入缓冲区 消费者每次取出一个产品 缓冲区有大小限制且为临界资源 PV关系：缓冲区空否——同步信号量（初值为n） 满否——同步信号量（初值为0） 访问——互斥信号量 P操作：互斥信号always在同步信号后（不空/满才访问） V：whatever 多生产多消费者 bg：生产者A生产a 消费者C只要c BD同理 缓冲区仅能放有限数量 PV：互斥——访问 同步——几个a/b（For消费者） 同步——还可以放多少（For生产者） 共4个 若缓冲区大小为1 maybe可以不加互斥信号量 吸烟者 bg：3个抽烟者和1个供应者 卷烟需要3种材料 一抽烟者有1种 供应者每次供应2种 1对应抽烟者拿走 PV：互斥——访问 同步——1 2 3是否卷好 可以省略互斥 读者-写者 bg：共享一个文件 可以多个读 一个写则其它均不可 写时让已有的读与写全部退出 PV：互斥——记录读进程个数（互斥访问计数器） 互斥——写锁 读写锁等 哲学家进餐 bg：圆桌 每人两边各有一只筷子 哲学家要么思考要么进食（需要两只筷子） PV：对筷子设置互斥 无限制会死锁——限制最多四人进餐/… 管程 信号量机制——编写程序困难易出错 =\u0026gt; 引入管程替代PV\n组成≈类（过程≈Java中的方法） 特征：管城内的数据只能被其内部的过程访问 + 只有通过管程的过程才能访问内部的共享数据 + 每次仅有一个进程在管程内执行过程 Java中的类似机制：synchronized 被其 修饰的函数在同一时段内只能被一个线程调用 死锁 概述 概念 死锁：各进程互相等待对方的资源 = 都阻塞 管理者的问题 饥饿：长期得不到资源 某进程无法推进 管理者的问题 死循环：进程执行时跳不出循环 条件 互斥——资源使用互斥 不剥夺——其他进程不能强行夺走资源 请求和保持——已经保持了至少一个资源 但还有请求 循环等待——资源的循环等待链 循环等待时不一定会发生死锁 发生死锁的情况 资源竞争 进程推进顺序非法（请求与释放的顺序不当） 信号量使用不当 = 不可剥夺的资源分配不合理\n处理策略 预防（破坏形成条件） + 避免（防止进入不安全状态） + 检测与解除\n预防死锁（静态策略） 互斥条件破坏——改为共享资源 eg.SPOOLing技术 适用范围窄 不剥夺破坏——请求无法满足时释放所有资源/操作系统将资源强行剥夺 复杂+降低吞吐量+maybe饥饿+只适用易保存回复资源 请求保持破坏——静态分配方法（运行前申请所有资源 不满足则不运行 运行后不请求） 资源利用率低 maybe饥饿 循环等待破坏——顺序资源分配法（资源编号 每个进程按编号递增请求资源 同号一次申请完） 难新增资源+资源浪费+编程麻烦 避免死锁（动态策略） 安全序列：按此序列分配资源则每个进程都能完成 安全 = 一定不死锁 不安全 = 不一定死锁 银行家算法：进程申请时 预判分配会否导致不安全 会则阻塞该进程 安全性算法：根据资源分配循环找安全序列 n个进程 m种资源 = n*m矩阵 =\u0026gt;最大需求矩阵Max n*m的分配矩阵Allocation 最多还需要多少资源Need 长m的一维数组Available表示还有多少可用资源 长m的一维数组Request表示本次申请的各种资源\n不断重复上述步骤 检测与解除 检测：保存资源的请求与分配信息（数据结构）+检测是否死锁（算法） 两种边：请求与分配 最终能消除所有边 = “可完全简化” = 一定没有死锁 死锁定理：若不能消除 = 发生死锁 还连着的边 = 处于死锁[^2]: 暂时挂到外存 解除： 资源剥夺法：挂起[^2]某些死锁进程 并将其资源分给其它死锁进程 注意防止饥饿 撤销进程法：强制撤销部分/全部死锁进程 并剥夺资源 代价大 进程回退法：一个/多个死锁进程回退到避免死锁的地步 需设置还原点 进程选择考虑：进程优先级 已执行时间 还要多久完成 已使用多少资源 交互式or批处理式 内存 内存基础 内存中存储程序的最小单位——存储单元 按字节编址 = 每个存储单元大小为1B 1K=2^10^ 1M=2^20^ 1G=2^30^ 逻辑地址（编程时指定的相对地址）转换为物理地址（绝对地址）方法： 绝对装入——编译时指定绝对地址 不存在操作系统时应用 静态重定位（可重定位装入）——装入模块（exe）装入时转换 必分配要求的全部内存空间 运行期间位置不能移动 动态重定位（……）——程序要执行时再进行转换 需要重定位寄存器——寄存装入模块存放的起始位置 允许程序在内存中移动 链接方式 静态链接——运行前链接为装入模块 装入时动态链接——装入内存时 边装入边链接 运行时动态链接——执行时需要某模块才链接 内存管理 概念 功能：内存空间的分配与回收 + 内存空间的扩展 + 地址转换 + 内存保护 内存保护方法： CPU中设置上下限寄存器——限定进程可访问的空间 重定位寄存器（基址寄存器）+界地址寄存器（限长寄存器）=起始物理地址 + 最大逻辑地址 最大逻辑地址判定是否越界异常 起始物理地址确定被查询数据的具体位置 覆盖与交换（内存空间的扩展） 覆盖：不能同时进行的程序段共享同一片覆盖区 一个固定区（程序段不会被调入调出）+若干覆盖区 程序员提前声明 对用户不透明——已淘汰 交换：内存紧张时 内存中某进程暂时换出外存 外存中某进程换入内存 外存（磁盘）包括文件区\u0026amp;对换区——对换区IO速度比文件区更快（对换区主要追求效率） 可优先换出阻塞/优先级低进程/…… PCB常驻内存 不会被换出（储存进程换出在外存的位置） 连续分配管理方式 为进程分配连续的内存空间\n单一连续分配：内存 = 系统区 + 用户区 内存中只能有一个用户程序 无外部碎片 有内部碎片（分配的内存区域有部分没有用上） 固定分区分配——用户空间划分为固定大小的分区 每个分区运行一道作业（分区大小可相同/不相同） 分区说明表（数组/链表表示）：记录分区大小 起始地址 状态等 无外部碎片 but 用户程序过大只能覆盖 会产生内部碎片 动态分区分配（可变分区分配） 动态分区分配的几个问题 空闲分区表/链存储内存使用情况\n…链：空闲分区起始加前向指针 末尾加后向指针 多个空闲分区分配——动态分区分配算法\n分区的分配与回收——简单的修改表项操作\n特点：没有内存碎片 but 有外部碎片\n外部碎片：内存中某些空闲分区因太小而难以利用 可通过紧凑（拼凑Compaction）解决——换入换出 装入方式选择？ 动态重定位 紧凑之后？ 修改起始地址——PCB 也要放入CPU的基址寄存器 动态分区分配算法 首次适应算法：从低地址开始查找 找到第一个满足大小的空闲分区 空闲分区按地址递增的次序排列 算法开销小 性能最好 最佳适应算法：优先使用更小的空闲区 按容量递增次序排列 会产生很多外部碎片 + 算法开销大 最坏适应算法：优先使用最大的连续空闲区 容量递减次序 可能大进程无处安放 + 算法开销大 邻近适应算法：首次适应 + 每次从上次查找结束的位置开始检索 地址递增次序\u0026amp;上次查找结束 高地址的大分区可能被用完 基本分页存储管理（非连续分配管理方式） 分页存储： 内存空间分为大小相等的分区 每个分区就是一个页框 每个页框有编号 即页框号 页框=页帧=内存块=物理块=物理页面 页框号=页帧号=内存块号=物理块号=物理页号 页框号从0开始 进程的逻辑地址空间分为与页框大小相等的部分 每个部分即为页面 每个页面标号为页号 页面=页 页号从0开始 页面与页框一一对应 各页面不必连续存放 页表 通常保存在PCB中\n一进程对应一张页表 进程的每个页面对应一个页表项（=页号+块号） 记录进程页面和实际存放的内存块间的映射关系 问题：每个页表项占多少字节？ 从内存块号范围（如0~2^20^-1）确定（二进制表示至少需要20bit 即内存块号大小） 用B（字节）表示至少3B（1B=8bit） 即至少用3B表示块号 页号不占存储空间——页表项连续存放 问题：如何实现地址转换？ 确定页号+页内偏移量 基本地址变换机构 逻辑地址到物理地址的转换\n注意越界检查——从系统区的PCB调出数据 放到页表寄存器（页表始址 + 页表长度） 页表长度即页表中有多少页表项 实际会拓展页表项大小——最好一个页框能装下整数个页表项（跟进程存储相独立） 具有快表地地址变换机构 快表TLB（联想寄存器translation lookaside buffer）——访问速度比内存快很多的高速缓存（Cache） 非内存（内存中的页表被称为慢表） 存放最近访问的页表项的副本 普通Cache中存放其它内容的副本 在快表中查询是否有需查找的页表项 若未命中则访问内存中慢表——内存中最近访问过的页表项存放到快表中 两级页表 将页表拆分为很多小页表——页目录表存储小页表存放位置 二级页表存放进程页面的存放位置 二级页表可以离散存储 逻辑地址结构 = 一级页号 + 二级页号 + 页内偏移量 各级页表最多存储页表项数量 = 各页面可存放的最多页表项 基本分段存储管理（非连续分配管理方式） 分段：程序自身逻辑划分为若干段 每段有段名（低级语言——汇编语言 按段名编程） 每段从0开始编址 段号位数决定了每个进程最多分多少段 段内地址数决定了每段最大长度 段表：保存逻辑段存放位置 = 段号 + 段长 + 基址（段号隐含 不占内存） 各段表项长度相同 地址变换——段表寄存器（段表始址+段表长度）\u0026amp;段内地址与段长 进行越界中断检查 分页\u0026amp;分段 页是信息的物理单位 对用户不可见 进程地址空间为一维 段是信息的逻辑单位 对用户可见 进程地址空间为二维 更易实现信息共享与保护 不会被修改的代码（即纯代码）才可以共享 段页式管理方式（非连续分配管理方式） 分页分段优缺点：分页不会产生外部碎片 但不能按逻辑实现信息共享 分段反之 段页式 = 先分段 \u0026amp; 每段再分页 逻辑地址结构 = 段号 + 页号 + 页内偏移量 一个段表 + n个页表 页部分对用户不可见 只需指定段号与段内偏移量 检查段号 页号是否越界 虚拟内存（内存的扩充） 局部性原理 时间局部性——某指令/数据若被调用过 不久后很可能再次被调用 空间局部性——某存储单元若被访问过 不久后其附近存储单元很可能被访问 很多数据在内存中连续存放 程序指令也是顺序存放 虚拟内存——很快会用到的部分装入内存 剩下的在外存 + 若执行时某信息不在内存 操作系统将其调入 + 内存不够时将暂时不用的调出 特征： 多次性——无需一次性装入 对换性——作业运行时允许换入换出 虚拟性——逻辑上扩充内存容量 管理：请求分页管理方式\u0026amp;请求分段管理方式\u0026amp;请求段页式管理方式 实现：操作系统提供请求调页功能 + 页面置换功能（For分页 分段类似） 请求分页管理方式 页表机制：操作系统需知页面是否已调入内存/外存存放位置 内存空间不够时进行页面置换——修改过的页面调出覆盖外存中旧数据 未修改的不变 缺页中断：若页面不在内存则产生 缺页的进程阻塞 调页完成后唤醒就绪 中断处理程序需要保存CPU现场 中断信号来自CPU 为内中断 地址变换机构：新增请求调页 \u0026amp; 页面置换 \u0026amp; 修改请求页表中的新增表项 调入的页面对应的表项会直接加入快表 页面置换算法 选择哪个页面被换出\n最佳置换算法OPT：淘汰以后永不使用/最长时间不访问的页面 保证最低缺页率 不可能实现 先进先出FIFO：淘汰最早进入内存的页面 为进程分配的物理块数（内存块）增多时 缺页次数反而增加 = Belady异常 只有FIFO有Belady 性能差 最近最久未使用置换算法LRU：淘汰自上次访问至今时间最长的页面 性能好 but 实现困难开销大 时钟置换CLOCK/最近未用NRU：（简单版）内存中页面用指针链接为循环队列 被访问时访问位设为1 淘汰时遇1置0 遇0淘汰 最多经过两轮扫描进行淘汰页面 未考虑是否修改 改进版时钟置换：设置修改位 0表示未被修改 1表示被修改 优先淘汰(0,0)（访问位，修改位） 二轮淘汰(0,1) 并把扫描过的页面访问位置0 三轮淘汰(0,0)，四轮淘汰(0,1)（访问位均为0，故总有页面被淘汰） 算法开销小 \u0026amp; 性能可 页面分配策略 驻留集 请求分页存储管理中给进程分配的物理块集合\n虚拟存储技术的系统中 驻留集一般小于进程总大小 页面分配置换策略 固定分配 \u0026amp; 可变分配 驻留集大小在进程运行期间是否可变 局部置换 \u0026amp; 全局置换 缺页时 只能选进程自己的物理块进行置换 可选其他进程的物理块/操作系统保留的物理块 固定分配局部置换 难以在初期确定合理的物理块数目 可变分配全局置换——选择未锁定页面换出外存 将其分配（只要缺页就分配新物理块） 被选中的进程缺页率增加 可变分配局部置换——频繁缺页 系统会多分配物理块 调入页面时机 预调页策略——相邻页面调入 主要用于进程首次调入 请求调页策略——缺页时调入 抖动现象（颠簸） 刚换出的页面马上需换入内存\n原因：频繁访问的页面数目高于可用的物理块数（物理块不够） 工作集：某时间间隔里 进程实际访问页面的集合 一般驻留集\u0026lt;工作集 否则会频繁缺页 内存映射文件Memory-Mapped Files 将文件映射到进程的虚拟地址空间——以访问内存的方式访问文件 读入写出由操作系统负责 多个进程可以映射同个文件 实现共享 文件管理 在磁盘（外存）中\n文件的逻辑结构 逻辑结构 For用户（看来 内部数据如何组织） 物理结构 For操作系统（看来 文件数据如何存放在外存）\nflowchart LR 逻辑结构--\u0026gt;无结构文件 逻辑结构--\u0026gt;有结构文件 有结构文件--\u0026gt;顺序文件 有结构文件--\u0026gt;索引文件 有结构文件--\u0026gt;索引顺序文件 顺序文件--\u0026gt;顺序存储 顺序文件--\u0026gt;链式存储 无结构文件（流式文件）——内部数据为一系列二进制流/字符流 eg.txt 有结构文件（记录式文件） 每条记录有一个数据项可作为关键字 定长记录——各条记录长度相等 可变长记录——不等 有结构文件的逻辑结构 各记录排列的顺序\n顺序文件：记录按顺序排列（逻辑上的顺序） 定长/可变长记录 串结构——记录的顺序与关键词无关 顺序结构——记录顺序按关键词顺序 定长记录的顺序文件可实现随机存取 若采用顺序结构可快速找到关键字对应的记录（折半查找） 可变长记录的顺序文件不能随机存取 索引文件（加快文件检索速度）——可变长记录的顺序文件改进 索引表自身为定长记录的顺序文件 可能会占用很大的内存空间 索引顺序文件——索引表改进 将文件数据分组 索引顺序文件储存分组信息 查找：先在索引顺序文件中顺序找分组 后在分组中顺序找记录 多级索引顺序文件——索引顺序文件改进 文件目录 文件控制块FCB——包含文件基本信息 FCB有序集合即为文件目录 目录结构： 单极目录结构 不允许文件重名 两级目录结构 = 主文件目录 + 用户文件目录 允许不同用户的文件重名 多级目录结构（树形结构）——用文件路径名标识文件 eg./users/local/bin 树形结构不便于文件共享 无环图目录结构——增加一些指向同节点的有向边（相当于共享） 可设置共享计数器 索引结点：存放FCB中除文件名外的信息（用索引结点指针存放） 加快查找效率 文件物理结构 磁盘块：磁盘中分为many磁盘块 大小与内存块、页面大小相同 逻辑块号 + 块内地址 = 文件的逻辑地址 连续分配：要求每个文件在磁盘上占有一组连续的块 文件目录需记录文件存放在磁盘中的起始块号\u0026amp;长度（总共占用几块） 优点：支持顺序访问与直接访问 \u0026amp; 顺序读写时速度最快（距离近 磁头移动更快） 缺点：存储空间利用率低 会产生磁盘碎片 链接分配：离散分配 指针链接 隐式链接——必须从上一个逻辑块中读到下一个块的物理地址 只支持顺序读取 but 不会产生碎片 显式链接——链接各物理块的指针显式存放在一张表中（文件分配表FAT File Allocation Table） 一个磁盘仅一张FAT 开机时读入内存并常驻 FAT各表项在物理上连续存储 且长度相同 支持顺序/随机访问 不会产生外部碎片 but FAT需要占用一定存储空间 索引分配：离散分配 每个文件都有一张索引表（记录文件逻辑块对应的物理块） 索引表存放的磁盘块称为索引块（FCB中记录索引块位置） 文件数据存放的称为数据块 索引表过大 解决方案： 链接方案——顺序读取各索引块 多层索引——需多次读磁盘 混合索引——多种索引分配方式结合 eg.有的直接地址索引 有的一级间接（单层索引表） 有的二级间接索引 各级索引表不能超过一个块 文件存储空间管理 存储空间划分与初始化 将物理磁盘划分为文件卷（逻辑卷/逻辑盘） eg.C盘 文件卷包括目录区（存放FCB 存储空间管理的信息等）\u0026amp;文件区 空闲表法——建立空闲表（包括空闲盘块号\u0026amp;空闲盘块数） 分配回收与内存的动态分区分配类似 空闲链表法——空闲盘块链/空闲盘区链（连续的盘块组成盘区） OS保存链头链尾指针 盘区链适用于离散分配\u0026amp;连续分配 位示图法 每一格代表一个盘块 盘块号=ni+j（n为字长 i为字号 j为位号） 空闲标0 不空标1 成组链接法（UNIX采用） 空闲表/链表法不适用于大型文件系统 文件基本操作 创建文件：在外存中找到文件所需空间 + 创建该文件对应的目录项 删除文件：找到目录项 + 回收磁盘块 + 删除目录项 打开文件：找到目录项（检查权限） + 目录项复制到内存中的打开文件表 打开文件表 系统有一总表 各进程也有表（记录读写指针 访问权限 系统表索引号） 关闭文件：进程的打开文件表项删除 + 回收内存 + 系统打开文件总表计数器更改 读/写文件：读/写指针指向外存（文件数据存储处） OS将用户指定的数据读入内存 写回写指针指向的外存数据 文件共享 基于索引结点的共享方式——硬链接 不同用户的目录下索引结点指针指向同一个索引结点 索引结点中设置链接计数变量 基于符号链的共享方式——软链接 创建Link类型文件 根据其记录的路径查找目录 eg.快捷方式 文件保护 口令保护：为文件设置口令（保存在FCB中） 请求访问时验证 口令存放在系统内部 加密保护：对文件原始数据进行加密 eg.异或加密 访问控制：为文件的FCB/索引结点增加访问控制列表(Access-Control List,ACL) 记录各用户可执行的操作 设备管理 I/O设备分类 输入输出\n分类：人机交互类外部设备 + 存储设备 + 网络通信设备 eg.猫 人机…：数据传输速度慢 存储设备：数据传输速度快 分类：低速设备 + 中速设备 + 高速设备 分类：块设备 + 字符设备 以块为单位进行信息交换 eg.移动硬盘 字符设备常采用中断驱动方式 I/O控制器 CPU控制I/O控制器 I/O控制器控制设备的机械部件\n功能： 接收识别CPU命令——控制寄存器存放 向CPU报告设备状态——状态寄存器 数据交换——数据寄存器 地址识别——为寄存器设置地址 组成：CPU与控制器的接口 + I/O逻辑 + 控制器与设备的接口（多个） 各寄存器也可能有多个 寄存器地址分类：内存映像I/O——与内存地址统一编址 寄存器独立编址——使用单独的地址 都储存在内存中 I/O控制方式 程序直接控制方式：数据最后要存储到内存中 CPU干预频繁 每次传送一个字 实现简单 but CPU与I/O只能串行工作 CPU长期处于忙等 中断驱动方式：CPU发出命令后将等待I/O的进程阻塞 切换执行其它进程 I/O完成后发出中断信号 CPU检测到中断信号后处理中断（读一个字） 之后恢复进程运行环境（等待I/O或其它） CPU在每个指令周期末尾检查中断 中断时需要保存进程现有状态 频繁中断效率低 DMA直接存储器存取——主要用于块设备的I/O控制 数据从设备到内存 or 从内存到设备 不经过CPU CPU通过MAR内存地址寄存器等指明存放位置等信息 可读写一个或连续的多个块 CPU只在传送的开始或结束时介入 but 只能读写连续的数据块 通道控制 = 更弱的CPU（硬件） CPU只需发出I/O命令 完成后向CPU发出中断信号 可处理一组块 I/O软件层次结构 know某处理是在哪层完成的 用户层软件：与用户交互 提供库函数进行操作 \u0026amp; 将用户请求转为I/O请求 用系统调用请求内核服务 设备独立性软件（与硬件特性无关的功能） 如：向上层提供系统调用接口\u0026amp;设备保护（如访问权限）\u0026amp;差错处理\u0026amp;设备分配回收\u0026amp;数据缓冲区管理\u0026amp;逻辑、物理设备名映射 不同设备内部硬件特性不同——不同的设备驱动程序 设备驱动程序：对硬件设备的具体控制 将命令转化为特定设备的操作 中断处理程序：I/O任务完成时控制器发送中断信号 系统根据中断信号类型找到中断处理程序 输入输出管理 I/O程序接口： 字符设备接口 get/put系统调用 块设备 read/write seek——在读写指针处操作 网络设备 网络套接字socket接口 eg.localhost:1313 1313即为一个套接字 可与其它ip地址的socket绑定 实现信息传输 阻塞I/O 发出I/O系统调用进程需转为阻塞态 非阻塞I/O不需阻塞等待 设备驱动程序接口——设备独立软件层 I/O核心子系统 I/O调度——类其它调度策略 设备保护——UNIX将设备视为特殊的文件 假脱机技术SPOOLing 用户层软件 模拟脱机技术\n组成：缓冲区与井都暂存数据 位置不同 共享打印机原理——输出井为每个打印请求分配一个存储区（逻辑设备） 设备的分配与回收 设备独立性软件\n设备分配考虑：设备固有属性 设备分配算法 设备分配安全性 分配方法： 静态分配 运行前分配资源 动态分配 过程中分配 分配管理的数据结构 设备控制表DCT 指向COCT的指针 控制器控制表COCT 指向CHCT的指针 通道控制表CHCT 等待队列指针 系统设备表SDT 包括DCT 分配步骤：根据物理设备名找SDT 从SDT找到DCT 到COCT找到控制器 到CHCT分配通道 设备、控制器、通道都分配成功才成功 必须使用物理设备名——难换 \u0026amp; 若正忙进程必须阻塞等待 改进：用逻辑设备名申请 OS用LUT（逻辑设备表）实现名称映射 一张LUT中逻辑设备名不可重复 一般每个用户一张 缓冲区 作用：缓和CPU与I/O设备速度不匹配的矛盾 减少对CPU的中断频率 解决数据粒度不匹配问题（字符/块） 单缓冲：主存中分配缓冲区——非空时不能进数据 空时可以进数据但必须充满 双缓冲：分配2个缓冲区 循环缓冲区：多个大小相等的缓冲区链接为循环队列 缓冲池：系统中共用的缓冲区组成 可分为空缓冲队列 装满输入数据的缓冲队列（输入队列） 输出队列 缓冲区种类：收容输入hin 提取输入sin 收容输出sout 提取输出hout 磁盘 结构 磁盘上一圈为一个磁道 磁道被分为一个个扇区（即磁盘块） 可能有很多盘面 但所有盘面连轴转 每个磁头共进退 各扇区存放数据量相同 读写数据：移到指定磁道 磁盘转动使目标扇区从磁头下划过实现 柱面号-盘面号-扇区号定位磁盘块 柱面：所有盘面中相对位置相同的磁道（下图黄色部分） 分类：活动头磁盘（磁臂可移动） 固定头磁盘（不可动 但有很多磁臂） 也可按盘片可否更换分类 磁盘调度算法 一次读写操作时间： 寻找时间——读写数据前 磁臂移动到指定磁道 延迟时间——旋转磁盘 定位扇区 传输时间——从磁盘读出/写入数据 调度算法： 先来先服务FCFS：进程请求磁盘访问的先后顺序 最短寻找时间优先SSTF：优先处理离当前磁头最近的磁道 可能饥饿 扫描SCAN（电梯算法）：磁头移动到最外侧才能向内动 反之亦然 不会饥饿 but 不同磁道响应频率不平均 LOOK：若在移动方向上无其他请求 可以立即改变磁头移动方向 循环扫描C-SCAN：只有朝固定方向移动时才处理磁道访问请求 返回时直接到起始段 响应频率平均 but 平均寻道时间更长 C-LOOK：移动方向上若无其他请求立即返回 减少延迟时间的方法 读取一块后就需要处理——但磁盘转动不停——下一块要转圈\n交替编号——逻辑上相邻的扇区在物理上有间隔 磁盘地址结构设计： 为什么柱面号在前？ 面对连续的地址如000,00,000-000,01,111 柱面号在前时不用移动磁臂；盘面号在前需移动磁臂 错位命名——改变相邻盘面对应顺序（相邻地址读取时间问题） 磁盘管理（理解） 磁盘初始化： 低级格式化（物理格式化）——划分扇区 分为头、数据区域、尾 磁盘分区——每个分区由若干柱面组成eg.C盘 逻辑格式化——创建文件系统（创建根目录 初始化数据结构eg.位示图） 引导块（启动块/启动分区）——存放完整的自举程序 启动块位于磁盘的固定位置 拥有启动分区的磁盘 = 启动磁盘/系统磁盘eg.C盘 坏块（无法正确使用的扇区） 简单的磁盘可在逻辑格式化时检查并标明 复杂的用磁盘控制器维护坏块链 管理备用扇区 固态硬盘SSD 重点如下\n主要结构： 以页为单位读写 以块为单位进行数据擦除 方可重写每页 先把不需擦除的页复制到其它闪存芯片对应位置 在其它芯片上写后整体移入原芯片 映射的物理位置可以改变 读快写慢 SSD的一个块被多次擦除可能会损坏 磨损均衡技术：将擦除平均分布在各个块上 动态磨损均衡：写入数据时 优先选择累计擦除次数少的新闪存块 静态磨损均衡：SSD分配数据 让老旧闪存块承担以读为主任务 新的以写为主🥳🥳 ","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"所有图片来自：王道计算机考研 操作系统，链接见文章","title":"操作系统OS"},{"content":" OI WIKI 基础 三要素 数据结构 = 逻辑结构 + 数据运算 + 物理结构 逻辑结构=集合+线性+树形+图状 运算=增删改查 物理结构=存储结构=顺序+链式+索引+散列 存储 时间复杂度排序：O(1) \u0026lt; O(log~2~n) \u0026lt; O(n) \u0026lt; O(nlog~2~n) \u0026lt; O(n^2^) \u0026lt; O(n^3^) \u0026lt; O(2^n^) \u0026lt; O(n!) \u0026lt; O(n^n^) 最坏\u0026amp;平均时间复杂度度量 最深层循环的循环次数与n的关系 乘法规则：相乘后度量 空间复杂度 内存中的变量存储大小 递归\u0026amp;动态规划 递归：选定递归基 + 认定该方法可以解决该问题\n空间复杂度较高 动态规划：部分或完全消除算法中的递归成分（用有限空间记录子问题的解 以避免重复访问子问题） 条件：\n最优子结构（可能适用贪心） 无后效性：已求解的子问题不受后续决策影响 子问题重叠 线性表 相同数据类型 有限序列（有次序） ai中i为位序\n基础 基本操作 InitList(\u0026amp;L) DestroyList(\u0026amp;L) 增删改查: ListInsert(\u0026amp;L,i,e) ListDelete(\u0026amp;L,i,\u0026amp;e) LocateElem(L,e)按值查找 GetElem(L,i)按位查找 Length(L) \u0026amp; PrintList(L) \u0026amp; Empty(L) 传入\u0026amp;：需要用到修改后的值 栈 后进先出 (last in first out,LIFO)\nCpp的STL中stack容器提供成员函数： st.top()返回栈顶 st.push()进栈到顶 st.pop()弹出栈 st.empty() st.size()栈容量 Python模拟栈 st=[1,2,3] st.append(2) # 入栈 st.append(3) # [1,2,3,2,3] st.pop() st.clear() 队列 先进先出 (first in first out,FIFO)\n数组模拟队列 标记队列首尾(ql,qr) 删除元素：ql++ 清空队列：ql=1,qr=0(ql\u0026gt;qr即可) 双栈模拟队列 F为队尾栈 S为队首栈 pop时若S为空 则将F元素弹出后插入S 再进行pop 双端队列 队首队尾均可插入删除元素 Python中容器为collections.deque 循环队列 下标为0的位置视为最后位的后继 队列向数组尾部移动 最终入队即使有空位也会溢出（假溢出） 单调栈与单调队列 保证元素单调性的栈/队列（递增or递减）\n维护一个单增/单减的数组 实现最小/最大值查找\\\n(以单减找最大为例) 新元素与队尾元素比较 若更小则进队 若更大 则从队尾开始将所有比之更小的元素踹出队 lc.239滑动窗口找最大\\ int head=0,tail=-1; int i=0; int[] win=new int[nums.length]; for(;i\u0026lt;k;i++){ while(head\u0026lt;=tail\u0026amp;\u0026amp;nums[win[tail]]\u0026lt;=nums[i]){ tail--; } win[++tail]=i; System.out.println(\u0026#34;now tail is \u0026#34;+tail); } System.out.println(nums[win[head]]); for(;i\u0026lt;nums.length;i++){ while(head\u0026lt;=tail\u0026amp;\u0026amp;nums[win[tail]]\u0026lt;=nums[i]){ tail--; } win[++tail]=i; while(win[head]\u0026lt;=i-k) head++; System.out.println(nums[win[head]]); } 类似还有lc.84/739/862/901/907等可用类似方法\n链表 增删 O(1) 查读 O(n)\n单向链表 指针 + 数据 双向链表 指针（左、右） + 数据 struct Node{ int value; Node *left; Node *right; }; 插入数据 单向链表 new node的next指向p的next node p的next node指向new node node-\u0026gt;value=i; node-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=node; 单向循环链表 首尾相连 插入时判断是否为空 若为空 new node的next指向自己 p指向new node if(p==NULL){ p=node; node-\u0026gt;next=node; } 双向循环链表 判断是否为空 \u0026amp; 修改左右两个指针 非空 node-\u0026gt;left = p; node-\u0026gt;right = p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left = node; p-\u0026gt;right = node; 删除数据 单向循环链表 删除p = p-\u0026gt;next的值给p \u0026amp; 跳过p-\u0026gt;next p-\u0026gt;value = p-\u0026gt;next-\u0026gt;value; Node *t = p-\u0026gt;next; p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; 双向循环链表 p-\u0026gt;left-\u0026gt;right = p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left = p-\u0026gt;left; Node *t = p; p = p-\u0026gt;right; delete t; 哈希表 key-\u0026gt;哈希函数-\u0026gt;索引≈内存位置-\u0026gt;value\n哈希冲突 = 不同key计算的索引相同 拉链法（开散列法）多键值索引到同一位置 在该位置建立链表 闭散列法 所有记录记录在散列表中 发生冲突则根据某方式继续探查 堆 树 每个节点的键值都大于等于/小于root节点的键值\n大于等于的为最小化堆 反之为最大化堆（左子大于右子）\n二叉堆 结构：完全二叉树（以下以最大化堆为例） 插入：最下层最右叶子插入 向上调整 复杂度O(logn) 删除（root）：root与最后的节点交换 向下调整 向下调整 = 子节点中最大的与新root交换 复杂度O(logn) 实现：在序列中 Hi的子节点为H2i与H2i+1 void up(int x) { while (x \u0026gt; 1 \u0026amp;\u0026amp; h[x] \u0026gt; h[x / 2]) { std::swap(h[x], h[x / 2]); x /= 2; } } void down(int x) { while (x * 2 \u0026lt;= n) { t = x * 2; if (t + 1 \u0026lt;= n \u0026amp;\u0026amp; h[t + 1] \u0026gt; h[t]) t++; if (h[t] \u0026lt;= h[x]) break; std::swap(h[x], h[t]); x = t; } } 建堆：向上/向下调整 向上调整 从叶子开始向堆上部移动 复杂度O(nlogn) 向下调整 从root开始向堆下部移动 复杂度O(n) 二叉树 二叉搜索树 左子\u0026lt;root\u0026lt;右子\n删除元素：若有两个非空子节点 用左子树的最大值/右子树的最小值代替它后删除\n平衡树 每个节点的左子树和右子树高度差最多为1\n调整过程 右旋 root左子成为新root root成为新root的右子 新root原右子成为root左子 TreeNode* newRoot = root-\u0026gt;left; root-\u0026gt;left = newRoot-\u0026gt;right; newRoot-\u0026gt;right = root; 四种平衡破坏情况 LL RR省略 LR 左子的右子树过长 RL 右子的左子树过长（类上） AVL树 平衡的二叉搜索树\n性质：\nAVL的左右子树也是AVL树 且左右子树高度相差不大于1（平衡因子 = 右子树高 - 左子树高） 树高logn 调整：若平衡因子=-2 == 左子左旋后root右旋 B树 每个节点可以拥有两个以上的子节点 增删改查在对数时间完成\n最下层的节点称为叶子节点 性质：（m阶）\n每个节点最多有m个子节点 非叶子节点（除root）最少有m/2个子节点 若root不是叶子节点 则至少有2个子节点 排序 冒泡排序 对序列逐个扫描 n次扫描后排序完毕\n最坏\u0026amp;平均情况下时间复杂度O(n^2^) 最好情况下时间复杂度O(n)\nbool flag = true; while (flag) { flag = false; for (int i = 1; i \u0026lt; n; ++i) { if (a[i] \u0026gt; a[i + 1]) { flag = true; int t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; } } } 插入排序 最坏\u0026amp;平均情况下时间复杂度O(n^2^) 最好情况下时间复杂度O(n)\\\n从头开始遍历每个需插入的数据 与其前已排序的数据的末尾向头逐一比较 for (int i = 1; i \u0026lt; len; ++i) { int key = arr[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } 折半插入 二分算法优化 时间复杂度不变 快速排序 将数列划分为2parts 递归到两子序列中进行快排 = 挖坑填数\n最优/平均时间复杂度O(nlogn) 最坏O(n^2^)\n若选第一个数为基准数 数组首尾两指针 i\u0026amp;j\n从j开始向前找小于或等于基准数的 放到原基准数的位置\n从i开始向后找大于基准数的 放到原j的位置\n以此循环 最后i=j放入基准数\n在前后两parts再继续进行以上步骤\n三数取中：前中后三个数先排序——中与后换（后的前一个也可以）——从 前 到 后的前一个 进行大小判断（前指针先动）——后和指针位置处数字交换——重复\n排序后再选pivot while内每一步也要限定i\u0026lt;j或i\u0026lt;=j（且放在\u0026amp;\u0026amp;号之前） void quick_sort(int s[],int l,int r){ if(l\u0026lt;r) { int i=l,j=r,base=s[l]; while(i\u0026lt;j){ while(i\u0026lt;j\u0026amp;\u0026amp;s[j]\u0026gt;base) j--; if(i\u0026lt;j){ s[i++]=s[j]; } while(i\u0026lt;j\u0026amp;\u0026amp;s[i]\u0026lt;=base) i++; if(i\u0026lt;j){ s[j--]=s[i]; } } } s[i]=base; quick_sort(s,l,i-1); quick_sort(s,i+1,r); } 优化：\n三路快速排序 三路取中（首、中、尾三元素进行比较后选择base） 与base相等的元素聚集在其周边 短序列用插排 归并排序 时间复杂度O(nlogn) 空间复杂度O(n) 类似快排，但快排将数组分为大小两半 省略了最后将两部分数组合二为一的步骤\n堆排序 二叉堆 = 完全二叉树（/近似） 最大堆/最小堆 时间复杂度：$O(nlogn)$ 空间复杂度：$log(n)$ 递归使用栈的空间代价\n拥有一个arr 对arr建最大堆——只检查倒数第二行及以上，使用heapify 循环检查 从最后一个数字检查到第二行（即不包括root）——将root与当前数字交换后，从顶向下heapify 过程中可以将len\u0026ndash;（后面的已经检查过了） heapify：左子右子定义——检查parent是否比左子右子大——否 则将其与最大值交换后向下继续heapify（更新被交换的子的子树） public static void main(String[] args) { int[] arr={6,3,8,2,9,4,7,1,5}; int len=arr.length; buildMaxHeap(arr,len); for(int i=len-1;i\u0026gt;0;i--){ swap(arr,0,i); len--; heapify(arr,0,len); } System.out.println(Arrays.toString(arr)); } public static void buildMaxHeap(int[] arr,int len) { for(int i=len/2;i\u0026gt;=0;i--){ heapify(arr,i,len); } } public static void heapify(int[] arr,int i,int len) { int left=i*2+1; int right=i*2+2; int largest=i; if(left\u0026lt;len \u0026amp;\u0026amp; arr[left]\u0026gt;arr[largest]) largest=left; if(right\u0026lt;len\u0026amp;\u0026amp; arr[right]\u0026gt;arr[largest]) largest=right; if(largest!=i){ swap(arr,largest,i); heapify(arr,largest,len); } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 计数排序 原理：确定数组中max min，所有元素排入count[value-min]中，相同元素则count加一。 插入完毕，count[n]+=count[n-1]——为了确定在新数组中的位置 从后向前遍历原数组（相同元素插入时从前向后，取出时从后向前符合index） 在新数组中的count[n]-1位置（数组从0开始但count最小位为1）放入arr[i]，count[n]减一 基数排序 原理：从每个数的个位到十位到最高位依次排序，排进0-9的队列中，一直到max的最高位 计数\u0026amp;基数\u0026amp;桶 计数：每个桶放单一键值 基数：根据键值的每位数字分配桶（桶的映射函数方法不同） 桶：每个桶存储一定范围的数值 特殊应用 康托展开 数学方法 详见wiki\n应用：LC.60排列排序permutation-sequence\n","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"部分代码来自：OI WIKI，链接见文章","title":"数据结构"},{"content":" 存储引擎 MySql体系结构 MySql服务器 flowchart LR 连接层--\u0026gt;服务层 服务层\u0026lt;--\u0026gt;SQL接口 服务层\u0026lt;--\u0026gt;解析器 服务层\u0026lt;--\u0026gt;查询优化器 服务层\u0026lt;--\u0026gt;缓存 SQL接口--\u0026gt;d((可插拔式存储引擎)) 解析器--\u0026gt;d 查询优化器--\u0026gt;d 缓存--\u0026gt;d d--\u0026gt;存储层 存储引擎包括InnoDB等，Index信息也存储在其中 存储层存储系统文件、文件和日志等 存储引擎 存储引擎简介 存数据、建索引、更新数据等的实现方式，基于表不基于库（被称为表类型）\n建表时指定存储引擎\nCREATE TABLE 表名( … \\)ENGINE=INNODB … SHOW ENGINES; 显示支持的存储引擎\n存储引擎特点 InnoDB DML操作遵循ACID模型 支持事务 行级锁 提高并发访问性能 支持外键 以.idb表空间文件存储该表的表结构(frm sdi)、数据与索引 用cmd打开 idb2sdi ***.idb 查看表结构 数据段即为B+树的叶子节点 索引段为非叶子节点 flowchart LR Tablespace--\u0026gt;Segment--\u0026gt;Extent--\u0026gt;Page--\u0026gt;row 表空间--\u0026gt;段--\u0026gt;区--\u0026gt;页--\u0026gt;行 MyISAM 不支持事务 外键 支持表锁 不支持行锁 访问速度快 ✕✕.sdi 存储表结构信息 ✕✕.MYD 存储数据 ✕✕.MYI 存储索引 Memory 存储在内存中 只做临时文件\n内存存放 hash索引 ✕✕.sdi 存储表结构 比较 特点 InnoDB MyISAM Memory 事务安全 支持 - - 锁机制 行锁 表锁 表锁 支持外键 支持 - - B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持 支持 - 空间使用 高 低 N/A 内存使用 高 低 中 批量插入速度 低 高 高 选择 InnoDB 事务完整性\u0026amp;并发条件 各种操作都很多 MyISAM 以读\u0026amp;插入操作为主 少更新\u0026amp;删除 对事务的完整性与并发性要求不高(被ControlDB取代) Memory 临时表的缓存 对表的大小有限制 安全性没有保障(被Redis取代) 索引 索引概述 帮MySql高效获取数据的数据结构（有序） 在存储引擎中实现 优点： 提高查询效率 降低IO成本 降低排序成本 降低CPU消耗 缺点： 占用磁盘空间 降低更新表的速度 索引结构 主要索引： 索引结构 描述 B+Tree索引 大部分引擎都支持 最常见 Hash索引 不支持范围查询 精确匹配索引列的查询才有效 R-Tree(空间索引) MyISAM的特殊索引 用于地理空间数据类型 Full-text(全文索引) 建立倒排索引 快速匹配文档 支持引擎： 索引 InnoDB MyISAM Memory B+Tree 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree 不支持 支持 不支持 Full-text 支持 支持 不支持 一般索引直接指B+Tree索引 B+Tree\u0026amp;其它Tree 二叉树：左子小于亲点 右子大于亲点 顺序插入时会形成链表 大数据量下 层级较深 效率低 红黑树：新数据会先与根节点判断大小 大数据量下 层级较深 B Tree(多路平衡查找树)： 最大度数为n，最多n个子节点，每个节点最多存储n-1个key(元素)，n个指针 中间节点向上分裂 B+Tree 所有元素都会出现在叶子节点(树只起到索引作用) 所有叶子节点形成单向链表 B+Tree in MySql 增加了指向相邻叶子节点的链表指针 形成带顺序指针的B+Tree 一页(一个磁盘块)只存放指针和key不存放数据，则一页上可以存放的指针与key相比BTree更多，故层级更少 Hash 键值换算成新的hash值 映射到对应槽位 存储在hash表中 hash冲突(多个键值映射到同个槽位)时用链表解决 特点： 只能用于对等比较 不支持范围查询 无法利用索引进行排序 查询效率高 通常只需一次检索 通常效率高于B+Tree 索引分类 分类： 索引 含义 特点 关键字 主键索引 针对主键创建的 默认自动创建 onlyone PRIMARY 唯一索引 避免同表中某列数据的值重复 可有多个 UNIQUE 常规索引 快速定位特定数据 可多个 全文索引 查找文本关键词 非比较索引中的值 可多 FULLTEXT 根据索引的存储形式分类： 聚集索引 将数据存储与索引放到一起 索引的叶子节点保存行数据(有且仅有1个) 聚集索引选取规则：主键\u0026gt;第一个唯一索引\u0026gt;innoDB生成rowid作为隐藏聚集索引 二级索引 将数据与索引分开存储 叶子节点关联对应主键(可有多个) 如建立name的索引 叶子节点即存储id 回表查询 eg.查询Satti的所有信息 先二级索引查主键 后聚集索引查row信息 索引语法 CREATE [UNIQUE/FULLTEXT] INDEX 索引名 ON 表名 (字段名,…); 创建索引 字段名后可指定升降序建立索引 索引名一般为 idx_表名_字段名1_字段名2 可以关联多个字段 SHOW INDEX FROM 表名[\\G]; 查看索引 \\G可以把以行显示的索引转换为列显示 DROP INDEX 索引名 ON 表名; 删除索引 SQL性能 性能分析 SHOW GLOBAL STATUS LIKE'Com____' 查询命令(Delete等)执行频次 SHOW GLOBAL STATUS提供服务器状态 7个下划线 慢查询日志 记录超过指定时间的SQL语句 SHOW VARIABLES LIKE'SLOW_QUERY_LOG‘; 检查慢查询日志是否开启 开启慢查询日志： 在MySql配置文件/etc/my.cnf中配置\n#开启慢查询 slow_query_log=1\n#设置慢日志时长\nlong_query_time=2 查看记录信息 /var/lib/mysql/localhost-slow.log profile详情 SELECT @@have_profiling; 是否支持profile操作 开启profile SET PROFILING=1 SHOW PROFILES; 查看所有指令耗时 SHOW PROFILES [CPU] FOR QUERY query号; 查看某个query的耗时(与cpu消耗) explain执行计划 在select语句前加 desc 或 explain id select查询的序列号（操作顺序） id相同 顺序从上到下 id不同 值越大越先执行 type 性能指标从好到差： NULL\u0026gt;system\u0026gt;const(以上较好)\u0026gt;eq_ref\u0026gt;ref\u0026gt;range\u0026gt;index\u0026gt;all 主键/唯一索引==const possible_key 可能用到的索引 key 实际用到的索引 key_len 索引字段最大可能长度 rows 预估执行查询的行数 filtered 返回结果行数占读取行数的比例(越大越好) 索引使用原则 最左前缀法则 联合索引时遵守\n查询从索引的最左列开始 且不跳过索引中的列（即从联合索引的第一个字段开始） 若跳过索引中某字段 则后面的字段失效 范围查询 联合索引时遵守\n即\u0026gt; \u0026lt;等范围限定 若出现 其右侧列索引失效 若使用\u0026gt;=或\u0026lt;=则不存在此问题 失效问题 索引列运算 若对索引中的字段进行运算 索引失效 包括substring等 字符串不加引号 字符串类型字段若不加引号 索引失效 模糊查询 尾部模糊查询 不失效 头部模糊查询 索引失效 or连接 or中一条件中的字段有索引 + 另一列无索引 = 索引失效 数据分布影响 如索引效率不如全表扫描时 启用全表扫描 SQL提示 EXPLAIN select语句 USE INDEX(索引名) 建议使用某索引 EXPLAIN select语句 IGNORE INDEX(索引名) 不用某索引 EXPLAIN select语句 USE INDEX(索引名) 必用某索引 覆盖索引 需要返回的列在索引中可全部找到 \u0026ldquo;using where;using index\u0026rdquo; 在列 \u0026ldquo;using index condition\u0026rdquo; 需回表查询 前缀索引 字段类型为varchar text等 需索引很长字符串——前缀索引 CREATE INDEX 索引名 ON 表名(COLUMN(N)); 创建前缀索引 N为前缀长度 选择性计算：COUNT(DEISTINCT SUBSTRING(字段名,m,n))/COUNT(\\)* 根据选择性取舍选择N的大小 单列与联合索引的选择 业务场景中存在多个查询条件 建议采用联合索引 单列易产生回表查询 索引设计原则 数据量较大（\u0026gt;几十万） 查询频繁 常作为where、order by、group by条件的字段 区分度高的列（相对唯一 如身份证号等） 若为字符串类型 字段长度较长——前缀索引 尽量使用联合索引 控制索引数量 若索引列不能有NULL 建表时即规定NOT NULL 便于优化器选用索引 SQL优化 插入优化 基本优化 批量插入(500-1000条) 手动提交事务 主键顺序插入 大批量插入数据\n# 客户端连接服务端时加\u0026ndash;LOCAL-INFILE\nMYSQL --LOCAL-INFILE -U ROOT -P;\n# 设置全局参数为1 允许从本地加载文件导入数据\nSET GLOBAL LOCAL_INFILE=1;\n# 执行load加载数据\nLOAD DATA LOCAL INFILE '数据地址' INTO TABLE '表名' FIELDS TERMINATED BY ',' LINES TERMINATED BY '\\n'; linux命令行：head 文件名查看文件前十行 主键优化 数据组织方式 InnoDB中 表数据按主键顺序组织存放 此种表即为索引组织表(IOT) 页分裂 （页中存放的是行数据）\n每个页包含2~n个数据（若1个 则相当于一个链表） 根据主键排列 若乱序插入 可能发生页分裂 前一页后50%部分与新数据挪至新页 新页插入前一页与后一页间 页合并 当页中删除的row达到MERGE-THRESHOLD（默认50%） InnoDB会寻找靠近的页进行合并 MERGE-THRESHOLD 合并页的阈值 可自定义 主键设计原则 尽量降低主键长度（占用的字节大小） 尽量顺序插入（自增主键） 尽量不用UUID（通用唯一识别码）或其它自然主键（如身份证号）为主键 因为无序 避免修改主键 order by优化 Extra显示 Using index 通过索引排序 Using filesort 不可通过索引直接返回排序结果 索引升序创建时 若倒序排序则需filesort 优化 根据排序字段建立合适索引 多字段排序时也遵循最左前缀 尽量使用覆盖索引\u0026amp;注意升降序设定 不可避免出现filesort大数据量排序时 适当增加排序缓冲区sort_buffer_size大小 group by优化 extra显示 Using temporary 使用临时表（性能低） Using index 使用索引 满足最左前缀 limit优化（分页） limit不能用在in/all/any/some子语句中==多表查询 将limit的结果视为新表 覆盖索引 + 子查询 原表与分页查到的主键id表联合查询name等索引覆盖的字段 count优化 MyISAM将表的总行存在磁盘中 效率高 InnoDB需将数据从引擎中读出后累计计数 优化思路 自己计数（设定计数器cnt） 用法 count(*) 不取值 直接累加 count(主键) 取主键id值 按行累加 主键不可能为NULL count(字段) 字段为NULL时 count不加1 字段有not null约束时 不需判断null count(1) 可以取-1等 服务层对返回的每一行放1（或-1）进去 后逐行累加 效率：字段 \u0026lt; 主键id \u0026lt; 1 \u0026lt; * update优化 update优先行锁（有索引字段时 锁住该行）若无索引 执行表锁 InnoDB的行锁针对索引 视图 虚拟存在的表 只保存查询的逻辑不保存结果\n视图语法 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED |LOCAL] CHECK OPTION]\n创建视图（OR REPLACE或替换视图） SHOW CREATE VIEW 视图名\n查看创建视图语句\nSELECT * FROM 视图名\n查看视图 类似表 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED/LOCAL] CHECK OPTION]\n修改视图（REPLACE为主要）\nALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED/LOCAL] CHECK OPTION]\n修改视图 DROP VIEW [IF EXISTS] 视图名称 删除视图 检查选项 WITH [CASCADED/LOCAL] CHECK OPTION 使之后对视图进行的增删改操作符合视图最初的定义 CASCADED/LOCAL 检查依赖视图的规则 保持一致性 二者限定的范围不同 CASCADED （若v1未指定视图检查 但为v2的依赖视图 也会检查v1）检查所有亲辈的限制 无论其是否指定 LOCAL 若v1未指定 则不检查v1 视图更新 可更新的视图：视图中的行与基础表的行一一对应 包含 聚合/DISTINCT/GROUP BY/HAVING/UNION/… 的视图不可更新 视图作用 简单 简化理解\u0026amp;操作（复杂且多次使用到的检索可以形成视图） 安全 可以只查看某表的部分内容（授权只能精确到表） 数据独立 屏蔽基表变化对查看信息带来的影响 存储过程 SQL语言的代码封装与重用\n特点 封装 复用 可以接收参数 返回数据 减少应用途径与数据库间的网络交互 提升效率 语法 创建存储过程 CREATE PROCEDURE 存储过程名([参数列表])* BEGIN ——SQL语句 END; 命令行中解决遇 ; 即停问题：用delimiter 某符号指定语句结束位置 在DataGrip中存储为routines 中文“例程”\nCALL 存储过程名([参数列表]) 调用存储过程 SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='表名';\n查询指定数据库的存储过程与状态\nSELECT CREATE PROCEDURE 存储过程名\n查询某存储过程的定义 DROP PROCEDURE 存储过程名 删除存储过程 变量 系统变量 由服务器提供 分为全局变量GLOBAL与会话变量SESSION（仅在当前会话 即当前控制台 生效） 默认SESSION 系统重启后全局参数失效 可在/etc/my.cnf中配置 SHOW [SESSION/GLOBAL] VARIABLES;\n查看所有系统变量\nSHOW [SESSION/GLOBAL] VARIABLES LIKE '…';\n模糊匹配\nSELECT @@[SESSION/GLOBAL] 系统变量名;\n查看指定变量的值 系统变量用@@ SET [SESSION/GLOBAL] 系统变量名=值\nSELECT @@[SESSION/GLOBAL] 系统变量名=值\n设置系统变量 SET SESSION AUTOCOMMIT =0 切换到手动提交 用户自定义变量 不用提前声明 通过“@变量名”使用(未定义时调用返回null) 作用域为当前\nSET @变量名=值;\nSET @变量名:=值;\nSELECT @变量名=值;\n赋值 可多个同时赋值\nSELECT 字段名 INTO @变量名 FROM 表名; 将字段名结果赋值给变量 SELECT @变量名 使用变量 局部变量 作用域在begin…end块之间 先声明后调用\nDECLARE 变量名 变量类型 [DEFAULT …]; 声明（有否默认值） SET 变量名 := 值\nSELECT 字段名 INTO 变量名 FROM 表名;\n为变量赋值 条件判断\u0026amp;循环 if IF 条件1 THEN …; ELSEIF 条件2 THEN …; ELSE …; END IF; 用SELECT语句显示返回值\n参数 类型 类型 含义 备注 IN 输入 调用时传入值 默认 OUT 输出 可为返回值 INOUT 输入\u0026amp;输出 CREATE PROCEDURE 存储过程名([IN/OUT/INOUT 参数名 参数类型]) case CASE [变量] WHEN … THEN …; … ELSE … END CASE; while WHILE 条件 DO SQL逻辑 END WHILE 条件为true时进行 repeat REPEAT SQL逻辑 UNTIL 条件 END REPEAT 先执行一次逻辑 若条件满足则停止循环 loop [begin_label:] LOOP … END LOOP [end_label]; 配合语句： LEAVE LABEL; 退出循环 ITERATE LABEL; 只可在循环中使用 跳过当前循环剩下的语句进入下一次循环 游标\u0026amp;条件处理程序 游标 暂时存储查询结果集的数据类型（集合）\nDECLARE 游标名 CURSOR FOR 查询语句; 声明游标 OPEN 游标名 打开游标 FETCH 游标名 INTO 变量; 获取游标记录（可以是多个变量） CLOSE 游标名 关闭游标 使用游标记录结果集 开启游标通过循环获取游标内的数据 条件处理程序 定义在流程控制结构执行过程中遇到问题的处理步骤\nDECLARE 处理动作 HANDLER FOR 状况值 … statement; 处理动作： CONTINUE 继续执行当前程序 EXIT 终止 状况值： SQLSTATE 状态码 可用下列替代 SQLWARNING（01开头的状态码） NOT FOUND（02开头的状态码） SQLEXCEPTION（除以上两种的其它） 存储函数 有返回值 参数必为IN类型（应用少）\nCREATE FUNCTION 存储函数名([参数列表]) RETURNS 数据类型 [characteristic] BEGIN ——SQL语句 END; characteristic：（二级日志开启 默认需加）\nDETERMINISTIC 相同输入产生相同结果 NO SQL 不包含SQL语句 READ SQL DATA 包含读取数据的语句 不包含写入数据的语句 触发器 触发器定义 与表有关的数据库对象。在insert/update/delete之前或之后，触发并执行其定义的语句（多为记录数据变更日志） OLD与NEW引用触发器中发生变化的记录内容 如insert用NEW；update用OLD（引用需修改的内容）与NEW（引用修改后的内容） 只支持行级触发器 不支持语句级触发 触发器语法 CREATE TRIGGER 触发器名 BEFORE/AFTER INSERT/… ON 表名 FOR EACH ROW——行级触发器 BEGIN 语句（将修改的内容放入新建的日志表中） END; 创建触发器 “语句”为将新操作记录插入日志表（自建） 可以记录插入的详细信息 用 concat() 拼接字符串 SHOW TRIGGERS; 查看触发器 DROP TRIGGER [数据库名.]触发器名; 删除触发器 锁 概述 协调多进程或线程并发访问某资源的机制 事务中进行 分类 全局锁 数据库中所有表 表级锁 行级锁 全局锁 通常用做全数据库的逻辑备份\n语法 FLUSH TABLES WITH READ LOCK 加全局锁 MYSQLDUMP -UROOT -P1234 数据库名\u0026gt;保存地点 备份数据库 在命令行中运行 非mysql语句 用户名root 密码1234 UNLOCK TABLES 释放锁 特点（不重要） 若主库备份 备份期间不能更新主库 若从库备份 备份期间从库不能执行主库同步来的二进制日志 导致主从延迟 MYSQLDUMP --SINGLE-TRANSACTION -UROOT -P1234 数据库名\u0026gt;保存地点 不需加全局锁的备份 表级锁 锁定粒度大 发生所冲突的概率最高 并发度最低\n分类： 表锁 元数据锁 意向锁 表锁 分类： 表共享读锁 表独占写锁 LOCK TABLES 表名… READ/WRITE 加锁 读锁 所有客户端都可读 不可写 写锁 当前客户端可读 / 写 其他客户端不可读 / 写 UNLOCK TABLES 释放锁 元数据锁(meta data lock,MDL) 系统自动控制\n维护表元数据的数据一致性==表上有活动事务时不可对元数据进行写入 避免DML与DDL冲突 MySql5.5后 DML增删改查加读锁 DDL对表结构变更加写锁 SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM PERFORMANCE_SCHEMA.METADATA_LOCKS; 查看元数据锁 意向锁 使表锁不用检查每行数据是否加行锁 避免DML执行时行锁与表锁冲突 分类： 意向共享锁(IS) 意向排他锁(IX) SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM PERFORMANCE_SCHEMA.DATA_LOCKS;\n查看锁 日志中RECORD锁类型代表行锁 意向锁间不互斥\nIS 意向共享锁 由SELECT语句 LOCK IN SHARE MODE添加 与表锁共享读锁(read)兼容 与表锁排它写锁(write)互斥 IX 意向排他锁 由增删改语句 FOR UPDATE添加 与表锁共享读锁(read)互斥 与表锁排它写锁(write)互斥 行级锁 锁定粒度最小 锁冲突改率最低 并发度最高 在InnoDB存储引擎中应用\n分类： 行锁 锁定单个行记录——在RC RR隔离级别下都支持（包括共享锁与排他锁） 间隙锁 确保索引记录间隙不变 防止insert产生幻读——在RR下支持 临键锁 行锁+间隙锁（该行之前的间隙）——RR下支持 行锁类型 SQL 行锁类型 说明 增删改 排他锁 自动加 SELECT语句 无锁 SELECT加共享锁 共享锁S 手动 SELECT…FOR UPDATE 排他锁X 手动 行锁 InnoDB使用next-key（临键锁）进行搜索与索引扫描 以防止幻读\n针对唯一索引检索时 对存在的记录进行等值匹配（通过 “=” 检索）时会自动将next-key锁优化为行锁 InnoDB中不通过索引检索数据会升级为表锁 间隙锁\u0026amp;临键锁 理解 唯一索引的等值查询 给不存在的记录加锁时 优化为间隙锁 普通索引的等值查询 向右遍历到最后一个值不满足查询需求时 临键锁退化为间隙锁 唯一索引的范围查询 访问到不满足条件的第一个值为止（加锁） 间隙锁可以共存（只为防止其它事务插入间隙so） InnoDB引擎 理解 整体架构 内存架构 直接操作\n缓冲池 Buffer Pool Change Buffer 对非唯一的二级索引进行修改 操作存储在此（先到缓冲池 后到磁盘） Adaptive Hash Index 优化对缓冲池数据的查询(自动生成) 用SHOW VARIABLES LIKE '%HASH_INDEX%';查看其是否启用（模糊匹配） Log Buffer 日志缓冲区 保存要写入磁盘的log INNODB_LOG_BUFFER_SIZE查看大小 INNODB_FLUSH_LOG_AT_TRX_COMMIT刷新到磁盘的时机（可设置0 1 2 具体含义略） 磁盘结构 System Tablespaces系统表空间 主要存放Change Buffer %DATA_FILE_PATH%模糊匹配 General Tablespaces通用表空间 需在创建表时指定 CREATE TABLESPACE创建该表空间 Undo Tablespaces撤销表空间 自动创建两个 Temporary Tablespaces临时表空间 DoubleWrite Buffer Files双写缓冲区（缓冲池刷新到磁盘前先写入此） Redo Log重做日志 实现事务持久性（包括重做日志缓冲 储存在内存中） 后台线程 将缓冲区数据刷新到磁盘中\nMaster Thread核心后台线程 调度其他线程 IO Thread 负责IO请求的回调 Purge Thread 回收事务已提交的undo log Page Cleaner Thread减轻主线程刷新脏页的压力 事务原理 redo log 刷新脏页到磁盘发生错误时进行数据恢复（物理日志） undo log 回滚日志（逻辑日志） 记录数据被修改前的信息 MVCC需要 MVCC⭐ 多版本并发控制 Multi-Version Concurrency Control\n基本概念 当前读 读取记录数据的最新版本并对记录加锁 共享锁/排他锁/增删改 快照读 读取记录数据的可见（历史）版本 不加锁 RC隔断下 每次select生成一个快照读 RR 开启事务后第一个select才是快照读 S 快照读退化为当前读 MVCC 维护一个数据的多个版本 使读写操作没有冲突 快照读为其提供非阻塞读功能 依赖于： 数据库记录中的三个隐式字段 undo log readView 实现原理 三个隐式字段 （InnoDB隐式生成）\n隐藏字段 含义 DB_TRX-ID 最近修改事务ID DB_ROLL_PTR 回滚指针 指向这条记录的上个版本 配合undo log DB_ROW_ID 隐藏主键 若无指定主键则生成此字段 undo log日志（增删改时产生便于数据回滚的日志）\ninsert 只在回滚时需要log 事务提交后可被删除 删改 在回滚与快照读时需要（不会被立即删除） 生成undo log版本链 头部是最新的历史记录 尾部是最旧的历史记录 ReadView 记录并维护系统当前活跃（未提交）的事务id（MVCC提取数据的依据）\n四个核心字段 字段 含义 m_ids 当前活跃事务ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID（当前最大事务ID+1 自增） creator_trx_id ReadView创建者的事务ID 版本链数据访问规则（当前事务ID为trx_id 即DB_TRX_ID）理解 只可符合下列四个条件 若都不符合 则换下一条undo log trx_id==creator_trx_id ✔ 说明数据由当前事务更改 trx_id\u0026lt;min_trx_id ✔ 说明数据已提交 trx_id\u0026gt;max_trx_id ✖ 事务在RV生成后才开始 min_trx_id\u0026lt;=trx_id\u0026lt;=max_trx_id 且trx_id不在m_ids中 ✔ 说明数据已提交 RC隔离级别 事务中每次执行快照读时生成ReadView RR隔离级别 事务中第一次执行快照读时生成 后复用 MySql管理 系统数据库 自带四个数据库 数据库 作用 mysql 服务器运行需要的信息（时区 主从 用户 权限等） information_schema 访问元数据的表、视图等 performance_schema 底层监控服务器运行状态 收集其性能参数 sys 方便DBA 便于性能调优与诊断的视图 常用工具 MySQL 数据库名 -e \u0026quot;执行语句\u0026quot; -e执行sql语句并退出 适用于shell脚本 mysqladmin -uroot -p****** … 查看帮助文档并进行相关操作 mysqlbinlog log1 查看二进制日志文件 mysqlshow … 查找数据库/表/列/索引等 mysqldump [options] db_name备份数据库 mysqllimport或source 客户端数据（mysqldump加-T参数导出的文本文件）导入 🎉🎉 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/mysql/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"存储引擎\"\u003e存储引擎\u003c/h2\u003e\n\u003ch3 id=\"mysql体系结构\"\u003eMySql体系结构\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eMySql服务器\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart LR\n连接层--\u0026gt;服务层\n服务层\u0026lt;--\u0026gt;SQL接口\n服务层\u0026lt;--\u0026gt;解析器\n服务层\u0026lt;--\u0026gt;查询优化器\n服务层\u0026lt;--\u0026gt;缓存\nSQL接口--\u0026gt;d((可插拔式存储引擎))\n解析器--\u0026gt;d\n查询优化器--\u0026gt;d\n缓存--\u0026gt;d\nd--\u0026gt;存储层\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e存储引擎包括InnoDB等，\u003c!-- raw HTML omitted --\u003eIndex\u003c!-- raw HTML omitted --\u003e信息也存储在其中\u003c/li\u003e\n\u003cli\u003e存储层存储系统文件、文件和日志等\n\u003cimg loading=\"lazy\" src=\"2.jpg\" alt=\"系统结构图\"  title=\"系统图\"  /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"存储引擎-1\"\u003e存储引擎\u003c/h3\u003e\n\u003ch4 id=\"存储引擎简介\"\u003e存储引擎简介\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e存数据、建索引、更新数据等的实现方式，基于表不基于库（被称为表类型）\u003c/p\u003e","title":"MySql"},{"content":" 简介 NoSql 非关系型数据库 No Structured Relational\n特点： 表型 JSON型 图型==非结构化 Redis为键值类型 JSON表==数据无关联 查询方式==非SQL（语法不统一） 事务ACID无法全部满足==BASE 存储==内存 使用场景： 数据结构不固定 对一致性 安全性要求不高 性能要求 Redis 特征： 键值型 key-value 支持多种数据结构 单线程 命令具原子性 低延迟 内存 IO多路复用 编码风格 支持数据持久化 支持主从集群 分片集群（主表\u0026amp;从表） 多语言客户端 redis-cli -h 192.168.211.129 -p 6379 -a 密码\n启动（不安全） systemctl stop redis关闭 连接虚拟机与图形化界面失败=检查防火墙\n基本语法 不区分大小写\n数据结构 value类型 基本类型：String Hash List（可重复） Set SortedSet（排序集合 不可重复） 特殊类型：GEO（地理坐标） BitMap HyperLog 帮助文档 or 命令行 help\n通用命令 用help 命令名查看命令的具体使用方法\nKEYS查看符合模板pattern如a**的所有key（以a开头的key） 慢 DEL删key 会返回删除的个数 EXISTS判断是否存在 EXPIRE设置key的有效期 TTL查看key的剩余有效期 类型\u0026amp;命令 String 分类 类型 数据结构 string 字符串 int 整型 float 浮点数 常见命令 命令 作用 SET 添加/修改键值对 GET 由key得value MSET/MGET 批量操作 INCR 整型key自增1 INCRBY 整型自增指定步长 INCRBYFLOAT 浮点类型自增指定步长 SETNX 添加String键值对 前提key不存在 SETEX 添加String键值对 指定有效期 SETNX==SET key value NX\n返回0表示键值已存在不会添加\n返回1表示不存在已添加 层级结构 key的层级结构：用:隔开\n若值为Java对象 可用JSON形式存储： eg.'{\u0026quot;id\u0026quot;:1, \u0026quot;name\u0026quot;:\u0026quot;Satti\u0026quot;, \u0026quot;age\u0026quot;:20}'单引 Hash类型 无序字典 类HashMap CRUD 增删改查\n相对String类型的JSON字符串 可以将每个字段独立存储 KEY保存键名 VALUE中field保存字段名 value保存值 常见命令 命令 作用 HSET 添加/修改hash类型一对field\u0026amp;value HGET hash类型由key得filed HMSET/HMGET 对一个key批量操作 HGETALL 由key得所有field value HKEYS key中所有field HVALS key中所有value HINCRBY 字段值按指定步长自增 HSETNX 添加field 前提field不存在 List类型 类似LinkedList 但双向链表\n特征：有序 可重复 插入删除快 查询速度一般 常见命令 命令 作用 LPUSH/RPUSH 列表左/右侧插入 LPOP/RPOP 移除左/右侧第一个 LRANGE 返回一段角标范围内的所有元素 BLPOP/BRPOP 没有元素时等待指定的时间 移除时无元素 返回nil 角标 = 序号 从0开始 Set类型 类HashSet =\u0026gt; value为null的HashMap\n特征： 无序 不可重复 查找快 支持交并差集 常见命令： 命令 作用 SADD 向set添加元素 可多个 SREM 移除指定元素 SCARD 返回元素个数 SISMEMBER 是否有某元素 SMEMBERS 返回所有value 命令 作用 SINTER 求两键交集 SDIFF key1相对于key2不同的值（差集） SUNION 并集 SDIFF中key有先后顺序 SortedSet 类TreeSet（可排序的set） 数据结构不同\n每个元素具有score属性 通过属性排序=SkipList+Hash 特性： 可排序 元素不重复 查询速度快 常见命令：ZADD ZREM ZCARD ZINCRBY ZDIFF ZINTER ZUNION add时提示NX|XX NX-不存在时才插入该键 XX-存在时才插入该键 命令 作用 ZSORE 获取指定元素score ZRANK 获取指定元素排名 ZCOUNT score在某范围内的元素个数 ZRANGE 按score排序得指定排名范围内元素 ZRANGEBYSCORE 指定score范围内 默认升序排序 Z后加REV即为降序 Jedis 开启测试后通过new对象建立连接\njedis=new Jedis(ip,port);\n设置密码\njedis.auth(password)\n选择库\njedis.select(index) SpringDataRedis RedisTemplate工具类 redisTemplate.opsForValue()类似语句调用上述数据类型\n返回值类型如ValueOperations 步骤： 引入spring-boot-starter-data-redis依赖 application.yaml配置Redis 编写RedisTemplate配置类 设置@Bean test中Autowired注入RedisTemplate\u0026amp;进行Test试验 函数opsForValue()等调用value等对象（方法名有变动） StringRedisTemplate手动序列化\u0026amp;反序列化 节省内存 可以json形式存储、读取数据 or 编码为字符串类型 使用函数StringRedisSerializer 以对象形式初始化、接收 故需要手动进行序列化转换 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/redis%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/","summary":"数据类型与基础操作","title":"Redis_base"},{"content":" 基本概念 RDBMS 关系型数据库 based on关系模型，多张二维表相互连接 sql操作分类 分类 全称 说明 DDL Data Definition Language 定义数据库、表、字段等 DML Manipulation 对表中数据进行增删改 DQL Query 查询表的记录 DCL Control 创建库用户 控制权限 启动与停止 net start mysql80 \u0026amp; net stop mysql80\nMySql 开机自启，在cmd中可手动停止 mysql -u root -p\n-u 提示用户为 root，-p 提示将输入密码 SQL 基本 以分号结尾，行数不论，空格与缩进不论 不区分大小写，关键字最好大写 \u0026ndash; 或 # 注释内容 多行注释 /* 内容 */ DDL DDL数据库操作 SHOW DATABASES;\n查询所有数据库 SELECT DATABASE();\n查询当前（是在哪个）数据库 创建数据库（括号内容可以不加 采用默认规则） CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; charset utf8mb4 设定为容纳4个字节的utf8 在DataGrip中可以使用SCHEMA替代DATABASE DROP DATABASE [IF EXISTS] 数据库名;\n删除数据库 USE 数据库名;\n使用数据库 DDL表操作 查询 SHOW TABLES;\n查询当前数据库所有表 DESC 表名 查询表结构 SHOW CREATE TABLE 表名 查询指定表的建表语句 创建 CREATE TABLE 表名( 字段1 字段1类型[COMMENT '中文'], 字段2 字段2类型[COMMENT '……'], …… 字段3 字段3类型[COMMENT '……'] )[COMMENT '……']; 字段1 是表头名称，如name 字段1类型： 数值类型 tinyint,smallint,mediumint,int-4字节,bigint,float,double tinyint unsigned表示无符号 即正数范围 可指定double(m,n)，m表示最长位数，n表示小数点后最长位数 字符串 char(指定长度),varchar(指定长度), char为定长字符串，varchar变长(会计算所需空间是否需要变化) 日期 date,time,datetime,year,timestamp(截至2038年) 修改 ALTER TABLE 表名 ADD 字段名 字段类型 [COMMENT 注释] [约束]; 增加字段 ALTER TABLE 表名 MODIFY 字段名 新字段类型 [COMMENT 注释]; 修改字段类型 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段类型 [COMMENT 注释]; 修改字段名\u0026amp;字段类型 ALTER TABLE 表名 RENAME TO 新表名 修改表名 删除 ALTER TABLE 表名 DROP 字段名; 删除字段 DROP TABLE [IF EXISTS] 表名; 删除表 TRUNCATE TABLE 表名; 删除并重新创建该表 DataGrip中字段翻译为列\nDML 添加数据 INSERT INTO 表名(字段名1,字段名2,…) VALUES (值1,值2,…); 指定字段添加数据 INSERT INTO 表名 VALUES (值1,值2,…); 全部字段添加数据 此处括号为分隔符号，不可省略，[]表示可以忽略 Sql 以某数据库为原点，若需修改某表，在指令中需指明该表名 字符串与时间类型用 '…' 表示 修改删除 UPDATE 表名 SET 字段名1=值1,字段名2=值2,…[WHERE 条件]; 条件可以写为 id=1 等 DELETE FROM 表名 [WHERE 条件] 不能删除某个对象中特定字段的值（只能删除行） 没有被物理删除 被标记为删除使其空间可被♻ DQL 用*表示显示所有信息，放在其它特殊检索内容前\n基本查询 SELECT 字段1，字段2，… FROM 表名; SELECT * FROM 表名 查询多个字段 SELECT 字段1 [AS 别名1],字段2 [AS 别名2],… FROM 表名; 设置别名(显示在搜索结果的表头) SELECT DISTINCT 字段列表 FROM 表名; 显示查询到的非重复结果 条件查询 SELECT 字段列表 FROM 表名 WHERE 条件列表 条件类型： 比较运算 \u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;或!=表示不等于 所有数据类型适用（包括日期） BETWEEN … AND … 含最大最小值的范围 前小后大 数据有先后顺序 IN(…) 列表中的值 LIKE 占位符 模糊匹配 _表示单字符 %表示任意个字符 IS NULL 或 IS NOT NULL 逻辑运算 AND 或 \u0026amp;\u0026amp; OR 或 || NOT 或 ! 聚合函数\u0026amp;分组查询 SELECT 聚合函数(字段列表) FROM 表名;\n常见聚合函数： 函数 功能 count 统计数量 max 最大 min 最小 avg 平均 sum 求和 SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\n“字段列表”可以写聚合函数\u0026amp;搜索的字段名（可显示表头） 执行顺序：WHERE\u0026gt;聚合函数\u0026gt;HAVING 聚合函数(某) 别名 起别名方法 聚合函数多半可以直接写为 SUM(\\*) 排序查询 SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;\n排序方式： ASC 升序(默认) DESC 降序 字段1，字段2有先后顺序 分页查询 SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;\n起始索引从0开始，为查询页的起始id\n第一页可以写为 LIMIT 查询记录数 顺序 编写顺序： SELECT$\\rightarrow$FROM$\\rightarrow$WHERE$\\rightarrow$GROUP BY$\\rightarrow$HAVING$\\rightarrow$ORDER BY$\\rightarrow$LIMIT DCL 管理用户 USE mysql SELECT * FROM user 查询用户 CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 创建用户 主机名为 % 表示可在任意主机访问 ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 修改密码 DROP USER '用户名'@'主机名'; 删除用户 权限控制 常用权限类型： 权限 说明 ALL(PRIVILEGES) 所有权限 SELECT 查询 INSERT 插入 UPDATE 修改 DELETE 删除 ALTER 修改表 DROP 删除库/表/视图 CREATE 创建库/表 SHOW GRANTS FOR '用户名'@'主机名'; 查询权限 GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 授予权限 权限列表写 ALL 作通配 REVOKE 权限列表 ON 数据库名.表名FROM '用户名'@'主机名'; 撤销权限 数据库、表用\\*作通配 函数 使用 SELECT 函数 进行函数试验\n字符串函数 常用函数：\n函数 功能 CONCAT(S1,S2,…,Sn) 拼接字符串 LOWER(str) 全小写 UPPER(str) 全大写 LPAD(str,n,pad) pad从左填充str到n长度 RPAD(str,n,pad) pad从右填充str到n长度 TRIM(str) 去头尾空格 SUBSTRING(str,start,len) 返回str从start处起的len个字符 字符串从1开始 非0 主要结合前文语法进行应用 数值函数 常见函数：\n函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) x/y的模 RAND() 0~1内随机数 ROUND(x,y) x四舍五入 y位小数 日期函数 常见函数：\n函数 功能 CURDATE() 当前日期 CURTIME() 当前时间 NOW() 当前日期与时间 YEAR(date) 获得date的年份 MONTH(date) date的月份 DAY(date) date的日 DATE_ADD(date,INTERVAL expr type) date加上时间间隔expr后的时间 DATEDIFF(date1,date2) date1到date2的天数 DATE_ADD 中 expr 可为数字 type可为 DAY 流程控制函数 常用函数：\n函数 功能 IF(v,t,f) v为true返回t 否之为f IFNULL(value1,value2) v1不为空则返回v1 否之为v2 CASE WHEN [val1] THEN [res1] … ELSE [default] END v1真则返回res1 否之为d CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END expr等于v1返回res1 否之为d val1处不能并列多个val 用此类函数做筛选不用加where，格式为：==SELECT \\*,(CASE …) AS '别名' FROM 表名== 约束 约束概述 目的：保证数据库中数据的正确有效与完整\n约束分类 约束 描述 关键字 非空约束 该字段数据不为null NOT NULL 唯一约束 该字段所有数据不重复 UNIQUE 主键约束 一行数据的唯一标识 非空且唯一 PRIMARY KEY 默认约束 未指定则采用默认值 DEFAULT 某 检查约束 保证字段满足某条件 CHECK id int PRIMARY KEY AUTO_INCREMENT主键且自动增长(多个约束用空格隔开) 作用于表中字段 创建/修改表时添加 一般把序号设为主键 外键约束 让两表数据建立连接 保证数据完整一致\n具有外键的表=子表 被关联的表=亲表\n格式：\n创建时添加 [CONSTRAINT] [外键名] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) 修改时添加 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) 外键名是给外键自定义的新名字 注意数据类型需完全相同 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 删除外键\n[ON UPDATE 模式 ON DELETE 模式] 在添加语句后指定删除/更新模式\n模式 说明 NO ACTION 有外键则不允许更新 RESTRICT 同上 CASCADE 亲子表同时更新 SET NULL 亲表删除 子表设null SET DEFAULT 子表设为默认(Innodb不支持) 多表查询 多表关系 一对多：建立外键连接 eg.员工\u0026amp;部门 多对多：建立第三表 至少包含两外键 分别关联两方主键 eg.学生\u0026amp;课程 一对一：任意一方加外键 并设置为UNIQUE 多用于单表拆分 基础字段在一表 详情字段在另一表 UNIQUE 在定义id的时候添加 eg.用户\u0026amp;用户详情 多表查询概述 并列多表时需要消除无效的笛卡尔积情况(指A*B) 分类： flowchart LR; test((连接查询)) test--\u0026gt;内连接 test--\u0026gt;外连接 test--\u0026gt;自连接 多表查询--\u0026gt;test 多表查询--\u0026gt;子查询 外连接--\u0026gt;左外连接 外连接--\u0026gt;右外连接 内连接 返回A B表的交集\nSELECT 字段列表 FROM 表1,表2 WHERE 条件 …; 隐式内连接 条件类似employee.dept_id=dept\\.id SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件 …; 显式内连接 外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 …; 左外连接 查询左表与交集部分的数据 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 …; 左外连接 右表\u0026amp;交集 自连接 SELECT 字段列表 FROM 表1 别名1 JOIN 表1 别名2 ON 条件 …; 可内连接也可外连接 联合查询 SELECT 字段列表 FROM 表1 … UNION [ALL] SELECT 字段列表 FROM 表2 …; 有ALL结果直接合并 无ALL去重 字段列表与类型相同 子查询（嵌套查询） 外部可以是INSERT/UPDATE/DELETE/SELECT 根据子查询结果的不同分类： 名称 意义 标量子查询 结果为单个值 列子查询 结果为一列 行子查询 为一行 表子查询 多行多列 可在WHERE/FROM/SELECT之后进行 列子查询 返回一列结果 常用操作符： 操作符 用途 ==IN== 集合范围之内 多选一 NOT IN 不在集合范围内 ANY 任意一个满足 SOME 同ANY ALL 所有值都满足 行子查询 常用操作符 =、\u0026lt;\u0026gt;、IN、NOT IN 可以用 (1200,1)=(salary,manager) 表示一一对应 表子查询 常用操作符 IN 事务 操作 简介：一组操作的集合 整体提交 自动开始 SELECT @@AUTOCOMMIT; 开始事务(自动提交) SELECT @@AUTOCOMMIT=0; …… COMMIT; 手动提交事务 ROLLBACK; 事务回滚 手动开始 START TRANSACTION; 开启事务 COMMIT; 提交事务 ROLLBACK; 回滚事务 特性 原子性 不可分割的最小操作单元 一致性 事务完成时所有数据保持一致状态 隔离性 数据库的隔离机制，事务进行不受外部并发操作影响 持久性 提交或回滚后，数据的改变是永久的 ==ACID模型== 并发事务问题 脏读 一个事务读到另一个事务未提交的数据 不可重复读 先后读取同一记录但数据不同 幻读 按条件查询数据，无对应数据行，但插入数据时发现该行数据已存在 事务隔离级别 分类： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED ✔ ✔ ✔ READ COMMITTED ✖ ✔ ✔ REPEATABLE READ(默认) ✖ ✖ ✔ SERIALIZABLE ✖ ✖ ✖ ORACLE默认READ COMMITTED 性能递减 安全性递增 SELECT @@TRANSACTION_ISOLATION; 查看事务隔离级别 SET [SESSION或GLOBAL] TRANSACTION ISOLATION LEVEL {隔离级别}; 设定隔离级别 SESSION为当前连接 GLOBAL为全局，不包含当前连接 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/mysql_base/","summary":"DDL与DML","title":"MySql基础"},{"content":"\u003c!DOCTYPE html\u003e Bi-RRT及改良 \u0026nbsp;\n\u0026nbsp;\nBi-RRT 原理 基本名词 状态空间：系统全部可能状态的集合 RRT原理 RRT(Rapidly exploring Random Tree 快速随机搜索树)是一种全局规划算法\n已知：\n初始状态（起点位置）qstartq_{start}qstart​ 目标状态（终点位置）qgoalq_{goal}qgoal​ 搜索步长 ρ{\\rho}ρ 系统状态空间 CCC 自由状态空间 CfreeC_{free}Cfree​ Cfree⊂CC_{free}{\\subset}CCfree​⊂C，是 CCC 中不会发生碰撞的状态集合 目标状态空间 CgoalC_{goal}Cgoal​ 有 kkk 个节点的快速随机搜索树 TkT_kTk​ 过程：\n生成随机点：在自由状态空间 CfreeC_{free}Cfree​ 中随机采一个状态点 qrandq_{rand}qrand​，同时保证 qrand∉Tkq_{rand}{\\notin}T_kqrand​∈/Tk​ 查找最近点：遍历现有的随机搜索树 TkT_kTk​ 寻找与 qrandq_{rand}qrand​ 最近的节点 qnearq_{near}qnear​，满足：DIS(qnear,qrand)\u0026lt;=DIS(qi,qrand)DIS(q_{near},q_{rand})\u0026lt;=DIS(q_i,q_{rand})DIS(qnear​,qrand​)\u0026lt;=DIS(qi​,qrand​)，其中 qrand∈Tkq_{rand}{\\in}T_kqrand​∈Tk​ 计算新节点：从 qnearq_{near}qnear​ 向 qrandq_{rand}qrand​ 方向拓展距离 ρ{\\rho}ρ 得到 qnewq_{new}qnew​，检查该路径是否会发生碰撞。 若会发生碰撞，返回1. 不会发生碰撞，则将 qnewq_{new}qnew​ 添加到 TkT_kTk​ 中 计算公式：\nqnew\u0026nbsp;=qnear\u0026nbsp;+εqrand\u0026nbsp;−qnear\u0026nbsp;∥qrand\u0026nbsp;−qnear\u0026nbsp;∥q_{\\text {new }}=q_{\\text {near }}+\\varepsilon \\frac{q_{\\text {rand }}-q_{\\text {near }}}{\\left\\|q_{\\text {rand }}-q_{\\text {near }}\\right\\|}qnew\u0026nbsp;​=qnear\u0026nbsp;​+ε∥qrand\u0026nbsp;​−qnear\u0026nbsp;​∥qrand\u0026nbsp;​−qnear\u0026nbsp;​​ 到达检查：若节点 qnewq_{new}qnew​ 实现 DIS(qnew,qgoal)\u0026lt;ρDIS(q_{new},q_{goal})\u0026lt;{\\rho}DIS(qnew​,qgoal​)\u0026lt;ρ，证明已经到达终点，添加 qgoalq_{goal}qgoal​ 到 TkT_kTk​ ，搜索结束。若 DIS(qnew,qgoal)\u0026gt;ρDIS(q_{new},q_{goal})\u0026gt;{\\rho}DIS(qnew​,qgoal​)\u0026gt;ρ，返回1. 得到路径：从 qgoalq_{goal}qgoal​ 开始反向回溯亲节点直到 qstartq_{start}qstart​，形成完整路径 LLL graph LR 生成随机点--\u0026gt;生成新节点 生成新节点--\u0026gt;碰撞检查 生成新节点-----\u0026gt;到达检查 到达检查--\u0026gt;|不成功|重新生成随机点 碰撞检查---\u0026gt;|不成功|重新生成随机点 碰撞检查--\u0026gt;|成功|扩展树 扩展树--\u0026gt;重新生成随机点 到达检查---\u0026gt;|成功|结束 Bi-RRT原理 从起点、终点同时开始随机搜索树的构建\n另外已知：\n从起点开始构建的随机搜索树的新节点为 qnew−startq_{new-start}qnew−start​ 从终点开始构建的随机搜索树的新节点为 qnew−goalq_{new-goal}qnew−goal​ 从起点开始构建的随机搜索树为 Tk−startT_{k-start}Tk−start​ 从终点开始构建的随机搜索树为 Tk−goalT_{k-goal}Tk−goal​ 将上文RRT构建过程的4.到达检查修改为如下检查:\n若节点 qnew−startq_{new-start}qnew−start​ 实现 DIS(qnew−start,qnew−goal)\u0026lt;ρDIS(q_{new-start},q_{new-goal})\u0026lt;{\\rho}DIS(qnew−start​,qnew−goal​)\u0026lt;ρ，\n证明已经到达终点，添加 qnew−goalq_{new-goal}qnew−goal​ 到 Tk−goalT_{k-goal}Tk−goal​ ，搜索结束。若 DIS(qnew−start,qnew−goal)\u0026gt;ρDIS(q_{new-start},q_{new-goal})\u0026gt;{\\rho}DIS(qnew−start​,qnew−goal​)\u0026gt;ρ，返回1. 将上文RRT构建过程的5.得到路径修改为如下过程:\n从 qnew−goalq_{new-goal}qnew−goal​ 开始同时向起点、终点回溯亲节点直到 qstartq_{start}qstart​ 与 qgoalq_{goal}qgoal​，形成完整路径 RRT-Connect原理 与Bi-RRT大致相同\n相对于Bi-RRT，RRT-Connect虽然也是起终点同时开始两条路径，但是从起点方向生成随机点，\n用终点的随机搜索树向其进行拓展，反之亦然 分析 出入 （生成随机点）程序实际在 CCC 中随机采样，也未避免其在 TkT_kTk​ 中；可能造成冗余，在狭窄复杂环境中可能会导致收敛速度减慢 其他问题 （生成随机点）在整个自由状态空间任何位置以相同概率生成随机点，缺少对目标点的指向性 （计算新节点）任何节点的拓展距离都相同，缺少空间敏感性 eg.在空旷位置可以适当增长拓展距离 （计算新节点）遇到障碍时回退到1.生成随机点，可以考虑不回退，通过更换方向避障 （到达检查）用 DIS(qnew,qgoal)\u0026lt;ρDIS(q_{new},q_{goal})\u0026lt;{\\rho}DIS(qnew​,qgoal​)\u0026lt;ρ 进行到达检查，可能在终点 附近需要不同的标准 改进点 （生成随机点）引入人工势场/其他方法提高随机点指向性 \u0026amp; 在自由状态空间中生成随机点 （查找最近点）最近点的度量方式在基础算法中是最基础的几何距离，可以更改度量方式 剪枝处理——生成的路径有较多折角与累赘路径，可进行剪枝处理 对得到的路径 LLL，从 qgoalq_{goal}qgoal​（视为当前起始点 qnowq_{now}qnow​）开始分别与其后的节点连接并进行碰撞检查 若在连接 qnowq_{now}qnow​ 与某节点 qcollisionq_{collision}qcollision​ 时发生碰撞，回退到 qcollisionq_{collision}qcollision​ 的亲节点 qno−collision−nearq_{no-collision-near}qno−collision−near​，\n并连接 qnowq_{now}qnow​ 与 qno−collision−nearq_{no-collision-near}qno−collision−near​ 形成新路径的一部分 从 qno−collisionq_{no-collision}qno−collision​ 开始重复3.1.，直到某个 qnowq_{now}qnow​ 连接到 qgoalq_{goal}qgoal​ （到达检查）根据实例对到达检查精度进行修改 路径折角多，可通过样条曲线对路径进行光顺 \u0026amp; 生成路径时进行转角优化 源码中转角通过角度常量进行简单约束，可考虑结合运动方程 实现 生成随机点 def get_random_node(x_min, x_max, y_min, y_max, goal_point=None): # 此处在目标点方向增加生成概率 if goal_point is not None and random.random() \u0026lt;= 0.2: x = goal_point[0] y = goal_point[1] else: x = random.uniform(x_min, x_max) y = random.uniform(y_min, y_max) rnd_node = Node(x, y) return rnd_node 查找最近点 def get_nearest_node_index(node_list, rnd_node): dlist = [] # 遍历随机搜索树 for node in node_list: dis = calc_p2p_dis(node, rnd_node) dlist.append(dis) minind = dlist.index(min(dlist)) # 返回距离最近的点 return minind 计算新节点 def generate_new_node(nearest_node, random_node, extend_length): new_node = Node(nearest_node.x, nearest_node.y) d = math.sqrt((random_node.x - nearest_node.x) ** 2 + (random_node.y - nearest_node.y) ** 2) if extend_length \u0026gt; d: extend_length = d dx = random_node.x - nearest_node.x dy = random_node.y - nearest_node.y if dx * dx + dy * dy == 0: return random_node # 新节点计算公式 new_node.x += extend_length / math.sqrt(dx * dx + dy * dy) * dx new_node.y += extend_length / math.sqrt(dx * dx + dy * dy) * dy # 建立节点的连接（亲节点） new_node.parent = nearest_node return new_node 碰撞检查（圆形/矩形障碍物） def check_collision(node1, node2, obstacleList): for [ox, oy, size] in obstacleList: round = Node(ox, oy) # 增加障碍物的半径为size_new 避免实际情况下的碰撞 size_new = size if node2 is None: return False if calc_p2p_dis(node1, round) \u0026lt;= size_new: return True # 发生碰撞 if calc_p2p_dis(node2, round) \u0026lt;= size_new: return True # 若点线距小于“半径”且该线段可能出现在圆内 if calc_p2l_dis(node1, node2, round) \u0026lt;= size_new and calc_triangle_deg(node1, round, node2) \u0026lt;= 90 and \\ calc_triangle_deg(node2, round, node1) \u0026lt;= 90: return True elif len(obstacle) == 4: # 矩形障碍物用内置函数判断 rect_shape = box(obstacle[0], obstacle[1], obstacle[2], obstacle[3]) if not isinstance(node1, list): line = LineString([(node1.x, node1.y), (node2.x, node2.y)]) else: line = LineString([(node1[0], node1[1]), (node2[0], node2[1])]) if line.intersects(rect_shape): return True return False # 不碰撞 Bi-RRT到达检查与路径生成 # 每次生成一轮（两个）新节点后都对整个路径进行遍历，检查两个路径中可否各有一个点相连生成路径 for node1 in node_list1: for node2 in node_list2: if calc_p2p_dis(node1, node2) \u0026lt;= extend_length and \\ check_collision(node1, node2, obs_list) == False: # 生成从起点到相交点的路径 path1 = [] node = node1 while node is not None: path1.append([node.x, node.y]) node = node.parent path1.reverse() # 反转路径，使其从起点开始 # 生成从终点到相交点的路径 path2 = [] node = node2 while node is not None: path2.append([node.x, node.y]) node = node.parent # 合并两条路径 path = path1 + path2 此处可以优化为只用新生成的点来试验能否连上（已完成 与上文程序类似 省略）\n剪枝 def prune_path(path, obs_list): pruned_path = [path[0]] i = 0 while i \u0026lt; len(path) - 1: found = False # 从终点开始验证 找到第一个不碰撞的（反之有漏洞 for j in range(len(path) - 1, i, -1): if not check_collision(path[i], path[j], obs_list): pruned_path.append(path[j]) # 更新起点 i = j found = True break if not found: # 确保路径前进 i += 1 if pruned_path[-1] != path[-1]: pruned_path.append(path[-1]) return pruned_path 效果 单向RRT\u0026amp;不剪枝\n单向RRT\u0026amp;剪枝\n双向RRT\u0026amp;剪枝\n适用 基于随机采样的树形路径规划算法\n适用于非凸高维状态空间 \u0026amp; 动态环境 可以快速生成可行路径 容易处理包含障碍物、差分运动约束的场景 差分运动约束——每个约束条件由其中两个变量作差构成 需得出满足所有约束条件的解 无需梯度信息 适用未知环境（目标函数未知） Bi-RRT* 原理 在Bi-RRT的基础上增加重写（rewrite）与重布线（rewire）功能\n另外已知：\n生成的随机点 qrandq_{rand}qrand​ 随机搜索树上距离随机点最近的树节点 qnearq_{near}qnear​ 从树节点延伸出来的新节点 qnewq_{new}qnew​ 重写操作搜索范围 RwriteR_{write}Rwrite​ 重布线操作搜索范围 RwireR_{wire}Rwire​ 随机搜索树上每个节点 qqq 关联的成本 C(q)C(q)C(q)，定义为：\nC(q)=C(qparent)+DIS(qparent,q)C(q)=C(q_{parent})+DIS(q_{parent},q)C(q)=C(qparent​)+DIS(qparent​,q) 过程：\n重写Rewrite 潜在亲节点集合：在Bi-RRT方法的步骤3.计算新节点确认 qnewq_{new}qnew​ 有效性后，在以 qrandq_{rand}qrand​ 为圆心， RwriteR_{write}Rwrite​ 为半径的范围内寻找随机搜索树 TkT_kTk​ 上所有节点，并将节点集合视为 qrandq_{rand}qrand​ 潜在的亲节点集合 QnearQ_{near}Qnear​ 更新亲节点：计算通过 QnearQ_{near}Qnear​ 中每个亲节点到 qnewq_{new}qnew​ 的成本 C(Qnew)C(Q_{new})C(Qnew​) 选择成本最小的节点为 qnewq_{new}qnew​ 的新亲节点，更新 TkT_kTk​。即满足：\nC(qnew\u0026nbsp;)=min⁡{C(qnear\u0026nbsp;)+DIS⁡(qnear\u0026nbsp;,qnew\u0026nbsp;)∣qnear\u0026nbsp;∈Qnear\u0026nbsp;}C\\left(q_{\\text {new }}\\right)=\\min \\left\\{C\\left(q_{\\text {near }}\\right)+\\operatorname{DIS}\\left(q_{\\text {near }}, q_{\\text {new }}\\right) \\mid q_{\\text {near }} \\in Q_{\\text {near }}\\right\\}C(qnew\u0026nbsp;​)=min{C(qnear\u0026nbsp;​)+DIS(qnear\u0026nbsp;​,qnew\u0026nbsp;​)∣qnear\u0026nbsp;​∈Qnear\u0026nbsp;​} 重布线Rewire 计算成本：重写Rewrite的2.操作后，以 qnewq_{new}qnew​ 为圆心， RwireR_{wire}Rwire​ 为半径的范围内寻找随机搜索树 TkT_kTk​ 上所有节点 Qnear′Q_{near}'Qnear′​，逐个比较将这些节点的亲节点设置为 qnewq_{new}qnew​ 的成本与原成本 C(qnear′)C(q_{near}')C(qnear′​) 更新亲节点：满足下式时将 qnear′q_{near}'qnear′​ 的亲节点更新为 qnewq_{new}qnew​：\nC(qnew)+DIS(qnew,qnear′)\u0026lt;C(qnear′)∣qnear′∈Qnear′C(q_{new})+DIS(q_{new},q_{near}')\u0026lt;C(q_{near}') \\mid q_{{near}}' \\in Q_{{near}}'C(qnew​)+DIS(qnew​,qnear′​)\u0026lt;C(qnear′​)∣qnear′​∈Qnear′​ 继续Bi-RRT的4. 5.步骤 分析 优化 相比Bi-RRT，以每个新节点为中心，在小区域内更新亲节点选择最优情况（以新节点为主要优化对象），放大到全路径实现整体优化 改进方案 更新成本函数定义，可以引入外部变量对成本进行把控 搜索区域范围大小可更新，搜索区域形状等也可根据实际需要具体调整 RRT算法对障碍物的动态、静态并无要求，只通过避碰函数进行障碍物判断（其他时候无影响），可以引入动障碍进行试验 实现 重写Rewrite\ndef rewrite_index(node_new, node_list, obstacle_list): r = 8 # 搜索范围 min_cost = float('inf') min_node_index = None for i, node in enumerate(node_list): # 确定潜在亲节点集合 if calc_p2p_dis(node_new, node) \u0026lt; r and not check_collision(node_new, node, obstacle_list): # 计算成本函数 potential_cost = node.cost + calc_p2p_dis(node_new, node) # 根据成本函数更新亲节点索引 if potential_cost \u0026lt; min_cost: min_cost = potential_cost min_node_index = i return min_node_index 重布线Rewire\ndef rewire(node_new, node_list, obstacle_list): r = 30 # 搜索范围 for node in node_list: # 排除node_new的亲节点 if node != node_new.parent and calc_p2p_dis(node_new, node) \u0026lt; r: potential_cost = node_new.cost + calc_p2p_dis(node, node_new) # 根据成本函数更新亲节点 if potential_cost \u0026lt; node.cost and check_collision(node, node_new, obstacle_list) is False: # if potential_cost \u0026lt; node.cost: node.parent = node_new node.cost = potential_cost 效果 Bi-RRT*\n相较Bi-RRT，路径折角减少，优化效果较为明显 \u0026nbsp;\nBi-RRT*加剪枝\n相较Bi-RRT加剪枝，明显减少路径节点，路径更简单 适用 解决RRT难以求解最优的可行路径的问题\n引入路径成本 通过最小化路径成本提升路径质量 渐进地向全局最优解收敛 Bi-RRT*+DWA DWA原理 引入机器人运动方程 相当于对机器人运动路径的模拟\n已知变量 假设为全向移动机器人 机器人移动速度：vx,vyv_x, v_yvx​,vy​ 速度空间：v,ωv, \\omegav,ω，以下列出可能限制速度的因素： 自身能到达的所有矢量速度：\nVs={(v,ω)∣v∈[vmin⁡,vmax⁡]∧ω∈[ωmin⁡,ωmax⁡]}V_{\\mathrm{s}}=\\left\\{(v, \\omega) \\mid v \\in\\left[v_{\\min }, v_{\\max }\\right] \\wedge \\omega \\in\\left[\\omega_{\\min }, \\omega_{\\max }\\right]\\right\\}Vs​={(v,ω)∣v∈[vmin​,vmax​]∧ω∈[ωmin​,ωmax​]} 受电机性能影响——设定加速度的最大最小值（包括刹车）后在一定时间内能到达的速度：\nVd={(v,ω)∣v∈[vc−v˙bΔt,vc+v˙aΔt]∧ω∈[ωc−ω˙bΔt,ωc+ω˙aΔt]}V_d=\\left\\{(v, \\omega) \\mid v \\in\\left[v_c-\\dot{v}_b \\Delta t, v_c+\\dot{v}_a \\Delta t\\right] \\wedge \\omega \\in\\left[\\omega_c-\\dot{\\omega}_b \\Delta t, \\omega_c+\\dot{\\omega}_a \\Delta t\\right]\\right\\}Vd​={(v,ω)∣v∈[vc​−v˙b​Δt,vc​+v˙a​Δt]∧ω∈[ωc​−ω˙b​Δt,ωc​+ω˙a​Δt]} 障碍：\nVa={(v,ω)∣v≤2dist⁡(v,ω)v˙b∧ω≤2dist⁡(v,ω)ω˙b}V_a=\\left\\{(v, \\omega) \\mid v \\leq \\sqrt{2 \\operatorname{dist}(v, \\omega) \\dot{v}_b} \\wedge \\omega \\leq \\sqrt{2 \\operatorname{dist}(v, \\omega) \\dot{\\omega}_b}\\right\\}Va​={(v,ω)∣v≤2dist(v,ω)v˙b​​∧ω≤2dist(v,ω)ω˙b​​} 评价函数：\nG(v,ω)=σ(α∗heading⁡(v,ω)+β∗dist⁡(v,ω)+γ∗vel⁡(v,ω))G(v, \\omega)=\\sigma(\\alpha * \\operatorname{heading}(v, \\omega)+\\beta * \\operatorname{dist}(v, \\omega)+\\gamma * \\operatorname{vel}(v, \\omega))G(v,ω)=σ(α∗heading(v,ω)+β∗dist(v,ω)+γ∗vel(v,ω)) heading(v,ω)heading(v,\\omega)heading(v,ω) 方位角评价函数——轨迹末端朝向与目标点间的角度差距 dist(v,ω)dist(v,\\omega)dist(v,ω) 距离评价函数——路径末端与最近障碍物的距离 velocity(v,ω)velocity(v,\\omega)velocity(v,ω) 当前机器人的线速度 αβγσ\\alpha \\beta \\gamma \\sigmaαβγσ为权重系数 原理 速度空间动态窗口：在受限制的速度空间内进行采样，选择不同的v,ωv,\\omegav,ω 在一定时间段内根据运动学模型可生成多种轨迹 评价函数选择路径：通过评价函数对所有可能轨迹打分 选择最优路径 Bi-RRT*+DWA原理 根据已知障碍物通过Bi-RRT*方法生成路径 机器人沿路径开始运动，选择Δt\\Delta tΔt，对机器人前方ΔL\\Delta LΔL长度的路径进行碰撞检测 若碰撞检测通过，不采用DWA方法；若不能通过，进入DWA状态进行动态障碍物避碰 DWA避碰状态下，以最近的路径点为goal，并不断更新，直到进入到达域 分析 剪枝后的路径进行dwa优化效果更好 否则每个目标点寻找的耗时长\n运动方程：以上机器人运动方程需要用水下机器人的运动方程进行优化，影响速度、角速度的因素可以根据水下机器人的转角限制、运动限制等进行限定 障碍物限定条件：速度限定中，受障碍物影响的限定方程现在采用最简单的x=12av2x=\\frac{1}{2}av^2x=21​av2，可以根据实际情况进行优化，也可以考虑结合check-collision函数 评价函数：评价函数暂时选择方位角、与最近障碍物的距离与线速度三方面进行评价，可以考虑引入其它物理量并对权重系数通过相关公式等进行优化 算法结合：两算法可以通过其它方法进行结合 也可以根据其它物理量的评价（如与障碍物的距离）决定当前情况是否引入DWA/退出DWA 参数优化：根据机器人实际情况调整相关参数（如最大速度等） 实现 DWA方法\n计算动态窗口\nVs = [self.config['min_speed'], self.config['max_speed'], -self.config['max_yawrate'], self.config['max_yawrate']] Vd = [x[3] - self.config['max_accel'] * self.config['dt'], x[3] + self.config['max_accel'] * self.config['dt'], x[4] - self.config['max_dyawrate'] * self.config['dt'], x[4] + self.config['max_dyawrate'] * self.config['dt']] dw = [max(Vs[0], Vd[0]), min(Vs[1], Vd[1]), max(Vs[2], Vd[2]), min(Vs[3], Vd[3])] return dw 评估函数计算并选出最优路径\nx_init = x[:] min_cost = float(\"inf\") best_u = [0.0, 0.0] best_trajectory = np.array(x) # evaluate all trajectory with sampled input in dynamic window for v in np.arange(dw[0], dw[1], self.config['v_reso']): for y in np.arange(dw[2], dw[3], self.config['yawrate_reso']): trajectory = self.calc_trajectory(x_init, v, y) to_goal_cost = self.calc_to_goal_cost(trajectory, goal) speed_cost = self.config['speed_cost_gain'] * (self.config['max_speed'] - trajectory[-1, 3]) ob_cost = self.calc_obstacle_cost(trajectory, obstacles) final_cost = to_goal_cost + speed_cost + ob_cost if min_cost \u0026gt;= final_cost: min_cost = final_cost best_u = [v, y] best_trajectory = trajectory return best_u, best_trajectory 运动学方程\nx[2] += u[1] * self.config['dt'] x[0] += u[0] * np.cos(x[2]) * self.config['dt'] x[1] += u[0] * np.sin(x[2]) * self.config['dt'] x[3] = u[0] x[4] = u[1] return x 效果 避障\n\u0026nbsp;\n完整规划\n","permalink":"https://Sattiluvcat.github.io/en/posts/else/bi-rrt/bi-rrt/","summary":"\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\n      \u003ctitle\u003eBi-RRT及改良\u003c/title\u003e\n      \u003cmeta charset=\"utf-8\"\u003e\n      \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n      \n      \u003clink rel=\"stylesheet\" href=\"file:///c:\\Users\\lingl\\.vscode\\extensions\\shd101wyy.markdown-preview-enhanced-0.8.15\\crossnote\\dependencies\\katex\\katex.min.css\"\u003e\n      \n      \n      \u003cscript type=\"text/javascript\" src=\"file:///c:\\Users\\lingl\\.vscode\\extensions\\shd101wyy.markdown-preview-enhanced-0.8.15\\crossnote\\dependencies\\mermaid\\mermaid.min.js\" charset=\"UTF-8\"\u003e\u003c/script\u003e\n      \n      \n      \u003cstyle\u003e\n      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,\"Liberation Mono\",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)\u003ecode[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body\u003e:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body\u003ep{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body\u003eol,html body\u003eul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li\u003ep{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote\u003e:first-child{margin-top:0}html body blockquote\u003e:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\\00a0'}html body pre\u003ecode{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers\u003ecode{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows\u003espan{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows\u003espan:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}\n/* Please visit the URL below for more information: */\n/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */\n\n      \u003c/style\u003e\n      \u003c!-- The content below will be included at the end of the \u003chead\u003e element. --\u003e\u003cscript type=\"text/javascript\"\u003e\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    // your code here\n  });\n\u003c/script\u003e\u003c/head\u003e\u003cbody for=\"html-export\"\u003e\n    \n    \n      \u003cdiv class=\"crossnote markdown-preview  \"\u003e\n      \n\u003cp\u003e\u0026nbsp;\u003c/p\u003e","title":""},{"content":"\u003c!DOCTYPE html\u003e VF-RRT \u0026nbsp;\n\u0026nbsp;\n以下部分算法参考VF-RRT*\n原理 改进部分 新点的生成——随机点方向与当前位置向量场方向\n最优RRT路径——重复生成多条RRT路径后对每条路径计算上游系数的积分，选取能耗消耗最少的一条\n剪枝优化——比较剪枝与否得到的路径评分，判断是否进行剪枝（包括能耗影响、路径总转角、总长等）\nDWA优化——评分系统中引入上游系数\n生成新节点 确定方向向量：\n随机方向向量：计算从 qnearq_{\\text{near}}qnear​ 到 qrandq_{\\text{rand}}qrand​ 的方向向量 vrandv_{\\text{rand}}vrand​，并将其归一化为单位向量. 向量场方向向量：获取 qnearq_{\\text{near}}qnear​ 处的向量场方向 FFF，并将其归一化为单位向量 vfieldv_{\\text{field}}vfield​. 计算权重：确定向量场方向对随机方向的影响权重 www。权重的计算方法如下：\n计算 vrandv_{\\text{rand}}vrand​ 和 vfieldv_{\\text{field}}vfield​ 之间的夹角 θrand\\theta_{\\text{rand}}θrand​. 根据上游准则和指数分布的关系，计算新的夹角 θnew\\theta_{\\text{new}}θnew​. 使用正弦定理计算权重 www：\nw=∥vrand∥sin⁡(θrand−θnew)∥vfield∥sin⁡(θnew)w = \\frac{\\|v_{\\text{rand}}\\| \\sin(\\theta_{\\text{rand}} - \\theta_{\\text{new}})}{\\|v_{\\text{field}}\\| \\sin(\\theta_{\\text{new}})}w=∥vfield​∥sin(θnew​)∥vrand​∥sin(θrand​−θnew​)​ 确定新节点方向：根据权重 www，计算新的方向向量 vnewv_{\\text{new}}vnew​：\nvnew=vrand+wvfield∥vrand+wvfield∥v_{\\text{new}} = \\frac{v_{\\text{rand}} + w v_{\\text{field}}}{\\|v_{\\text{rand}} + w v_{\\text{field}}\\|}vnew​=∥vrand​+wvfield​∥vrand​+wvfield​​ 以上来自GPT总结。实际程序的权重计算中，简化了相关过程。 上游系数 根据柯西-施瓦茨不等式得到，上游系数是一个衡量能耗的指标，并非定量计算结果\nU(q)=∫0L(∥F(q(s))∥−⟨F(q(s)),q˙(s)⟩)ds\\mathcal{U}(q)=\\int_0^L(\\|F(q(s))\\|-\\langle F(q(s)), \\dot{q}(s)\\rangle) d sU(q)=∫0L​(∥F(q(s))∥−⟨F(q(s)),q˙​(s)⟩)ds 评分标准 主要考虑能耗水平、路径总长与累计转角等参数 实现 以下主要起到 demo 作用，有一些 TODO 尚未完成，并非最终版\n生成新节点\ndef vf_generate_new_node(nearest_node, random_node, extend_length, vector_field): # 获取最近节点到随机点的方向向量 direction_to_random = np.array([random_node.x - nearest_node.x, random_node.y - nearest_node.y]) # 不该出现0的情况（原来是回旋镖） if np.linalg.norm(direction_to_random)!=0: direction_to_random /= np.linalg.norm(direction_to_random) print(\"nearest_node:\", nearest_node.x, nearest_node.y) # 获取最近节点处的向量场方向 u, v = get_vector_field(nearest_node.x, nearest_node.y, vector_field) direction_vector_field = np.array([u, v]) # TODO 方向选取的优化 # 两个方向向量的加权平均方向 average_direction_vector = (direction_to_random*4 + direction_vector_field) / 5 # 归一化平均方向向量 average_direction_vector /= np.linalg.norm(average_direction_vector) # 根据这个平均方向生成新节点 new_x = nearest_node.x + extend_length * average_direction_vector[0] new_y = nearest_node.y + extend_length * average_direction_vector[1] new_node = Node(new_x, new_y) new_node.parent = nearest_node return new_node 计算上游系数\ndef upstream_criterion(path, vector_field): total_difference = 0 for i in range(1, len(path)): # 当前位置的向量场 u, v = get_vector_field(path[i][0], path[i][1], vector_field) vector_field_magnitude = np.sqrt(u**2 + v**2) # 本来已经归一化了 但是计算精度可能不准确 此处二加工 direction_vector_field = np.array([u, v]) / vector_field_magnitude # 当前速度方向——路径求导 direction_path = np.gradient(np.array(path), axis=0)[i] path_magnitude = np.linalg.norm(direction_path) # 归一化速度方向 --\u0026gt; 需要，因为向量场本身已经归一化 --\u0026gt; 应用不等式时两者模长相等，均为1 direction_path /= path_magnitude # Cauchy-Schwarz 不等式: |a · b| \u0026lt;= ||a|| * ||b|| dot_product = np.dot(direction_path, direction_vector_field) # 👆归一化后直接取 1 即可 total_difference += 1 * vector_field_magnitude - dot_product return total_difference 剪枝更新\ndef vf_prune_path(path, obs_list, vector_field): pruned_path = [path[0]] i = 0 while i \u0026lt; len(path) - 1: found = False for j in range(len(path) - 1, i, -1): # TODO 转角约束 if not check_collision(path[i], path[j], obs_list): # 现有优化路径+现在考虑的路径不剪枝形式 candidate_path = pruned_path + path[i:] # 计算路径评分——跳过 i 到 j 中间的路径 score_start_to_current = path_score(pruned_path + path[j:], vector_field) # 计算路径评分——已优化路径 score_current_to_previous = path_score(candidate_path, vector_field) # Compare the scores if score_start_to_current \u0026lt; score_current_to_previous: pruned_path.append(path[j]) i = j found = True break if not found: i += 1 if pruned_path[-1] != path[-1]: pruned_path.append(path[-1]) return pruned_path 剪枝评分\ndef path_score(path, vector_field): total_difference = 0 total_angle = 0 # TODO 评分细则 for i in range(len(path) - 1): # 最大值是 len(path) - 2 u, v = get_vector_field(path[i][0], path[i][1], vector_field) direction_vector_field = np.arctan2(v, u) direction_path = np.arctan2(path[i + 1][1] - path[i][1], path[i + 1][0] - path[i][0]) total_difference += abs(direction_path - direction_vector_field) if i \u0026lt; len(path) - 2: angle = abs(np.arctan2(path[i + 2][1] - path[i + 1][1], path[i + 2][0] - path[i + 1][0]) - direction_path) total_angle += angle return total_difference + total_angle ","permalink":"https://Sattiluvcat.github.io/en/posts/else/vf-rrt/vf-rrt/","summary":"\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\n      \u003ctitle\u003eVF-RRT\u003c/title\u003e\n      \u003cmeta charset=\"utf-8\"\u003e\n      \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n      \n      \u003clink rel=\"stylesheet\" href=\"file:///c:\\Users\\lingl\\.vscode\\extensions\\shd101wyy.markdown-preview-enhanced-0.8.15\\crossnote\\dependencies\\katex\\katex.min.css\"\u003e\n      \n      \n      \n      \n      \n      \u003cstyle\u003e\n      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,\"Liberation Mono\",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)\u003ecode[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body\u003e:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body\u003ep{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body\u003eol,html body\u003eul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li\u003ep{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote\u003e:first-child{margin-top:0}html body blockquote\u003e:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\\00a0'}html body pre\u003ecode{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers\u003ecode{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows\u003espan{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows\u003espan:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}\n/* Please visit the URL below for more information: */\n/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */\n\n      \u003c/style\u003e\n      \u003c!-- The content below will be included at the end of the \u003chead\u003e element. --\u003e\u003cscript type=\"text/javascript\"\u003e\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    // your code here\n  });\n\u003c/script\u003e\u003c/head\u003e\u003cbody for=\"html-export\"\u003e\n    \n    \n      \u003cdiv class=\"crossnote markdown-preview  \"\u003e\n      \n\u003cp\u003e\u0026nbsp;\u003c/p\u003e","title":""},{"content":" 我叫Lulu 是一只矮脚小猫😼\n请收集柠檬助力我进化成Lululemon！ 请关注 Lulu 主人的 Youtube 和 ins 好吗好的 OK(*^▽^*) Thanks for your lemon(s)! 柠檬收集度：0/8848 我生活在韩国\n和 一个人类 小声告诉你 她叫 Claire 喔\n还有 十只猫猫 住在一起\n虽然我很可爱 可是矮脚猫有基因缺陷 请谨慎养宠!\n这就是我的世界 喜欢我的话就往下看看吧🥰\n我的人型抱枕🥰 Secret !\nlulu不是不喜欢 Claire 是她的食物和玩具太有吸引力了\nClaire 在 Youtube\n和 Instagram\n上发布我们的动态\n答应我 如果喜欢我们的话要去关注她\n认准 Claire _luvcat频道不迷路😋 Claire 是我们的管家！\n肾衰的TT姐姐 跟我一样折耳的ChuChu\nClaire 都带我们治病\n喜欢她🥰\n舔狗lulu😗 只是喜欢的真情流露\n盗窃小分队😋\n喜欢DD\nMoMo会长😗\n一口吃掉\n盗窃小分队Ⅱ\n也喜欢CoCo\n唯一的Queen——TT姐姐🤩\n勇敢lulu 不怕困难😼 lulu （和弟弟TOTO,DODO）是最 勇猛 的小猫😼\n因为基因 lulu可以 站 起来 lulu在看着你🥺\nClaire 在吃什么 可以给lulu尝一口吗\nlulu爱睡觉 lulu一天到晚睡觉\n属于折耳猫的病痛 短粗的尾巴 畸形的耳朵\n是 折耳 基因的影响😢\n软骨发育不全会带来 痛苦\n所以请不要养折耳猫！\nTo Be Continued\n","permalink":"https://Sattiluvcat.github.io/en/lulu/","summary":"lulu","title":"Lulu的一切"},{"content":" 一直很想在互联网上拥有属于自己的空间😸\n记录一些关于自己和最喜欢的小猫——Lulu！的故事\n🥰🥰\n喜欢电影和文字 如有同好请通过博文评论区跟我交流🎃🎉\n","permalink":"https://Sattiluvcat.github.io/en/about/","summary":"about","title":"关于我"}]