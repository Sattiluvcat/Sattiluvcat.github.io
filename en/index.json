[{"content":" 操作系统 定义 系统资源的管理者\u0026amp;提供方便的接口与环境\u0026amp;最接近硬件的软件\n功能：处理机(CPU)管理\u0026amp;存储器管理\u0026amp;文件管理\u0026amp;设备管理 程序运行 将相关数据从磁盘放入内存 = 存储器 进程被CPU管理 = 处理机 接口\u0026amp;环境 flowchart LR 接口--\u0026gt;GUI 接口--\u0026gt;程序接口 用户接口--\u0026gt;程序接口 用户接口--\u0026gt;脱机命令接口 接口--\u0026gt;命令接口 命令接口--\u0026gt;脱机命令接口 命令接口--\u0026gt;联机命令接口 联机命令接口---交互式命令接口 交互式命令接口--\u0026gt;cmd 批处理--\u0026gt;.bat 脱机命令接口---批处理 GUI 图形化用户接口 硬件拓展 无软件支持的计算机 = 裸机 覆盖了软件 = 扩充机器（虚拟机） 四个特征 并发 共享 是最基本的特征 互为存在条件\n并发 宏观上同时发生 微观上交替（= 同时段发生）\n单核CPU同一时刻只能执行一个程序=并发 多核可以实现并行（同一时刻进行多个程序） 共享 资源共享 系统资源可供内存中多个并发进程共同使用 两种资源共享方式：\n互斥共享 一时段一进程 eg.摄像头 同时共享 一时段多进程 虚拟 物理实体变为逻辑上的对应物\nflowchart LR 虚拟技术--\u0026gt;空分复用技术 虚拟技术--\u0026gt;时分复用技术 空分复用技术--\u0026gt;eg.虚拟存储器 时分复用技术--\u0026gt;eg.虚拟处理器 没有并发性 虚拟性 = 不存在 异步性 多个程序并发 资源有限时进程执行以未知速度推进\n没有并发性 异步性 = 不存在 发展与分类 flowchart TB subgraph 手工操作 缺点1--\u0026gt;独占全机 缺点1--\u0026gt;资源利用率低 资源利用率低--\u0026gt;计算机快\u0026amp;人工慢 end 手工操作--\u0026gt;批处理阶段 subgraph 批处理阶段 subgraph 单道批处理系统 主要结构--\u0026gt;磁带\u0026amp;监督程序 缺点2--\u0026gt;内存中仅能运行一道程序 end 单道批处理系统--\u0026gt;多道批处理系统 subgraph 多道批处理系统 输入计算输出错峰运行 缺点3--\u0026gt;运行过程时不能调试 end end 批处理阶段--\u0026gt;分时操作系统 subgraph 分时操作系统 特点--\u0026gt;以时间片为单位轮流服务用户 优点--\u0026gt;及时响应解决人机交互问题 缺点4--\u0026gt;不能优先处理紧急任务 end 分时操作系统--\u0026gt;实时操作系统 subgraph 实时操作系统 在严格时限内处理事件---可以优先响应 特点1--\u0026gt;及时性\u0026amp;可靠性 分类--\u0026gt;硬实时系统 硬实时系统---严格时限 分类--\u0026gt;软实时系统 软实时系统---偶尔接受迟滞 end 实时操作系统--\u0026gt;网络操作系统 实时操作系统--\u0026gt;分布式操作系统 实时操作系统--\u0026gt;个人计算机操作系统 subgraph 不重要 网络操作系统 分布式操作系统 个人计算机操作系统 end 运行机制 指令 = 机器指令 非cmd\n两种 flowchart LR 内核程序Kernal--\u0026gt;特权指令 应用程序--\u0026gt;非特权指令 特权指令--\u0026gt;内核态 非特权指令--\u0026gt;用户态 内核程序 = 最接近硬件的部分 特权指令 = 管理者操作 内核态/用户态 = CPU状态（用PSW存储状态） PSW 程序状态字寄存器 内核态=核心态=管态 用户态=目态 切换状态：\n内核到用户：特权指令修改PSW 用户到内核：触发中断 硬件自动完成 中断与异常 中断作用 唯一让CPU从用户态变为内核态的途径 = 保障并发\n中断类型 内中断（异常）：中断信号来自CPU内部 当前执行指令\n指令自身非法/遇到特权指令 eg.trap程序引发/fault错误条件 Kernal可能修补/abort致命错误 外中断（中断）：与当前指令无关 eg.时钟中断 eg.I/O中断 基本原理 CPU检测到中断后查询中断向量表 找到中断处理程序的内存位置\n系统调用 一组系统调用组成程序接口\n应用程序通常通过库函数进行系统调用 有些库函数不调用 有些语言直接进行系统调用 eg.汇编语言 向系统内核提出请求对共享资源进行操作 即系统调用 发出trap指令提出请求（用户态） 执行trap后引发内中断进入核心态 体系结构 大/宏内核操作系统：所有内核功能（Linux UNIX等）\neg.进程 存储 设备 + 微内核部分 性能高 内核代码庞大 结构混乱 微内核操作系统：与硬件关系最紧密的功能（Windows NT） eg.时钟管理 中断处理 原语（设备驱动 CPU切换） 优缺点反之 引导 过程 1\nCPU从主存（ = RAM + ROM（BIOS））执行ROM引导程序 将磁盘中主引导记录（MBR）读入内存 执行磁盘引导程序 扫描分区表 从活动分区（主分区）读入分区引导记录（PBR） 执行程序 主分区即安装了操作系统的分区 从根目录找到启动管理器并执行 完成开机🥳 虚拟机 Virtual Machine (VMware \u0026amp; Virtual Box)\n虚拟机管理程序（VMM monitor）\n第一类VMM 运行在硬件上（CPU 磁盘 内存进行划分） 用户空间分为虚拟用户态\u0026amp;虚拟内核态（但实际均为用户态） 若执行特权指令 由内核中的VMM进行虚拟执行 第二类VMM 运行在宿主操作系统（Host OS）上（如Vmware） VMM大部在用户态 VM驱动部分在内核态 对比：第一类性能更好 可容纳更多虚拟机 运行在最高特权级(Ring 0) 但可迁移性不强 第二类反之 进程管理 进程基础知识 基本 定义 程序：静态 = 指令集合 进程：动态 = 程序的执行过程\n进程组成 PCB（Process Control Block）进程控制块 For操作系统\n进程存在唯一标志 保存：PIDUID \u0026amp; 进程控制与管理信息 \u0026amp; 资源分配清单\u0026amp; 处理机信息 PID（进程ID 唯一不重复） 程序段：程序代码 For进程\n程序运行：程序-\u0026gt;硬盘（exe）-\u0026gt;内存PCB-\u0026gt;CPU取出指令 数据段：运行过程中产生的数据 For进程 进程实体（进程映像）=PCB+程序段+数据段 静态 进程 进程实体的运行过程 动态 特征 动态性：最基本的特征 并发性：内存中有多个进程实体 独立性：获得资源的基本单位 异步性 结构性：每个进程都有一个PCB\n状态与转换 创建态 就绪态 运行态 阻塞态 终止态\n就绪态——等待处理机调度 运行态——占用整个CPU运行 阻塞态——运行态进程请求等待某事件发生 下CPU（进程主动） 事件发生后改为就绪态（被动） 进程的组织 链式：队列指针 索引：索引表指针\n进程控制 实现进程状态转换\n原语实现——具原子性 = 不可中断\n特权指令 关中断指令\u0026amp;开中断指令实现原子性 关中断开启——不再检查中断信号 创建/撤销进程时使用的原语：PCB更新——资源分配——合适的队列\n申请空白PCB——找到对应PCB 为新进程分配资源——若运行 剥夺CPU并分配 初始化PCB——终止所有子进程 PCB插入就绪队列——资源归还并删除PCB 阻塞/唤醒原语——成对使用（因何阻塞必因何唤醒）\n切换进程的原语：将现行运行环境存入PCB\n进程通信IPC 两进程间的数据交互 不同进程的内存地址不重叠 通信需要操作系统支持\n共享存储 设定共享存储区 映射到进程的虚拟地址空间\n互斥访问 由进程自己实现 基于存储区：灵活性高 高级通信 基于数据结构：低级通信 消息传递 消息包括消息头\u0026amp;消息体 操作均由原语完成\n直接通信：两进程明确消息的接收方与发送方 在内存中存储发送了的消息 形成消息队列 间接通信：发到内存中的信箱 另一进程从信箱读取 信箱公用 管道通信 某时段内单向传输（半双工通信） I/O进程不固定数量\n一种共享文件pipe 内存中一个大小固定的内存缓冲区 队列 先进先出 线程与多线程 同个进程中可能有多个线程 程序执行的最小单位（相当于小进程）\n提升并发度 不用切换进程（同进程内线程切换）系统开销小 每个线程有自己的线程ID与TCB线程控制块 几乎不拥有系统资源（来自所属的进程） 通信方便 同进程内不需系统干预 线程实现方式 用户级线程（早期）——由线程库实现\u0026amp;管理 程序实现 与操作系统无关 并发程度很低（阻塞） 1 内核级线程（KTL） 进程与对应的内核级线程都在内核态的操作系统 内核级线程一一管理用户级线程 线程切换管理成本更高 多线程模型 一对一：一内核一用户 多对一：一内核多用户（退化） 多对多：多内核多用户（内核更少） 线程状态与转换 就绪——运行——阻塞 线程组织与控制 TCB(≈PCB)=线程标识符（TID）+程序计数器PC+其他寄存器+堆栈指针+线程运行状态+优先级 调度时保存PC+其他寄存器+堆栈指针 调度 处理机调度 确定处理任务的先后顺序\n三个层次 高级调度（作业调度）——从外存调入内存开始任务 低级调度（进程调度）——最基本 快速 内存到CPU 中级调度（内存调度）——从外存调到内存 从挂起队列调回内存（内存不足） 进程调度时机 不能调度的eg.处理中断 原语 处于内核程序临界区（操作系统内） 可调度eg包括主动与被动 方式： 非抢占方式——反之 抢占方式——更紧急的任务优先执行 当前任务中止 适用分时、实时操作系统 包括：选择进程+进程切换 调度器（调度程序）scheduler与闲逛进程idle 触发调度器eg.创建新进程+进程退出+进程阻塞+I/O中断（maybe唤醒阻塞进程） 抢占式调度：时钟中断触发 非抢占式：only阻塞/退出才触发 闲逛进程idle——优先级最低 占一个完整的指令周期（提醒作用） 调度算法评价指标 CPU利用率=利用时间/总时间 系统吞吐量=单位时间内完成作业的数量 周转时间=作业提交至系统-\u0026gt;作业完成的时间 平均周转时间=各作业周转时间和/作业数 带权周转时间=周转时间/实际运行时间（\u0026gt;=1） 平均带权周转时间=带权和/作业数 等待时间=等待处理机状态时间和 for进程：等待被服务的时间 for作业：建立进程后的等待时间+作业在外存后备队列的等待时间 响应时间=提交请求-\u0026gt;首次响应的时间 调度算法 先来先服务FCFS first come first serve 非抢占式 公平 but 长作业有利 短作业不利 不会饥饿（长期得不到服务） 短作业优先SJF shortest job first——当前已到达 运行时间最短 =短进程优先 非抢占（抢占版为最短剩余时间优先算法SRNT 新达到进程/进程完成时 剩余时间最短者抢占当前进程 SRNT平均等待时间、平均周转时间最少 若所有进程几乎同时到达 SJF平均等待时间、平均周转时间最少 时间短 but 不公平 长作业不利 会饥饿 maybe饿死 高响应比优先HRRN highest response ratio next——每次调度时先计算响应比 响应比同先来先服务 响应比=(等待时间+要求服务时间)/要求服务时间 非抢占式 考虑了要求服务时间 不会饥饿\n（适用于交互式系统的调度算法👇） 时间片轮转RR round-robin——根据到达顺序轮流执行一个时间片 only用于进程调度 可抢占式——时钟中断 公平 but 切换频繁\u0026amp;不区分紧急程度 时间片过大——增大进程响应时间 过小——进程切换过于频繁 不会饥饿 优先级——设置优先级：系统\u0026gt;用户 前台\u0026gt;后台 更偏好I/O型（I/O可以和CPU并行工作） 也可用于I/O 非抢占 有抢占式版本 考虑优先级 but 可能导致饥饿 多级反馈队列——设置多级就绪队列 优先级从高到低 时间片从小到大 规则： 新进程先进第1级队列 FCFS分配时间片 时间片用完还未结束 则进入下级队尾（最下级的就进入本级队尾） k级队列为空时 再为k+1级分配时间片 被抢占的进程进入此队队尾 用于进程调度 抢占式（有非抢占式版本） 相对公平 响应快 短进程完成较快 避免用户作假 灵活调整偏好程度 maybe饥饿 多级队列——按进程类型设置不同优先级 队列间可采取固定优先级/时间片划分 各队列可采用不同调度策略 进程同步 互斥等 进程同步与互斥 进程同步——进程的次序（对抗异步性——未知速度） 进程互斥——临界资源（一时段一程序访问）互斥 进入区（检查可否进入 设置正在访问标志）——临界区——退出区（解除标志）——剩余区 临界区空闲则让进 忙则等待 有限等待——能在有限时间内进入临界区 让权等待 进程互斥的软件实现 单标志法——一个flag=允许进入临界区的进程号 空闲让进不符 双标志先检查法——进程数个flag 表达本进程是否进入临界区 忙则等待不符（检查与上锁不是同时发生） 双标志后检查法——先上锁后检查 空闲让进 有限等待不符 Peterson——自己flag为true \u0026amp; 上其它锁 \u0026amp; 若其它flag为true且上锁则自己while空循环等待 进程互斥硬件实现 中断屏蔽——开/关中断指令实现 简单高效 but 不适用多处理机（only单处理机）\u0026amp;特权指令 TS指令 TestAndSetLock——执行过程不允许中断 1 让权等待不符——无法进入的程序会占用CPU并循环TSL指令 SWAP指令（即XCHG）——类TSL指令 1 互斥锁 主要缺点：忙等 需要连续循环忙等的互斥锁 = 自旋锁 适用多处理机系统 信号量机制 用户进程用一对原语对信号量操作\n信号量：变量（整数/记录型变量） 整型信号量——仅初始化、P、V操作 存在忙等 记录型信号量——灵活使用阻塞态 就绪态等 value表示资源的剩余数量 遵循让权等待 1 1 一对原语：wait(S) signal(S) 简称为P、V操作 必成对出现 信号量机制应用 实现进程互斥——value定为互斥信号量mutex（进入临界区的名额） 初值为1 进程同步——保证操作顺序——设置同步信号量S 初值0（反互斥之道而行之） 先V（进程一结束后）后P（进程二开始前）——V释放资源 P获取资源 前驱关系 PV例题 生产者消费者问题 bg：生产者生产一个产品放入缓冲区 消费者每次取出一个产品 缓冲区有大小限制且为临界资源 PV关系：缓冲区空否——同步信号量（初值为n） 满否——同步信号量（初值为0） 访问——互斥信号量 P操作：互斥信号always在同步信号后（不空/满才访问） V：whatever 多生产多消费者 bg：生产者A生产a 消费者C只要c BD同理 缓冲区仅能放有限数量 PV：互斥——访问 同步——几个a/b（For消费者） 同步——还可以放多少（For生产者） 共4个 若缓冲区大小为1 maybe可以不加互斥信号量 吸烟者 bg：3个抽烟者和1个供应者 卷烟需要3种材料 一抽烟者有1种 供应者每次供应2种 1对应抽烟者拿走 PV：互斥——访问 同步——1 2 3是否卷好 可以省略互斥 读者-写者 bg：共享一个文件 可以多个读 一个写则其它均不可 写时让已有的读与写全部退出 PV：互斥——记录读进程个数（互斥访问计数器） 互斥——写锁 读写锁等 哲学家进餐 bg：圆桌 每人两边各有一只筷子 哲学家要么思考要么进食（需要两只筷子） PV：对筷子设置互斥 无限制会死锁——限制最多四人进餐/… 管程 信号量机制——编写程序困难易出错 =\u0026gt; 引入管程替代PV\n组成≈类（过程≈Java中的方法） 特征：管城内的数据只能被其内部的过程访问 + 只有通过管程的过程才能访问内部的共享数据 + 每次仅有一个进程在管程内执行过程 Java中的类似机制：synchronized 被其 修饰的函数在同一时段内只能被一个线程调用 死锁 概述 概念 死锁：各进程互相等待对方的资源 = 都阻塞 管理者的问题 饥饿：长期得不到资源 某进程无法推进 管理者的问题 死循环：进程执行时跳不出循环 条件 互斥——资源使用互斥 不剥夺——其他进程不能强行夺走资源 请求和保持——已经保持了至少一个资源 但还有请求 循环等待——资源的循环等待链 循环等待时不一定会发生死锁 发生死锁的情况 资源竞争 进程推进顺序非法（请求与释放的顺序不当） 信号量使用不当 = 不可剥夺的资源分配不合理\n处理策略 预防（破坏形成条件） + 避免（防止进入不安全状态） + 检测与解除\n预防死锁（静态策略） 互斥条件破坏——改为共享资源 eg.SPOOLing技术 适用范围窄 不剥夺破坏——请求无法满足时释放所有资源/操作系统将资源强行剥夺 复杂+降低吞吐量+maybe饥饿+只适用易保存回复资源 请求保持破坏——静态分配方法（运行前申请所有资源 不满足则不运行 运行后不请求） 资源利用率低 maybe饥饿 循环等待破坏——顺序资源分配法（资源编号 每个进程按编号递增请求资源 同号一次申请完） 难新增资源+资源浪费+编程麻烦 避免死锁（动态策略） 安全序列：按此序列分配资源则每个进程都能完成 安全 = 一定不死锁 不安全 = 不一定死锁 银行家算法：进程申请时 预判分配会否导致不安全 会则阻塞该进程 安全性算法：根据资源分配循环找安全序列 n个进程 m种资源 = n*m矩阵 =\u0026gt;最大需求矩阵Max n*m的分配矩阵Allocation 最多还需要多少资源Need 长m的一维数组Available表示还有多少可用资源 长m的一维数组Request表示本次申请的各种资源\n不断重复上述步骤 检测与解除 检测：保存资源的请求与分配信息（数据结构）+检测是否死锁（算法） 两种边：请求与分配 最终能消除所有边 = “可完全简化” = 一定没有死锁 死锁定理：若不能消除 = 发生死锁 还连着的边 = 处于死锁[^2]: 暂时挂到外存 解除： 资源剥夺法：挂起[^2]某些死锁进程 并将其资源分给其它死锁进程 注意防止饥饿 撤销进程法：强制撤销部分/全部死锁进程 并剥夺资源 代价大 进程回退法：一个/多个死锁进程回退到避免死锁的地步 需设置还原点 进程选择考虑：进程优先级 已执行时间 还要多久完成 已使用多少资源 交互式or批处理式 来自王道408-操作系统\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"操作系统\"\u003e操作系统\u003c/h2\u003e\n\u003ch3 id=\"定义\"\u003e定义\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e系统资源的管理者\u0026amp;提供方便的接口与环境\u0026amp;最接近硬件的软件\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e功能：处理机(CPU)管理\u0026amp;存储器管理\u0026amp;文件管理\u0026amp;设备管理\n\u003cul\u003e\n\u003cli\u003e程序运行 将相关数据从磁盘放入\u003cstrong\u003e内存\u003c/strong\u003e = 存储器\u003c/li\u003e\n\u003cli\u003e进程被CPU管理 = 处理机\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e接口\u0026amp;环境\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart LR\n 接口--\u0026gt;GUI\n 接口--\u0026gt;程序接口\n 用户接口--\u0026gt;程序接口\n 用户接口--\u0026gt;脱机命令接口\n 接口--\u0026gt;命令接口\n 命令接口--\u0026gt;脱机命令接口\n 命令接口--\u0026gt;联机命令接口\n 联机命令接口---交互式命令接口\n 交互式命令接口--\u0026gt;cmd\n 批处理--\u0026gt;.bat\n 脱机命令接口---批处理\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eGUI 图形化用户接口\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e硬件拓展\n\u003cul\u003e\n\u003cli\u003e无软件支持的计算机 = 裸机\u003c/li\u003e\n\u003cli\u003e覆盖了软件 = 扩充机器（虚拟机）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"四个特征\"\u003e四个特征\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发 共享 是最基本的特征 互为存在条件\u003c/p\u003e","title":"操作系统"},{"content":" 基础 三要素 数据结构 = 逻辑结构 + 数据运算 + 物理结构 逻辑结构=集合+线性+树形+图状 运算=增删改查 物理结构=存储结构=顺序+链式+索引+散列 存储 时间复杂度排序：O(1) \u0026lt; O(log~2~n) \u0026lt; O(n) \u0026lt; O(nlog~2~n) \u0026lt; O(n^2^) \u0026lt; O(n^3^) \u0026lt; O(2^n^) \u0026lt; O(n!) \u0026lt; O(n^n^) 最坏\u0026amp;平均时间复杂度度量 最深层循环的循环次数与n的关系 乘法规则：相乘后度量 空间复杂度 内存中的变量存储大小 递归\u0026amp;动态规划 递归：选定递归基 + 认定该方法可以解决该问题\n空间复杂度较高 动态规划：部分或完全消除算法中的递归成分（用有限空间记录子问题的解 以避免重复访问子问题） 条件：\n最优子结构（可能适用贪心） 无后效性：已求解的子问题不受后续决策影响 子问题重叠 线性表 相同数据类型 有限序列（有次序） ai中i为位序\n基础 基本操作 InitList(\u0026amp;L) DestroyList(\u0026amp;L) 增删改查: ListInsert(\u0026amp;L,i,e) ListDelete(\u0026amp;L,i,\u0026amp;e) LocateElem(L,e)按值查找 GetElem(L,i)按位查找 Length(L) \u0026amp; PrintList(L) \u0026amp; Empty(L) 传入\u0026amp;：需要用到修改后的值 栈 后进先出 (last in first out,LIFO)\nCpp的STL中stack容器提供成员函数： st.top()返回栈顶 st.push()进栈到顶 st.pop()弹出栈 st.empty() st.size()栈容量 Python模拟栈 st=[1,2,3] st.append(2) # 入栈 st.append(3) # [1,2,3,2,3] st.pop() st.clear() 队列 先进先出 (first in first out,FIFO)\n数组模拟队列 标记队列首尾(ql,qr) 删除元素：ql++ 清空队列：ql=1,qr=0(ql\u0026gt;qr即可) 双栈模拟队列 F为队尾栈 S为队首栈 pop时若S为空 则将F元素弹出后插入S 再进行pop 双端队列 队首队尾均可插入删除元素 Python中容器为collections.deque 循环队列 下标为0的位置视为最后位的后继 队列向数组尾部移动 最终入队即使有空位也会溢出（假溢出） 单调栈与单调队列 保证元素单调性的栈/队列（递增or递减）\n维护一个单增/单减的数组 实现最小/最大值查找\\\n(以单减找最大为例) 新元素与队尾元素比较 若更小则进队 若更大 则从队尾开始将所有比之更小的元素踹出队 lc.239滑动窗口找最大\\ int head=0,tail=-1; int i=0; int[] win=new int[nums.length]; for(;i\u0026lt;k;i++){ while(head\u0026lt;=tail\u0026amp;\u0026amp;nums[win[tail]]\u0026lt;=nums[i]){ tail--; } win[++tail]=i; System.out.println(\u0026#34;now tail is \u0026#34;+tail); } System.out.println(nums[win[head]]); for(;i\u0026lt;nums.length;i++){ while(head\u0026lt;=tail\u0026amp;\u0026amp;nums[win[tail]]\u0026lt;=nums[i]){ tail--; } win[++tail]=i; while(win[head]\u0026lt;=i-k) head++; System.out.println(nums[win[head]]); } 类似还有lc.84/739/862/901/907等可用类似方法\n链表 增删 O(1) 查读 O(n)\n单向链表 指针 + 数据 双向链表 指针（左、右） + 数据 struct Node{ int value; Node *left; Node *right; }; 插入数据 单向链表 new node的next指向p的next node p的next node指向new node node-\u0026gt;value=i; node-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=node; 单向循环链表 首尾相连 插入时判断是否为空 若为空 new node的next指向自己 p指向new node if(p==NULL){ p=node; node-\u0026gt;next=node; } 双向循环链表 判断是否为空 \u0026amp; 修改左右两个指针 非空 node-\u0026gt;left = p; node-\u0026gt;right = p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left = node; p-\u0026gt;right = node; 删除数据 单向循环链表 删除p = p-\u0026gt;next的值给p \u0026amp; 跳过p-\u0026gt;next p-\u0026gt;value = p-\u0026gt;next-\u0026gt;value; Node *t = p-\u0026gt;next; p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; 双向循环链表 p-\u0026gt;left-\u0026gt;right = p-\u0026gt;right; p-\u0026gt;right-\u0026gt;left = p-\u0026gt;left; Node *t = p; p = p-\u0026gt;right; delete t; 哈希表 key-\u0026gt;哈希函数-\u0026gt;索引≈内存位置-\u0026gt;value\n哈希冲突 = 不同key计算的索引相同 拉链法（开散列法）多键值索引到同一位置 在该位置建立链表 闭散列法 所有记录记录在散列表中 发生冲突则根据某方式继续探查 堆 树 每个节点的键值都大于等于/小于root节点的键值\n大于等于的为最小化堆 反之为最大化堆（左子大于右子）\n二叉堆 结构：完全二叉树（以下以最大化堆为例） 插入：最下层最右叶子插入 向上调整 复杂度O(logn) 删除（root）：root与最后的节点交换 向下调整 向下调整 = 子节点中最大的与新root交换 复杂度O(logn) 实现：在序列中 Hi的子节点为H2i与H2i+1 void up(int x) { while (x \u0026gt; 1 \u0026amp;\u0026amp; h[x] \u0026gt; h[x / 2]) { std::swap(h[x], h[x / 2]); x /= 2; } } void down(int x) { while (x * 2 \u0026lt;= n) { t = x * 2; if (t + 1 \u0026lt;= n \u0026amp;\u0026amp; h[t + 1] \u0026gt; h[t]) t++; if (h[t] \u0026lt;= h[x]) break; std::swap(h[x], h[t]); x = t; } } 建堆：向上/向下调整 向上调整 从叶子开始向堆上部移动 复杂度O(nlogn) 向下调整 从root开始向堆下部移动 复杂度O(n) 二叉树 二叉搜索树 左子\u0026lt;root\u0026lt;右子\n删除元素：若有两个非空子节点 用左子树的最大值/右子树的最小值代替它后删除\n平衡树 每个节点的左子树和右子树高度差最多为1\n调整过程 右旋 root左子成为新root root成为新root的右子 新root原右子成为root左子 TreeNode* newRoot = root-\u0026gt;left; root-\u0026gt;left = newRoot-\u0026gt;right; newRoot-\u0026gt;right = root; 四种平衡破坏情况 LL RR省略 LR 左子的右子树过长 RL 右子的左子树过长（类上） AVL树 平衡的二叉搜索树\n性质：\nAVL的左右子树也是AVL树 且左右子树高度相差不大于1（平衡因子 = 右子树高 - 左子树高） 树高logn 调整：若平衡因子=-2 == 左子左旋后root右旋 B树 每个节点可以拥有两个以上的子节点 增删改查在对数时间完成\n最下层的节点称为叶子节点 性质：（m阶）\n每个节点最多有m个子节点 非叶子节点（除root）最少有m/2个子节点 若root不是叶子节点 则至少有2个子节点 排序 冒泡排序 对序列逐个扫描 n次扫描后排序完毕\n最坏\u0026amp;平均情况下时间复杂度O(n^2^) 最好情况下时间复杂度O(n)\nbool flag = true; while (flag) { flag = false; for (int i = 1; i \u0026lt; n; ++i) { if (a[i] \u0026gt; a[i + 1]) { flag = true; int t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; } } } 插入排序 最坏\u0026amp;平均情况下时间复杂度O(n^2^) 最好情况下时间复杂度O(n)\\\n从头开始遍历每个需插入的数据 与其前已排序的数据的末尾向头逐一比较 for (int i = 1; i \u0026lt; len; ++i) { int key = arr[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } 折半插入 二分算法优化 时间复杂度不变 快速排序 将数列划分为2parts 递归到两子序列中进行快排 = 挖坑填数\n最优/平均时间复杂度O(nlogn) 最坏O(n^2^)\n若选第一个数为基准数 数组首尾两指针 i\u0026amp;j 从j开始向前找小于或等于基准数的 放到原基准数的位置 从i开始向后找大于基准数的 放到原j的位置 以此循环 最后i=j放入基准数 在前后两parts再继续进行以上步骤 void quick_sort(int s[],int l,int r){ if(l\u0026lt;r) { int i=l,j=r,base=s[l]; while(i\u0026lt;j){ while(i\u0026lt;j\u0026amp;\u0026amp;s[j]\u0026gt;base) j--; if(i\u0026lt;j){ s[i++]=s[j]; } while(i\u0026lt;j\u0026amp;\u0026amp;s[i]\u0026lt;=base) i++; if(i\u0026lt;j){ s[j--]=s[i]; } } } s[i]=base; quick_sort(s,l,i-1); quick_sort(s,i+1,r); } 优化：\n三路快速排序 三路取中（首、中、尾三元素进行比较后选择base） 与base相等的元素聚集在其周边 短序列用插排 归并排序 时间复杂度O(nlogn) 空间复杂度O(n)\n特殊应用 康托展开 数学方法 详见wiki\n应用：LC.60排列排序permutation-sequence\n","permalink":"https://Sattiluvcat.github.io/en/posts/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"基础\"\u003e基础\u003c/h2\u003e\n\u003ch3 id=\"三要素\"\u003e三要素\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e数据结构 = 逻辑结构 + 数据运算 + 物理结构\n\u003cul\u003e\n\u003cli\u003e逻辑结构=集合+线性+树形+图状\u003c/li\u003e\n\u003cli\u003e运算=增删改查\u003c/li\u003e\n\u003cli\u003e物理结构=存储结构=顺序+链式+索引+散列 存储\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e时间复杂度排序：\u003ccode\u003eO(1) \u0026lt; O(log~2~n) \u0026lt; O(n) \u0026lt; O(nlog~2~n) \u0026lt; O(n^2^) \u0026lt; O(n^3^) \u0026lt; O(2^n^) \u0026lt; O(n!) \u0026lt; O(n^n^)\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e最坏\u0026amp;平均时间复杂度度量\u003c/li\u003e\n\u003cli\u003e最深层循环的循环次数与n的关系\u003c/li\u003e\n\u003cli\u003e乘法规则：相乘后度量\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e空间复杂度 内存中的变量存储大小\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"递归动态规划\"\u003e递归\u0026amp;动态规划\u003c/h3\u003e\n\u003cp\u003e递归：选定递归基 + 认定该方法可以解决该问题\u003c/p\u003e","title":"数据结构"},{"content":" 存储引擎 MySql体系结构 MySql服务器 flowchart LR 连接层--\u0026gt;服务层 服务层\u0026lt;--\u0026gt;SQL接口 服务层\u0026lt;--\u0026gt;解析器 服务层\u0026lt;--\u0026gt;查询优化器 服务层\u0026lt;--\u0026gt;缓存 SQL接口--\u0026gt;d((可插拔式存储引擎)) 解析器--\u0026gt;d 查询优化器--\u0026gt;d 缓存--\u0026gt;d d--\u0026gt;存储层 存储引擎包括InnoDB等，Index信息也存储在其中 存储层存储系统文件、文件和日志等 存储引擎 存储引擎简介 存数据、建索引、更新数据等的实现方式，基于表不基于库（被称为表类型）\n建表时指定存储引擎\nCREATE TABLE 表名( … \\)ENGINE=INNODB … SHOW ENGINES; 显示支持的存储引擎\n存储引擎特点 InnoDB DML操作遵循ACID模型 支持事务 行级锁 提高并发访问性能 支持外键 以.idb表空间文件存储该表的表结构(frm sdi)、数据与索引 用cmd打开 idb2sdi ***.idb 查看表结构 数据段即为B+树的叶子节点 索引段为非叶子节点 flowchart LR Tablespace--\u0026gt;Segment--\u0026gt;Extent--\u0026gt;Page--\u0026gt;row 表空间--\u0026gt;段--\u0026gt;区--\u0026gt;页--\u0026gt;行 MyISAM 不支持事务 外键 支持表锁 不支持行锁 访问速度快 ✕✕.sdi 存储表结构信息 ✕✕.MYD 存储数据 ✕✕.MYI 存储索引 Memory 存储在内存中 只做临时文件\n内存存放 hash索引 ✕✕.sdi 存储表结构 比较 特点 InnoDB MyISAM Memory 事务安全 支持 - - 锁机制 行锁 表锁 表锁 支持外键 支持 - - B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持 支持 - 空间使用 高 低 N/A 内存使用 高 低 中 批量插入速度 低 高 高 选择 InnoDB 事务完整性\u0026amp;并发条件 各种操作都很多 MyISAM 以读\u0026amp;插入操作为主 少更新\u0026amp;删除 对事务的完整性与并发性要求不高(被ControlDB取代) Memory 临时表的缓存 对表的大小有限制 安全性没有保障(被Redis取代) 索引 索引概述 帮MySql高效获取数据的数据结构（有序） 在存储引擎中实现 优点： 提高查询效率 降低IO成本 降低排序成本 降低CPU消耗 缺点： 占用磁盘空间 降低更新表的速度 索引结构 主要索引： 索引结构 描述 B+Tree索引 大部分引擎都支持 最常见 Hash索引 不支持范围查询 精确匹配索引列的查询才有效 R-Tree(空间索引) MyISAM的特殊索引 用于地理空间数据类型 Full-text(全文索引) 建立倒排索引 快速匹配文档 支持引擎： 索引 InnoDB MyISAM Memory B+Tree 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree 不支持 支持 不支持 Full-text 支持 支持 不支持 一般索引直接指B+Tree索引 B+Tree\u0026amp;其它Tree 二叉树：左子小于亲点 右子大于亲点 顺序插入时会形成链表 大数据量下 层级较深 效率低 红黑树：新数据会先与根节点判断大小 大数据量下 层级较深 B Tree(多路平衡查找树)： 最大度数为n，最多n个子节点，每个节点最多存储n-1个key(元素)，n个指针 中间节点向上分裂 B+Tree 所有元素都会出现在叶子节点(树只起到索引作用) 所有叶子节点形成单向链表 B+Tree in MySql 增加了指向相邻叶子节点的链表指针 形成带顺序指针的B+Tree 一页(一个磁盘块)只存放指针和key不存放数据，则一页上可以存放的指针与key相比BTree更多，故层级更少 Hash 键值换算成新的hash值 映射到对应槽位 存储在hash表中 hash冲突(多个键值映射到同个槽位)时用链表解决 特点： 只能用于对等比较 不支持范围查询 无法利用索引进行排序 查询效率高 通常只需一次检索 通常效率高于B+Tree 索引分类 分类： 索引 含义 特点 关键字 主键索引 针对主键创建的 默认自动创建 onlyone PRIMARY 唯一索引 避免同表中某列数据的值重复 可有多个 UNIQUE 常规索引 快速定位特定数据 可多个 全文索引 查找文本关键词 非比较索引中的值 可多 FULLTEXT 根据索引的存储形式分类： 聚集索引 将数据存储与索引放到一起 索引的叶子节点保存行数据(有且仅有1个) 聚集索引选取规则：主键\u0026gt;第一个唯一索引\u0026gt;innoDB生成rowid作为隐藏聚集索引 二级索引 将数据与索引分开存储 叶子节点关联对应主键(可有多个) 如建立name的索引 叶子节点即存储id 回表查询 eg.查询Satti的所有信息 先二级索引查主键 后聚集索引查row信息 索引语法 CREATE [UNIQUE/FULLTEXT] INDEX 索引名 ON 表名 (字段名,…); 创建索引 字段名后可指定升降序建立索引 索引名一般为 idx_表名_字段名1_字段名2 可以关联多个字段 SHOW INDEX FROM 表名[\\G]; 查看索引 \\G可以把以行显示的索引转换为列显示 DROP INDEX 索引名 ON 表名; 删除索引 SQL性能 性能分析 SHOW GLOBAL STATUS LIKE'Com____' 查询命令(Delete等)执行频次 SHOW GLOBAL STATUS提供服务器状态 7个下划线 慢查询日志 记录超过指定时间的SQL语句 SHOW VARIABLES LIKE'SLOW_QUERY_LOG‘; 检查慢查询日志是否开启 开启慢查询日志： 在MySql配置文件/etc/my.cnf中配置\n#开启慢查询 slow_query_log=1\n#设置慢日志时长\nlong_query_time=2 查看记录信息 /var/lib/mysql/localhost-slow.log profile详情 SELECT @@have_profiling; 是否支持profile操作 开启profile SET PROFILING=1 SHOW PROFILES; 查看所有指令耗时 SHOW PROFILES [CPU] FOR QUERY query号; 查看某个query的耗时(与cpu消耗) explain执行计划 在select语句前加 desc 或 explain id select查询的序列号（操作顺序） id相同 顺序从上到下 id不同 值越大越先执行 type 性能指标从好到差： NULL\u0026gt;system\u0026gt;const(以上较好)\u0026gt;eq_ref\u0026gt;ref\u0026gt;range\u0026gt;index\u0026gt;all 主键/唯一索引==const possible_key 可能用到的索引 key 实际用到的索引 key_len 索引字段最大可能长度 rows 预估执行查询的行数 filtered 返回结果行数占读取行数的比例(越大越好) 索引使用原则 最左前缀法则 联合索引时遵守\n查询从索引的最左列开始 且不跳过索引中的列（即从联合索引的第一个字段开始） 若跳过索引中某字段 则后面的字段失效 范围查询 联合索引时遵守\n即\u0026gt; \u0026lt;等范围限定 若出现 其右侧列索引失效 若使用\u0026gt;=或\u0026lt;=则不存在此问题 失效问题 索引列运算 若对索引中的字段进行运算 索引失效 包括substring等 字符串不加引号 字符串类型字段若不加引号 索引失效 模糊查询 尾部模糊查询 不失效 头部模糊查询 索引失效 or连接 or中一条件中的字段有索引 + 另一列无索引 = 索引失效 数据分布影响 如索引效率不如全表扫描时 启用全表扫描 SQL提示 EXPLAIN select语句 USE INDEX(索引名) 建议使用某索引 EXPLAIN select语句 IGNORE INDEX(索引名) 不用某索引 EXPLAIN select语句 USE INDEX(索引名) 必用某索引 覆盖索引 需要返回的列在索引中可全部找到 \u0026ldquo;using where;using index\u0026rdquo; 在列 \u0026ldquo;using index condition\u0026rdquo; 需回表查询 前缀索引 字段类型为varchar text等 需索引很长字符串——前缀索引 CREATE INDEX 索引名 ON 表名(COLUMN(N)); 创建前缀索引 N为前缀长度 选择性计算：COUNT(DEISTINCT SUBSTRING(字段名,m,n))/COUNT(\\)* 根据选择性取舍选择N的大小 单列与联合索引的选择 业务场景中存在多个查询条件 建议采用联合索引 单列易产生回表查询 索引设计原则 数据量较大（\u0026gt;几十万） 查询频繁 常作为where、order by、group by条件的字段 区分度高的列（相对唯一 如身份证号等） 若为字符串类型 字段长度较长——前缀索引 尽量使用联合索引 控制索引数量 若索引列不能有NULL 建表时即规定NOT NULL 便于优化器选用索引 SQL优化 插入优化 基本优化 批量插入(500-1000条) 手动提交事务 主键顺序插入 大批量插入数据\n# 客户端连接服务端时加\u0026ndash;LOCAL-INFILE\nMYSQL --LOCAL-INFILE -U ROOT -P;\n# 设置全局参数为1 允许从本地加载文件导入数据\nSET GLOBAL LOCAL_INFILE=1;\n# 执行load加载数据\nLOAD DATA LOCAL INFILE '数据地址' INTO TABLE '表名' FIELDS TERMINATED BY ',' LINES TERMINATED BY '\\n'; linux命令行：head 文件名查看文件前十行 主键优化 数据组织方式 InnoDB中 表数据按主键顺序组织存放 此种表即为索引组织表(IOT) 页分裂 （页中存放的是行数据）\n每个页包含2~n个数据（若1个 则相当于一个链表） 根据主键排列 若乱序插入 可能发生页分裂 前一页后50%部分与新数据挪至新页 新页插入前一页与后一页间 页合并 当页中删除的row达到MERGE-THRESHOLD（默认50%） InnoDB会寻找靠近的页进行合并 MERGE-THRESHOLD 合并页的阈值 可自定义 主键设计原则 尽量降低主键长度（占用的字节大小） 尽量顺序插入（自增主键） 尽量不用UUID（通用唯一识别码）或其它自然主键（如身份证号）为主键 因为无序 避免修改主键 order by优化 Extra显示 Using index 通过索引排序 Using filesort 不可通过索引直接返回排序结果 索引升序创建时 若倒序排序则需filesort 优化 根据排序字段建立合适索引 多字段排序时也遵循最左前缀 尽量使用覆盖索引\u0026amp;注意升降序设定 不可避免出现filesort大数据量排序时 适当增加排序缓冲区sort_buffer_size大小 group by优化 extra显示 Using temporary 使用临时表（性能低） Using index 使用索引 满足最左前缀 limit优化（分页） limit不能用在in/all/any/some子语句中==多表查询 将limit的结果视为新表 覆盖索引 + 子查询 原表与分页查到的主键id表联合查询name等索引覆盖的字段 count优化 MyISAM将表的总行存在磁盘中 效率高 InnoDB需将数据从引擎中读出后累计计数 优化思路 自己计数（设定计数器cnt） 用法 count(*) 不取值 直接累加 count(主键) 取主键id值 按行累加 主键不可能为NULL count(字段) 字段为NULL时 count不加1 字段有not null约束时 不需判断null count(1) 可以取-1等 服务层对返回的每一行放1（或-1）进去 后逐行累加 效率：字段 \u0026lt; 主键id \u0026lt; 1 \u0026lt; * update优化 update优先行锁（有索引字段时 锁住该行）若无索引 执行表锁 InnoDB的行锁针对索引 视图 虚拟存在的表 只保存查询的逻辑不保存结果\n视图语法 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED |LOCAL] CHECK OPTION]\n创建视图（OR REPLACE或替换视图） SHOW CREATE VIEW 视图名\n查看创建视图语句\nSELECT * FROM 视图名\n查看视图 类似表 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED/LOCAL] CHECK OPTION]\n修改视图（REPLACE为主要）\nALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED/LOCAL] CHECK OPTION]\n修改视图 DROP VIEW [IF EXISTS] 视图名称 删除视图 检查选项 WITH [CASCADED/LOCAL] CHECK OPTION 使之后对视图进行的增删改操作符合视图最初的定义 CASCADED/LOCAL 检查依赖视图的规则 保持一致性 二者限定的范围不同 CASCADED （若v1未指定视图检查 但为v2的依赖视图 也会检查v1）检查所有亲辈的限制 无论其是否指定 LOCAL 若v1未指定 则不检查v1 视图更新 可更新的视图：视图中的行与基础表的行一一对应 包含 聚合/DISTINCT/GROUP BY/HAVING/UNION/… 的视图不可更新 视图作用 简单 简化理解\u0026amp;操作（复杂且多次使用到的检索可以形成视图） 安全 可以只查看某表的部分内容（授权只能精确到表） 数据独立 屏蔽基表变化对查看信息带来的影响 存储过程 SQL语言的代码封装与重用\n特点 封装 复用 可以接收参数 返回数据 减少应用途径与数据库间的网络交互 提升效率 语法 创建存储过程 CREATE PROCEDURE 存储过程名([参数列表])* BEGIN ——SQL语句 END; 命令行中解决遇 ; 即停问题：用delimiter 某符号指定语句结束位置 在DataGrip中存储为routines 中文“例程”\nCALL 存储过程名([参数列表]) 调用存储过程 SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='表名';\n查询指定数据库的存储过程与状态\nSELECT CREATE PROCEDURE 存储过程名\n查询某存储过程的定义 DROP PROCEDURE 存储过程名 删除存储过程 变量 系统变量 由服务器提供 分为全局变量GLOBAL与会话变量SESSION（仅在当前会话 即当前控制台 生效） 默认SESSION 系统重启后全局参数失效 可在/etc/my.cnf中配置 SHOW [SESSION/GLOBAL] VARIABLES;\n查看所有系统变量\nSHOW [SESSION/GLOBAL] VARIABLES LIKE '…';\n模糊匹配\nSELECT @@[SESSION/GLOBAL] 系统变量名;\n查看指定变量的值 系统变量用@@ SET [SESSION/GLOBAL] 系统变量名=值\nSELECT @@[SESSION/GLOBAL] 系统变量名=值\n设置系统变量 SET SESSION AUTOCOMMIT =0 切换到手动提交 用户自定义变量 不用提前声明 通过“@变量名”使用(未定义时调用返回null) 作用域为当前\nSET @变量名=值;\nSET @变量名:=值;\nSELECT @变量名=值;\n赋值 可多个同时赋值\nSELECT 字段名 INTO @变量名 FROM 表名; 将字段名结果赋值给变量 SELECT @变量名 使用变量 局部变量 作用域在begin…end块之间 先声明后调用\nDECLARE 变量名 变量类型 [DEFAULT …]; 声明（有否默认值） SET 变量名 := 值\nSELECT 字段名 INTO 变量名 FROM 表名;\n为变量赋值 条件判断\u0026amp;循环 if IF 条件1 THEN …; ELSEIF 条件2 THEN …; ELSE …; END IF; 用SELECT语句显示返回值\n参数 类型 类型 含义 备注 IN 输入 调用时传入值 默认 OUT 输出 可为返回值 INOUT 输入\u0026amp;输出 CREATE PROCEDURE 存储过程名([IN/OUT/INOUT 参数名 参数类型]) case CASE [变量] WHEN … THEN …; … ELSE … END CASE; while WHILE 条件 DO SQL逻辑 END WHILE 条件为true时进行 repeat REPEAT SQL逻辑 UNTIL 条件 END REPEAT 先执行一次逻辑 若条件满足则停止循环 loop [begin_label:] LOOP … END LOOP [end_label]; 配合语句： LEAVE LABEL; 退出循环 ITERATE LABEL; 只可在循环中使用 跳过当前循环剩下的语句进入下一次循环 游标\u0026amp;条件处理程序 游标 暂时存储查询结果集的数据类型（集合）\nDECLARE 游标名 CURSOR FOR 查询语句; 声明游标 OPEN 游标名 打开游标 FETCH 游标名 INTO 变量; 获取游标记录（可以是多个变量） CLOSE 游标名 关闭游标 使用游标记录结果集 开启游标通过循环获取游标内的数据 条件处理程序 定义在流程控制结构执行过程中遇到问题的处理步骤\nDECLARE 处理动作 HANDLER FOR 状况值 … statement; 处理动作： CONTINUE 继续执行当前程序 EXIT 终止 状况值： SQLSTATE 状态码 可用下列替代 SQLWARNING（01开头的状态码） NOT FOUND（02开头的状态码） SQLEXCEPTION（除以上两种的其它） 存储函数 有返回值 参数必为IN类型（应用少）\nCREATE FUNCTION 存储函数名([参数列表]) RETURNS 数据类型 [characteristic] BEGIN ——SQL语句 END; characteristic：（二级日志开启 默认需加）\nDETERMINISTIC 相同输入产生相同结果 NO SQL 不包含SQL语句 READ SQL DATA 包含读取数据的语句 不包含写入数据的语句 触发器 触发器定义 与表有关的数据库对象。在insert/update/delete之前或之后，触发并执行其定义的语句（多为记录数据变更日志） OLD与NEW引用触发器中发生变化的记录内容 如insert用NEW；update用OLD（引用需修改的内容）与NEW（引用修改后的内容） 只支持行级触发器 不支持语句级触发 触发器语法 CREATE TRIGGER 触发器名 BEFORE/AFTER INSERT/… ON 表名 FOR EACH ROW——行级触发器 BEGIN 语句（将修改的内容放入新建的日志表中） END; 创建触发器 “语句”为将新操作记录插入日志表（自建） 可以记录插入的详细信息 用 concat() 拼接字符串 SHOW TRIGGERS; 查看触发器 DROP TRIGGER [数据库名.]触发器名; 删除触发器 锁 概述 协调多进程或线程并发访问某资源的机制 事务中进行 分类 全局锁 数据库中所有表 表级锁 行级锁 全局锁 通常用做全数据库的逻辑备份\n语法 FLUSH TABLES WITH READ LOCK 加全局锁 MYSQLDUMP -UROOT -P1234 数据库名\u0026gt;保存地点 备份数据库 在命令行中运行 非mysql语句 用户名root 密码1234 UNLOCK TABLES 释放锁 特点（不重要） 若主库备份 备份期间不能更新主库 若从库备份 备份期间从库不能执行主库同步来的二进制日志 导致主从延迟 MYSQLDUMP --SINGLE-TRANSACTION -UROOT -P1234 数据库名\u0026gt;保存地点 不需加全局锁的备份 表级锁 锁定粒度大 发生所冲突的概率最高 并发度最低\n分类： 表锁 元数据锁 意向锁 表锁 分类： 表共享读锁 表独占写锁 LOCK TABLES 表名… READ/WRITE 加锁 读锁 所有客户端都可读 不可写 写锁 当前客户端可读 / 写 其他客户端不可读 / 写 UNLOCK TABLES 释放锁 元数据锁(meta data lock,MDL) 系统自动控制\n维护表元数据的数据一致性==表上有活动事务时不可对元数据进行写入 避免DML与DDL冲突 MySql5.5后 DML增删改查加读锁 DDL对表结构变更加写锁 SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM PERFORMANCE_SCHEMA.METADATA_LOCKS; 查看元数据锁 意向锁 使表锁不用检查每行数据是否加行锁 避免DML执行时行锁与表锁冲突 分类： 意向共享锁(IS) 意向排他锁(IX) SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_DATA FROM PERFORMANCE_SCHEMA.DATA_LOCKS;\n查看锁 日志中RECORD锁类型代表行锁 意向锁间不互斥\nIS 意向共享锁 由SELECT语句 LOCK IN SHARE MODE添加 与表锁共享读锁(read)兼容 与表锁排它写锁(write)互斥 IX 意向排他锁 由增删改语句 FOR UPDATE添加 与表锁共享读锁(read)互斥 与表锁排它写锁(write)互斥 行级锁 锁定粒度最小 锁冲突改率最低 并发度最高 在InnoDB存储引擎中应用\n分类： 行锁 锁定单个行记录——在RC RR隔离级别下都支持（包括共享锁与排他锁） 间隙锁 确保索引记录间隙不变 防止insert产生幻读——在RR下支持 临键锁 行锁+间隙锁（该行之前的间隙）——RR下支持 行锁类型 SQL 行锁类型 说明 增删改 排他锁 自动加 SELECT语句 无锁 SELECT加共享锁 共享锁S 手动 SELECT…FOR UPDATE 排他锁X 手动 行锁 InnoDB使用next-key（临键锁）进行搜索与索引扫描 以防止幻读\n针对唯一索引检索时 对存在的记录进行等值匹配（通过 “=” 检索）时会自动将next-key锁优化为行锁 InnoDB中不通过索引检索数据会升级为表锁 间隙锁\u0026amp;临键锁 理解 唯一索引的等值查询 给不存在的记录加锁时 优化为间隙锁 普通索引的等值查询 向右遍历到最后一个值不满足查询需求时 临键锁退化为间隙锁 唯一索引的范围查询 访问到不满足条件的第一个值为止（加锁） 间隙锁可以共存（只为防止其它事务插入间隙so） InnoDB引擎 理解 整体架构 内存架构 直接操作\n缓冲池 Buffer Pool Change Buffer 对非唯一的二级索引进行修改 操作存储在此（先到缓冲池 后到磁盘） Adaptive Hash Index 优化对缓冲池数据的查询(自动生成) 用SHOW VARIABLES LIKE '%HASH_INDEX%';查看其是否启用（模糊匹配） Log Buffer 日志缓冲区 保存要写入磁盘的log INNODB_LOG_BUFFER_SIZE查看大小 INNODB_FLUSH_LOG_AT_TRX_COMMIT刷新到磁盘的时机（可设置0 1 2 具体含义略） 磁盘结构 System Tablespaces系统表空间 主要存放Change Buffer %DATA_FILE_PATH%模糊匹配 General Tablespaces通用表空间 需在创建表时指定 CREATE TABLESPACE创建该表空间 Undo Tablespaces撤销表空间 自动创建两个 Temporary Tablespaces临时表空间 DoubleWrite Buffer Files双写缓冲区（缓冲池刷新到磁盘前先写入此） Redo Log重做日志 实现事务持久性（包括重做日志缓冲 储存在内存中） 后台线程 将缓冲区数据刷新到磁盘中\nMaster Thread核心后台线程 调度其他线程 IO Thread 负责IO请求的回调 Purge Thread 回收事务已提交的undo log Page Cleaner Thread减轻主线程刷新脏页的压力 事务原理 redo log 刷新脏页到磁盘发生错误时进行数据恢复（物理日志） undo log 回滚日志（逻辑日志） 记录数据被修改前的信息 MVCC需要 MVCC⭐ 多版本并发控制 Multi-Version Concurrency Control\n基本概念 当前读 读取记录数据的最新版本并对记录加锁 共享锁/排他锁/增删改 快照读 读取记录数据的可见（历史）版本 不加锁 RC隔断下 每次select生成一个快照读 RR 开启事务后第一个select才是快照读 S 快照读退化为当前读 MVCC 维护一个数据的多个版本 使读写操作没有冲突 快照读为其提供非阻塞读功能 依赖于： 数据库记录中的三个隐式字段 undo log readView 实现原理 三个隐式字段 （InnoDB隐式生成）\n隐藏字段 含义 DB_TRX-ID 最近修改事务ID DB_ROLL_PTR 回滚指针 指向这条记录的上个版本 配合undo log DB_ROW_ID 隐藏主键 若无指定主键则生成此字段 undo log日志（增删改时产生便于数据回滚的日志）\ninsert 只在回滚时需要log 事务提交后可被删除 删改 在回滚与快照读时需要（不会被立即删除） 生成undo log版本链 头部是最新的历史记录 尾部是最旧的历史记录 ReadView 记录并维护系统当前活跃（未提交）的事务id（MVCC提取数据的依据）\n四个核心字段 字段 含义 m_ids 当前活跃事务ID集合 min_trx_id 最小活跃事务ID max_trx_id 预分配事务ID（当前最大事务ID+1 自增） creator_trx_id ReadView创建者的事务ID 版本链数据访问规则（当前事务ID为trx_id 即DB_TRX_ID）理解 只可符合下列四个条件 若都不符合 则换下一条undo log trx_id==creator_trx_id ✔ 说明数据由当前事务更改 trx_id\u0026lt;min_trx_id ✔ 说明数据已提交 trx_id\u0026gt;max_trx_id ✖ 事务在RV生成后才开始 min_trx_id\u0026lt;=trx_id\u0026lt;=max_trx_id 且trx_id不在m_ids中 ✔ 说明数据已提交 RC隔离级别 事务中每次执行快照读时生成ReadView RR隔离级别 事务中第一次执行快照读时生成 后复用 MySql管理 系统数据库 自带四个数据库 数据库 作用 mysql 服务器运行需要的信息（时区 主从 用户 权限等） information_schema 访问元数据的表、视图等 performance_schema 底层监控服务器运行状态 收集其性能参数 sys 方便DBA 便于性能调优与诊断的视图 常用工具 MySQL 数据库名 -e \u0026quot;执行语句\u0026quot; -e执行sql语句并退出 适用于shell脚本 mysqladmin -uroot -p****** … 查看帮助文档并进行相关操作 mysqlbinlog log1 查看二进制日志文件 mysqlshow … 查找数据库/表/列/索引等 mysqldump [options] db_name备份数据库 mysqllimport或source 客户端数据（mysqldump加-T参数导出的文本文件）导入 🎉🎉 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/mysql/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"存储引擎\"\u003e存储引擎\u003c/h2\u003e\n\u003ch3 id=\"mysql体系结构\"\u003eMySql体系结构\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eMySql服务器\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003eflowchart LR\n连接层--\u0026gt;服务层\n服务层\u0026lt;--\u0026gt;SQL接口\n服务层\u0026lt;--\u0026gt;解析器\n服务层\u0026lt;--\u0026gt;查询优化器\n服务层\u0026lt;--\u0026gt;缓存\nSQL接口--\u0026gt;d((可插拔式存储引擎))\n解析器--\u0026gt;d\n查询优化器--\u0026gt;d\n缓存--\u0026gt;d\nd--\u0026gt;存储层\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e存储引擎包括InnoDB等，\u003c!-- raw HTML omitted --\u003eIndex\u003c!-- raw HTML omitted --\u003e信息也存储在其中\u003c/li\u003e\n\u003cli\u003e存储层存储系统文件、文件和日志等\n\u003cimg loading=\"lazy\" src=\"2.jpg\" alt=\"系统结构图\"  title=\"系统图\"  /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"存储引擎-1\"\u003e存储引擎\u003c/h3\u003e\n\u003ch4 id=\"存储引擎简介\"\u003e存储引擎简介\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e存数据、建索引、更新数据等的实现方式，基于表不基于库（被称为表类型）\u003c/p\u003e","title":"MySql"},{"content":" 简介 NoSql 非关系型数据库 No Structured Relational\n特点： 表型 JSON型 图型==非结构化 Redis为键值类型 JSON表==数据无关联 查询方式==非SQL（语法不统一） 事务ACID无法全部满足==BASE 存储==内存 使用场景： 数据结构不固定 对一致性 安全性要求不高 性能要求 Redis 特征： 键值型 key-value 支持多种数据结构 单线程 命令具原子性 低延迟 内存 IO多路复用 编码风格 支持数据持久化 支持主从集群 分片集群（主表\u0026amp;从表） 多语言客户端 redis-cli -h 192.168.211.129 -p 6379 -a 密码\n启动（不安全） systemctl stop redis关闭 连接虚拟机与图形化界面失败=检查防火墙\n基本语法 不区分大小写\n数据结构 value类型 基本类型：String Hash List（可重复） Set SortedSet（排序集合 不可重复） 特殊类型：GEO（地理坐标） BitMap HyperLog 帮助文档 or 命令行 help\n通用命令 用help 命令名查看命令的具体使用方法\nKEYS查看符合模板a**的所有key 慢 DEL删key 会返回删除的个数 EXISTS判断是否存在 EXPIRE设置key的有效期 TTL查看key的剩余有效期 类型\u0026amp;命令 String 分类 类型 数据结构 string 字符串 int 整型 float 浮点数 常见命令 命令 作用 SET 添加/修改键值对 GET 由key得value MSET/MGET 批量操作 INCR 整型key自增1 INCRBY 整型自增指定步长 INCRBYFLOAT 浮点类型自增指定步长 SETNX 添加String键值对 前提key不存在 SETEX 添加String键值对 指定有效期 SETNX==SET key value NX\n返回0表示键值已存在不会添加\n返回1表示不存在已添加 层级结构 key的层级结构：用:隔开\n若值为Java对象 可用JSON形式存储： eg.'{\u0026quot;id\u0026quot;:1, \u0026quot;name\u0026quot;:\u0026quot;Satti\u0026quot;, \u0026quot;age\u0026quot;:20}'单引 Hash类型 无序字典 类HashMap CRUD 增删改查\n相对String类型的JSON字符串 可以将每个字段独立存储 KEY保存键名 VALUE中field保存字段名 value保存值 常见命令 命令 作用 HSET 添加/修改hash类型一对field\u0026amp;value HGET hash类型由key得filed HMSET/HMGET 对一个key批量操作 HGETALL 由key得所有field value HKEYS key中所有field HVALS key中所有value HINCRBY 字段值按指定步长自增 HSETNX 添加field 前提field不存在 List类型 类似LinkedList 但双向链表\n特征：有序 可重复 插入删除快 查询速度一般 常见命令 命令 作用 LPUSH/RPUSH 列表左/右侧插入 LPOP/RPOP 移除左/右侧第一个 LRANGE 返回一段角标范围内的所有元素 BLPOP/BRPOP 没有元素时等待指定的时间 移除时无元素 返回nil 角标 = 序号 从0开始 Set类型 类HashSet==value为null的HashMap\n特征：无序 不可重复 查找快 支持交并差集 常见命令： 命令 作用 SADD 向set添加元素 可多个 SREM 移除指定元素 SCARD 返回元素个数 SISMEMBER 是否有某元素 SMEMBERS 返回所有value 命令 作用 SINTER 求两键交集 SDIFF key1相对于key2不同的值（差集） SUNION 并集 SDIFF中key有先后顺序 SortedSet 类TreeSet（可排序的set） 数据结构不同\n每个元素具有score属性 通过属性排序=SkipList+Hash 特性： 可排序 元素不重复 查询速度快 常见命令：ZADD ZREM ZCARD ZINCRBY ZDIFF ZINTER ZUNION 命令 作用 ZSORE 获取指定元素score ZRANK 获取指定元素排名 ZCOUNT score在某范围内的元素个数 ZRANGE 按score排序得指定排名范围内元素 ZRANGEBYSCORE 指定score范围内 默认升序排序 Z后加REV即为降序 Jedis 开启测试后通过new对象建立连接\njedis=new Jedis(ip,port);\n设置密码\njedis.auth(password)\n选择库\njedis.select(index) SpringDataRedis RedisTemplate工具类 redisTemplate.opsForValue()类似语句调用上述数据类型\n返回值类型如ValueOperations 步骤： 引入spring-boot-starter-data-redis依赖 application.yaml配置Redis test中Autowired定义RedisTemplate\u0026amp;进行Test试验 StringRedisTemplate手动序列化\u0026amp;反序列化 节省内存 以json形式存储、读取数据 以对象形式初始化、接收 故需要手动进行序列化转换 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/redis%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003ch3 id=\"nosql\"\u003eNoSql\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e非关系型数据库 No Structured Relational\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e特点：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e表型 JSON型 图型==非结构化\n\u003cul\u003e\n\u003cli\u003eRedis为键值类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eJSON表==数据无关联\u003c/li\u003e\n\u003cli\u003e查询方式==非SQL（语法不统一）\u003c/li\u003e\n\u003cli\u003e事务ACID无法全部满足==BASE\u003c/li\u003e\n\u003cli\u003e存储==内存\u003c/li\u003e\n\u003cli\u003e使用场景：\n\u003cul\u003e\n\u003cli\u003e数据结构不固定\u003c/li\u003e\n\u003cli\u003e对一致性 安全性要求不高\u003c/li\u003e\n\u003cli\u003e性能要求\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"redis\"\u003eRedis\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e特征：\n\u003cul\u003e\n\u003cli\u003e键值型 key-\u003c!-- raw HTML omitted --\u003evalue\u003c!-- raw HTML omitted --\u003e 支持多种数据结构\u003c/li\u003e\n\u003cli\u003e单线程 命令具原子性\u003c/li\u003e\n\u003cli\u003e低延迟\n\u003cul\u003e\n\u003cli\u003e内存\u003c/li\u003e\n\u003cli\u003eIO多路复用\u003c/li\u003e\n\u003cli\u003e编码风格\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e支持数据持久化\u003c/li\u003e\n\u003cli\u003e支持主从集群 分片集群（主表\u0026amp;从表）\u003c/li\u003e\n\u003cli\u003e多语言客户端\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eredis-cli -h 192.168.211.129 -p 6379 -a 密码\u003c/code\u003e\u003cbr\u003e\n启动（不安全）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esystemctl stop redis\u003c/code\u003e关闭\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e连接虚拟机与图形化界面失败=检查防火墙\u003c/p\u003e","title":"Redis_base"},{"content":" 基本概念 RDBMS 关系型数据库 based on关系模型，多张二维表相互连接 sql操作分类 分类 全称 说明 DDL Data Definition Language 定义数据库、表、字段等 DML Manipulation 对表中数据进行增删改 DQL Query 查询表的记录 DCL Control 创建库用户 控制权限 启动与停止 net start mysql80 \u0026amp; net stop mysql80\nMySql 开机自启，在cmd中可手动停止 mysql -u root -p\n-u 提示用户为 root，-p 提示将输入密码 SQL 基本 以分号结尾，行数不论，空格与缩进不论 不区分大小写，关键字最好大写 \u0026ndash; 或 # 注释内容 多行注释 /* 内容 */ DDL DDL数据库操作 SHOW DATABASES;\n查询所有数据库 SELECT DATABASE();\n查询当前（是在哪个）数据库 创建数据库（括号内容可以不加 采用默认规则） CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; charset utf8mb4 设定为容纳4个字节的utf8 在DataGrip中可以使用SCHEMA替代DATABASE DROP DATABASE [IF EXISTS] 数据库名;\n删除数据库 USE 数据库名;\n使用数据库 DDL表操作 查询 SHOW TABLES;\n查询当前数据库所有表 DESC 表名 查询表结构 SHOW CREATE TABLE 表名 查询指定表的建表语句 创建 CREATE TABLE 表名( 字段1 字段1类型[COMMENT '中文'], 字段2 字段2类型[COMMENT '……'], …… 字段3 字段3类型[COMMENT '……'] )[COMMENT '……']; 字段1 是表头名称，如name 字段1类型： 数值类型 tinyint,smallint,mediumint,int-4字节,bigint,float,double tinyint unsigned表示无符号 即正数范围 可指定double(m,n)，m表示最长位数，n表示小数点后最长位数 字符串 char(指定长度),varchar(指定长度), char为定长字符串，varchar变长(会计算所需空间是否需要变化) 日期 date,time,datetime,year,timestamp(截至2038年) 修改 ALTER TABLE 表名 ADD 字段名 字段类型 [COMMENT 注释] [约束]; 增加字段 ALTER TABLE 表名 MODIFY 字段名 新字段类型 [COMMENT 注释]; 修改字段类型 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段类型 [COMMENT 注释]; 修改字段名\u0026amp;字段类型 ALTER TABLE 表名 RENAME TO 新表名 修改表名 删除 ALTER TABLE 表名 DROP 字段名; 删除字段 DROP TABLE [IF EXISTS] 表名; 删除表 TRUNCATE TABLE 表名; 删除并重新创建该表 DataGrip中字段翻译为列\nDML 添加数据 INSERT INTO 表名(字段名1,字段名2,…) VALUES (值1,值2,…); 指定字段添加数据 INSERT INTO 表名 VALUES (值1,值2,…); 全部字段添加数据 此处括号为分隔符号，不可省略，[]表示可以忽略 Sql 以某数据库为原点，若需修改某表，在指令中需指明该表名 字符串与时间类型用 '…' 表示 修改删除 UPDATE 表名 SET 字段名1=值1,字段名2=值2,…[WHERE 条件]; 条件可以写为 id=1 等 DELETE FROM 表名 [WHERE 条件] 不能删除某个对象中特定字段的值（只能删除行） 没有被物理删除 被标记为删除使其空间可被♻ DQL 用*表示显示所有信息，放在其它特殊检索内容前\n基本查询 SELECT 字段1，字段2，… FROM 表名; SELECT * FROM 表名 查询多个字段 SELECT 字段1 [AS 别名1],字段2 [AS 别名2],… FROM 表名; 设置别名(显示在搜索结果的表头) SELECT DISTINCT 字段列表 FROM 表名; 显示查询到的非重复结果 条件查询 SELECT 字段列表 FROM 表名 WHERE 条件列表 条件类型： 比较运算 \u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,\u0026lt;\u0026gt;或!=表示不等于 所有数据类型适用（包括日期） BETWEEN … AND … 含最大最小值的范围 前小后大 数据有先后顺序 IN(…) 列表中的值 LIKE 占位符 模糊匹配 _表示单字符 %表示任意个字符 IS NULL 或 IS NOT NULL 逻辑运算 AND 或 \u0026amp;\u0026amp; OR 或 || NOT 或 ! 聚合函数\u0026amp;分组查询 SELECT 聚合函数(字段列表) FROM 表名;\n常见聚合函数： 函数 功能 count 统计数量 max 最大 min 最小 avg 平均 sum 求和 SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\n“字段列表”可以写聚合函数\u0026amp;搜索的字段名（可显示表头） 执行顺序：WHERE\u0026gt;聚合函数\u0026gt;HAVING 聚合函数(某) 别名 起别名方法 聚合函数多半可以直接写为 SUM(\\*) 排序查询 SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;\n排序方式： ASC 升序(默认) DESC 降序 字段1，字段2有先后顺序 分页查询 SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;\n起始索引从0开始，为查询页的起始id\n第一页可以写为 LIMIT 查询记录数 顺序 编写顺序： SELECT$\\rightarrow$FROM$\\rightarrow$WHERE$\\rightarrow$GROUP BY$\\rightarrow$HAVING$\\rightarrow$ORDER BY$\\rightarrow$LIMIT DCL 管理用户 USE mysql SELECT * FROM user 查询用户 CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 创建用户 主机名为 % 表示可在任意主机访问 ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 修改密码 DROP USER '用户名'@'主机名'; 删除用户 权限控制 常用权限类型： 权限 说明 ALL(PRIVILEGES) 所有权限 SELECT 查询 INSERT 插入 UPDATE 修改 DELETE 删除 ALTER 修改表 DROP 删除库/表/视图 CREATE 创建库/表 SHOW GRANTS FOR '用户名'@'主机名'; 查询权限 GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 授予权限 权限列表写 ALL 作通配 REVOKE 权限列表 ON 数据库名.表名FROM '用户名'@'主机名'; 撤销权限 数据库、表用\\*作通配 函数 使用 SELECT 函数 进行函数试验\n字符串函数 常用函数：\n函数 功能 CONCAT(S1,S2,…,Sn) 拼接字符串 LOWER(str) 全小写 UPPER(str) 全大写 LPAD(str,n,pad) pad从左填充str到n长度 RPAD(str,n,pad) pad从右填充str到n长度 TRIM(str) 去头尾空格 SUBSTRING(str,start,len) 返回str从start处起的len个字符 字符串从1开始 非0 主要结合前文语法进行应用 数值函数 常见函数：\n函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x,y) x/y的模 RAND() 0~1内随机数 ROUND(x,y) x四舍五入 y位小数 日期函数 常见函数：\n函数 功能 CURDATE() 当前日期 CURTIME() 当前时间 NOW() 当前日期与时间 YEAR(date) 获得date的年份 MONTH(date) date的月份 DAY(date) date的日 DATE_ADD(date,INTERVAL expr type) date加上时间间隔expr后的时间 DATEDIFF(date1,date2) date1到date2的天数 DATE_ADD 中 expr 可为数字 type可为 DAY 流程控制函数 常用函数：\n函数 功能 IF(v,t,f) v为true返回t 否之为f IFNULL(value1,value2) v1不为空则返回v1 否之为v2 CASE WHEN [val1] THEN [res1] … ELSE [default] END v1真则返回res1 否之为d CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END expr等于v1返回res1 否之为d val1处不能并列多个val 用此类函数做筛选不用加where，格式为：==SELECT \\*,(CASE …) AS '别名' FROM 表名== 约束 约束概述 目的：保证数据库中数据的正确有效与完整\n约束分类 约束 描述 关键字 非空约束 该字段数据不为null NOT NULL 唯一约束 该字段所有数据不重复 UNIQUE 主键约束 一行数据的唯一标识 非空且唯一 PRIMARY KEY 默认约束 未指定则采用默认值 DEFAULT 某 检查约束 保证字段满足某条件 CHECK id int PRIMARY KEY AUTO_INCREMENT主键且自动增长(多个约束用空格隔开) 作用于表中字段 创建/修改表时添加 一般把序号设为主键 外键约束 让两表数据建立连接 保证数据完整一致\n具有外键的表=子表 被关联的表=亲表\n格式：\n创建时添加 [CONSTRAINT] [外键名] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) 修改时添加 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) 外键名是给外键自定义的新名字 注意数据类型需完全相同 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 删除外键\n[ON UPDATE 模式 ON DELETE 模式] 在添加语句后指定删除/更新模式\n模式 说明 NO ACTION 有外键则不允许更新 RESTRICT 同上 CASCADE 亲子表同时更新 SET NULL 亲表删除 子表设null SET DEFAULT 子表设为默认(Innodb不支持) 多表查询 多表关系 一对多：建立外键连接 eg.员工\u0026amp;部门 多对多：建立第三表 至少包含两外键 分别关联两方主键 eg.学生\u0026amp;课程 一对一：任意一方加外键 并设置为UNIQUE 多用于单表拆分 基础字段在一表 详情字段在另一表 UNIQUE 在定义id的时候添加 eg.用户\u0026amp;用户详情 多表查询概述 并列多表时需要消除无效的笛卡尔积情况(指A*B) 分类： flowchart LR; test((连接查询)) test--\u0026gt;内连接 test--\u0026gt;外连接 test--\u0026gt;自连接 多表查询--\u0026gt;test 多表查询--\u0026gt;子查询 外连接--\u0026gt;左外连接 外连接--\u0026gt;右外连接 内连接 返回A B表的交集\nSELECT 字段列表 FROM 表1,表2 WHERE 条件 …; 隐式内连接 条件类似employee.dept_id=dept\\.id SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件 …; 显式内连接 外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 …; 左外连接 查询左表与交集部分的数据 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 …; 左外连接 右表\u0026amp;交集 自连接 SELECT 字段列表 FROM 表1 别名1 JOIN 表1 别名2 ON 条件 …; 可内连接也可外连接 联合查询 SELECT 字段列表 FROM 表1 … UNION [ALL] SELECT 字段列表 FROM 表2 …; 有ALL结果直接合并 无ALL去重 字段列表与类型相同 子查询（嵌套查询） 外部可以是INSERT/UPDATE/DELETE/SELECT 根据子查询结果的不同分类： 名称 意义 标量子查询 结果为单个值 列子查询 结果为一列 行子查询 为一行 表子查询 多行多列 可在WHERE/FROM/SELECT之后进行 列子查询 返回一列结果 常用操作符： 操作符 用途 ==IN== 集合范围之内 多选一 NOT IN 不在集合范围内 ANY 任意一个满足 SOME 同ANY ALL 所有值都满足 行子查询 常用操作符 =、\u0026lt;\u0026gt;、IN、NOT IN 可以用 (1200,1)=(salary,manager) 表示一一对应 表子查询 常用操作符 IN 事务 操作 简介：一组操作的集合 整体提交 自动开始 SELECT @@AUTOCOMMIT; 开始事务(自动提交) SELECT @@AUTOCOMMIT=0; …… COMMIT; 手动提交事务 ROLLBACK; 事务回滚 手动开始 START TRANSACTION; 开启事务 COMMIT; 提交事务 ROLLBACK; 回滚事务 特性 原子性 不可分割的最小操作单元 一致性 事务完成时所有数据保持一致状态 隔离性 数据库的隔离机制，事务进行不受外部并发操作影响 持久性 提交或回滚后，数据的改变是永久的 ==ACID模型== 并发事务问题 脏读 一个事务读到另一个事务未提交的数据 不可重复读 先后读取同一记录但数据不同 幻读 按条件查询数据，无对应数据行，但插入数据时发现该行数据已存在 事务隔离级别 分类： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED ✔ ✔ ✔ READ COMMITTED ✖ ✔ ✔ REPEATABLE READ(默认) ✖ ✖ ✔ SERIALIZABLE ✖ ✖ ✖ ORACLE默认READ COMMITTED 性能递减 安全性递增 SELECT @@TRANSACTION_ISOLATION; 查看事务隔离级别 SET [SESSION或GLOBAL] TRANSACTION ISOLATION LEVEL {隔离级别}; 设定隔离级别 SESSION为当前连接 GLOBAL为全局，不包含当前连接 ","permalink":"https://Sattiluvcat.github.io/en/posts/java/mysql_base/","summary":"\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch2 id=\"基本概念\"\u003e基本概念\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cem\u003eRDBMS\u003c/em\u003e 关系型数据库\nbased on关系模型，多张二维表\u003cstrong\u003e相互连接\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003esql操作分类\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e分类\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e全称\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e说明\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDDL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eData Definition Language\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e定义数据库、表、字段等\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDML\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eManipulation\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e对表中数据进行增删改\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDQL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eQuery\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e查询表的记录\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDCL\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eControl\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e创建库用户 控制权限\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"启动与停止\"\u003e启动与停止\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003enet start mysql80\u003c/code\u003e \u0026amp; \u003ccode\u003enet stop mysql80\u003c/code\u003e\u003cbr\u003e\nMySql 开机自启，在cmd中可手动停止\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emysql -u root -p\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e-u\u003c/code\u003e 提示用户为 root，\u003ccode\u003e-p\u003c/code\u003e 提示将输入密码\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"sql\"\u003eSQL\u003c/h2\u003e\n\u003ch3 id=\"基本\"\u003e基本\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e以分号结尾，行数不论，空格与缩进不论\u003c/li\u003e\n\u003cli\u003e不区分大小写，关键字最好大写\u003c/li\u003e\n\u003cli\u003e\u0026ndash; 或 # 注释内容\n多行注释 /* 内容 */\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"ddl\"\u003eDDL\u003c/h3\u003e\n\u003ch4 id=\"ddl数据库操作\"\u003eDDL数据库操作\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSHOW DATABASES;\u003c/code\u003e\u003cbr\u003e\n查询所有数据库\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSELECT DATABASE();\u003c/code\u003e\u003cbr\u003e\n查询当前（是在哪个）数据库\u003c/li\u003e\n\u003cli\u003e创建数据库（括号内容可以不加 采用默认规则）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eCREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003echarset utf8mb4\u003c/code\u003e 设定为容纳4个字节的utf8\u003c/li\u003e\n\u003cli\u003e在\u003c!-- raw HTML omitted --\u003eDataGrip\u003c!-- raw HTML omitted --\u003e中可以使用\u003cem\u003eSCHEMA\u003c/em\u003e替代\u003cem\u003eDATABASE\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\u003ccode\u003eDROP DATABASE [IF EXISTS] 数据库名;\u003c/code\u003e\u003cbr\u003e\n删除数据库\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUSE 数据库名;\u003c/code\u003e\u003cbr\u003e\n使用数据库\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"ddl表操作\"\u003eDDL表操作\u003c/h4\u003e\n\u003ch5 id=\"查询\"\u003e查询\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eSHOW TABLES;\u003c/code\u003e\u003cbr\u003e\n查询当前数据库所有表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDESC 表名\u003c/code\u003e\n查询表结构\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSHOW CREATE TABLE 表名\u003c/code\u003e\n查询指定表的建表语句\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"创建\"\u003e创建\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eCREATE TABLE 表名( 字段1 字段1类型[COMMENT '中文'], 字段2 字段2类型[COMMENT '……'], …… 字段3 字段3类型[COMMENT '……'] )[COMMENT '……'];\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e字段1 是表头名称，如name\u003c/li\u003e\n\u003cli\u003e字段1类型：\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数值类型\u003c/strong\u003e\ntinyint,smallint,mediumint,int-4字节,bigint,float,double\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etinyint unsigned\u003c/code\u003e表示无符号 即\u003cstrong\u003e正数范围\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e可指定\u003ccode\u003edouble(m,n)\u003c/code\u003e，m表示最长位数，n表示小数点后最长位数\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字符串\u003c/strong\u003e\nchar(指定长度),varchar(指定长度),\n\u003cul\u003e\n\u003cli\u003echar为定长字符串，varchar变长(会计算所需空间是否需要变化)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e日期\u003c/strong\u003e\ndate,time,datetime,year,timestamp(截至2038年)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"修改\"\u003e修改\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 ADD 字段名 字段类型 [COMMENT 注释] [约束];\u003c/code\u003e\n增加字段\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 MODIFY 字段名 新字段类型 [COMMENT 注释];\u003c/code\u003e\n修改字段类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 CHANGE 旧字段名 新字段名 新字段类型 [COMMENT 注释];\u003c/code\u003e\n修改字段名\u0026amp;字段类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 RENAME TO 新表名\u003c/code\u003e\n修改表名\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5 id=\"删除\"\u003e删除\u003c/h5\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eALTER TABLE 表名 DROP 字段名;\u003c/code\u003e\n删除字段\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDROP TABLE [IF EXISTS] 表名;\u003c/code\u003e\n删除表\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTRUNCATE TABLE 表名;\u003c/code\u003e\n删除并重新创建该表\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDataGrip中字段翻译为列\u003c/p\u003e","title":"MySql基础"},{"content":" 我叫Lulu 是一只矮脚小猫😼\n我生活在韩国\n和 一个人类 小声告诉你 她叫 Claire 喔\n还有 十只猫猫 住在一起\n虽然我很可爱 可是矮脚猫有基因缺陷 请谨慎养宠!\n这就是我的世界 喜欢我的话就往下看看吧🥰\n我的人型抱枕🥰 Secret !\nlulu不是不喜欢 Claire 是她的食物和玩具太有吸引力了\nClaire 在 Youtube\n和 Instagram\n上发布我们的动态\n答应我 如果喜欢我们的话要去关注她\n认准 Claire _luvcat频道不迷路😋 Claire 是我们的管家！\n肾衰的TT姐姐 跟我一样折耳的ChuChu\nClaire 都带我们治病\n喜欢她🥰\n舔狗lulu😗 只是喜欢的真情流露\n盗窃小分队😋\n喜欢DD\nMoMo会长😗\n一口吃掉\n盗窃小分队Ⅱ\n也喜欢CoCo\n唯一的Queen——TT姐姐🤩\n勇敢lulu 不怕困难😼 lulu （和弟弟TOTO,DODO）是最 勇猛 的小猫😼\n因为基因 lulu可以 站 起来\nlulu在看着你🥺\nClaire 在吃什么 可以给lulu尝一口吗\nlulu爱睡觉 lulu一天到晚睡觉\n属于折耳猫的病痛 短粗的尾巴 畸形的耳朵\n是 折耳 基因的影响😢\n软骨发育不全会带来 痛苦\n所以请不要养折耳猫！\nTo Be Continued\n","permalink":"https://Sattiluvcat.github.io/en/lulu/","summary":"lulu","title":"Lulu的一切"},{"content":" 一直很想在互联网上拥有属于自己的空间😸\n记录一些关于自己和最喜欢的小猫——Lulu！的故事\n🥰🥰\n喜欢电影和文字 如有同好请通过博文评论区跟我交流🎃🎉\n","permalink":"https://Sattiluvcat.github.io/en/about/","summary":"about","title":"关于我"}]