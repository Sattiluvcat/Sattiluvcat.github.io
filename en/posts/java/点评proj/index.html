<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")}</script></head><title>点评Proj | Satti's Blog</title>
<meta name=keywords content="Java,Redis"><meta name=description content="又是来自黑马的烂大街项目——小小点评，也是Redis基础的一个延伸"><meta name=author content="Satti"><link rel=canonical href=https://Sattiluvcat.github.io/en/posts/java/%E7%82%B9%E8%AF%84proj/><link crossorigin=anonymous href=/assets/css/stylesheet.c5df81d78a700d63222bf88c998222af7e6085cc41585cba2eff58e49fd49e25.css integrity="sha256-xd+B14pwDWMiK/iMmYIir35ghcxBWFy6Lv9Y5J/UniU=" rel="preload stylesheet" as=style><link rel=icon type=image/png href=/favicon-48x48.png sizes=48x48><link rel=icon type=image/svg+xml href=/favicon.svg><link rel="shortcut icon" href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta name=apple-mobile-web-app-title content="MyWebSite"><link rel=manifest href=/site.webmanifest><link rel=alternate hreflang=en href=https://Sattiluvcat.github.io/en/posts/java/%E7%82%B9%E8%AF%84proj/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")}</script><meta property="og:title" content="点评Proj"><meta property="og:description" content="又是来自黑马的烂大街项目——小小点评，也是Redis基础的一个延伸"><meta property="og:type" content="article"><meta property="og:url" content="https://Sattiluvcat.github.io/en/posts/java/%E7%82%B9%E8%AF%84proj/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-16T12:16:45+08:00"><meta property="article:modified_time" content="2024-12-13T23:13:45+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="点评Proj"><meta name=twitter:description content="又是来自黑马的烂大街项目——小小点评，也是Redis基础的一个延伸"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://Sattiluvcat.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Java💻","item":"https://Sattiluvcat.github.io/en/posts/java/"},{"@type":"ListItem","position":3,"name":"点评Proj","item":"https://Sattiluvcat.github.io/en/posts/java/%E7%82%B9%E8%AF%84proj/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"点评Proj","name":"点评Proj","description":"又是来自黑马的烂大街项目——小小点评，也是Redis基础的一个延伸","keywords":["Java","Redis"],"articleBody":" 功能完善 拦截器 Utils中实现添加拦截器Interceptor功能，在config中添加MVCConfig以添加拦截器并设置排除拦截的地址 session 存储用户基本信息即可\n多台Tomcat不共享session空间（存储当前用户信息）–\u003e切换不同Tomcat时数据丢失 需要数据共享 内存存储 键值 ==\u003eRedis替代 Redis 保存用户时以随机token作为key 设置有效期 另外用户访问时持续更新时长–\u003e在拦截器中设置 取出Hash类型的所有字段–\u003eentries 缓存 数据交换缓冲区 临时存储数据 读写性能较高\n注意：添加缓存时根据Redis中类型转换变量类型 Redis使用String类型——以JSON形式存储，需转换 缓存更新策略 内存淘汰 Redis内存不足时自动淘汰部分数据 一致性差 无维护成本 超时剔除 为缓存数据添加TTL时间 下次查询时更新缓存 一致性一般 主动更新 Cache Aside \u0026 Read/Write Through \u0026 Write Back 一致性好 主动更新 Cache Aside Pattern 更新缓存无效写操作较多（若查询很少）——\u003e删除缓存 查询时再更新缓存 保证缓存与数据库操作同时成功/失败——\u003e 单体系统：缓存与数据库变一个事务 分布式系统：TCC等分布式事务方案 先删缓存再改数据库or先修改数据库（线程安全性）——\u003e先改数据库后删缓存 封装成事务 缓存穿透 客户端请求的数据在缓存和数据库中都不存在\n缓存空对象：在Redis中缓存键值对null 造成额外的内存消耗——设置TTL解决 可能造成短期不一致 布隆过滤：客户端到Redis之间设置布隆过滤器 判断存在则放行 不存在则拒绝请求 ≈ 数据库中数据通过Hash转换后在过滤器中以二进制位形式存储 优点：内存占用较少 没有多余key 缺点：实现复杂 可能误判（判为存在） 选择缓存空对象\n其它解决方案：增加id复杂度 \u0026 做好数据的基础格式校验 \u0026 用户权限校验 \u0026 热点参数限流 缓存雪崩 同一时段内大量缓存key同时失效/Redis服务宕机 导致大量请求到达数据库——\u003e巨大压力\n给不同key的TTL设置随机值 利用Redis集群提高服务的可用性 缓存业务添加降级限流策略（牺牲部分服务） 给业务添加多级缓存（浏览器 nginx JVM…都设置缓存） 缓存击穿 “热点key问题” 被高并发访问\u0026缓存重建业务（查询数据库并更新缓存）较复杂的key突然失效 无数请求访问会给数据库带来巨大冲击\n互斥锁——（查询缓存未命中后）获取互斥锁成功后才可进行缓存重建，若获取失败 休眠一会后重试 优点：无额外内存消耗 \u0026 保证一致性 \u0026 实现简单 缺点：线程需要等待 性能受影响 \u0026 可能死锁 逻辑过期——存储热点key的value时在value中增加逻辑过期值expire（实际上不设置TTL） 手动回收 查询缓存 检查逻辑时间是否已过期 已过期，获取互斥锁成功，开启新线程来更新expire，本线程返回过期数据，新线程更新完毕释放锁 已过期，获取互斥锁失败，返回过期数据 优点：线程无需等待 性能较好 缺点：不保证一致性（返回旧数据） \u0026 有额外内存消耗 \u0026 实现复杂 使用逻辑过期 创建线程池 private static final ExecutorService CACHE_REBUILD_EXECUTOR= Executors.newFixedThreadPool(10); 秒杀 全局ID 针对优惠券\n订单表不用自增ID：id规律性明显 \u0026 受单表数据量限制 分布式系统下生成全局唯一ID的工具 高可用 递增性 安全性 高性能 唯一性 ID组成：符号位 + 时间戳（31位） + 序列号（32位） 设置每天一个key 避免超过上限 超卖 产生：对库存进行操作完成前 有线程访问 即会产生超卖 锁： 悲观锁：线程安全问题一定发生，操作数据前先获取锁eg.Synchronized lock 乐观锁：不一定发生，只在更新数据时判断是否有其他线程对数据进行了修改 乐观锁：两种方案 版本号法：数据库中添加version字段，修改时需校验version与之前查到的是否一致，一致时同时更新版本号 CAS法：直接把库存当版本即可 成功率过低 一人一单 加悲观锁——Synchronized 对同一个用户加锁，intern方法保证只对该值加锁 不是新创建对象（toString会新创建对象） 当锁在事务中时，锁释放后事务尚未提交 ==\u003e 其他线程仍有可能访问到未更新的内容 锁在方法上时，会对所有this对象都加锁and···，范围太广 选定把锁加在方法调用上 synchronized (userId.toString().intern()) 锁加在方法调用上时，this的对象并非代理（Impl）对象，Spring的事务会失效，解决方法选择获取代理对象 注意有几种使Spring的事务失效的可能 有几种解决方案\nsynchronized (userId.toString().intern()) { IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } * 主方法中添加注解`@EnableAspectJAutoProxy(exposeProxy = true)` * 添加AspectJweaver依赖 集群设备访问 失效 测试时设置虚拟机设置（VM options）修改为多个端口号 分布式锁 满足分布式系统/集群模式下多进程可见\u0026互斥的锁\n要求：多进程可见 + 互斥 + 高可用 + 高性能 + 安全性 + ··· 对比：MySql Redis Zookeeper 维度 MS R Zk 互斥 自身的互斥锁 setnx等互斥命令 节点唯一性 有序性实现 高可用 好 好 好 高性能 一般 好 一般 安全性 断开连接自动释放锁 锁超时时间设置 临时节点 断开连接则释放 实现：设置锁的同时保证互斥（设置锁\u0026设置过期时间 语句合二为一） 业务完成后需手动释放锁 SET lock thread1 NX EX 10 问题：误删（eg.某线程业务阻塞 锁超时释放 其他线程即可获取锁 此后原业务再释放即释放了其它线程的锁） 解决：删除锁时对比value是否是本线程——修改释放锁逻辑即可 value存储某固定UUID+线程标识 新问题：判断标识与释放锁必同时进行（否则过程中发生阻塞后也会有问题——Java自身导致的） 解决：保证原子性——Lua脚本（不用Redis的事务机制） 一个脚本中编写多条命令 -- 从1开始计数 local key=KEYS[1] -- 非key的都用ARGV保存 local threadId=ARGV[1] 隐患：（极小概率）——Redisson解决 不可重入——同个线程不可多次获取同一把锁 不可重试 超时释放——业务执行耗时较长 锁也会释放 主从一致性 Redisson 设置：引入依赖——配置config——注入后直接使用 @Configuration public class RedissonConfig { @Bean public RedissonClient redissonClient() { Config config = new Config(); config.useSingleServer().setAddress(\"redis://192.168.balabal:6379\").setPassword(\"123456\"); return org.redisson.Redisson.create(config); } } 可重入锁原理👇：同一线程可以多次访问一个锁——Redis用Hash结构保存，value为访问次数，当最后value==0时释放锁（若非0，则重置有效期后继续执行业务——不在最外侧）\nLua脚本编写 可重试：订阅等功能实现——等待、唤醒、获取锁失败👇\n超时续约：watchDog 每隔一段时间重置超时时间（leaseTime=-1时自动进入）👇\nRedisson分布式锁过程👇（读源码）下图来自：黑马程序员Redis入门到实战教程 主从一致性（主从同步有延时/同步失败时）——设置多Node 必须在所有Node都获得锁程序才获得锁（也可以继续给Node配Slave节点）\n异步优化 （Lua脚本）Redis进行判断购买条件与“扣减库存” tomcat根据其传回的信息判断是否添加到阻塞队列并返回订单id mysql异步下单 两线程进行 阻塞队列 BlockingQuene——队列为空时 阻塞进程；队满时插入 阻塞进程 Spring Security 鉴权 权限：访问 执行 控制 共享 RBAC–\u003erole-based access control RBAC0：用户–\u003e角色–\u003e许可（均为多对多） == 3+2张表（对应关系表） RBAC1：引入角色继承机制（角色间的等级关系） RBAC2：在0的基础上引入对角色的约束–\u003e一个用户不能同时具有两种特定的权限 RBAC3：约束+继承 注解 eg.PreAuthorize–\u003e提前鉴权验证 基于RBAC鉴权模型添加统一功能 –\u003e AOP（切面 = 切点 通知 连接点 ···） 拦截指定方法并增强，无需侵入业务代码 模块化 非侵入式 可重用性 松耦合 提高性能与可拓展性 （spring boot）启动类添加注解EnableAspectJAutoProxy 定义接口anno 添加Target Retention注解——target的是method 在runtime有效运行 切面类编写 添加Aspect Component注解——切面类方法的具体实现 (配置AOP时 把目标类\u0026切面类都bean（添加注解@Component交予容器管理）) 指定pointcut地址（目标方法地址） 消息队列 待施工···\n封装 泛型 其它 JMeter 运行jmeter.bat即可 拆箱装箱问题 Boolean-boolean Integer-int等\n知识点总结 JWT+Interceptor JWT组成：Header Payload Signature（前二Base64url解码后是JSON格式 签名通过前二+密钥with签名算法得到） Payload 部分默认不加密 JWT如何进行身份验证？ 用户向服务器发送用户名、密码以及验证码用于登陆系统。 如果用户校验正确，服务端返回已经签名的 Token，即 JWT 用户每次向后端发请求都在 Header 中带上 JWT （此处可省略）用户端最好将JWT保存到localstorage 而非Cookie（CSRF风险） 服务端检查 JWT 并从中获取用户相关信息 防止JWT被篡改——签名比对 加强安全性方法 Payload 要加入 exp （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长 JWT 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险 不要将隐私信息存放在 Payload 中 密钥不要泄露。JWT 安全的核心在于签名，签名安全的核心在密钥 JWT优势： 无状态：服务器不需要存储每次会话的客户端信息（传来JWT后用加密算法比对签名即可） 避免CSRF（跨站请求伪造）：CSRF 攻击依赖 Cookie ，Session 认证中 Cookie 中的 SessionID 是由浏览器发送到服务端的，只要发出请求，Cookie 就会被携带（身份就被确定） 适合移动端——Session认证需要Cookie 故不适合（移动端特点：无状态 兼容性强（cookie跨域问题） 安全性差） JWT常见问题： 注销登录后JWT依然有效：存入Redis（违背无状态）+ 保持令牌有效期短并经常轮换 续签JWT：（申请两个jwt）客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。如果服务端判断 accessJWT 过期，客户端将 refreshJWT 传给服务端。如果有效，服务端生成新的 accessJWT 给客户端。否则，客户端重新登录 体积过大：减少payload信息 + 换用传统的token（save in redis） Interceptor：属于Spring MVC（Filter属于Servlet 对所有访问都增强 此只对SpringMVC访问增强） 动态拦截方法调用的机制，在SpringMVC中动态拦截Controller方法的执行 引申 SpringMVC工作流程： 客户端（浏览器）发送请求， DispatcherServlet拦截请求。 DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 URL 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器），并会将请求涉及到的拦截器和 Handler 一起封装。 DispatcherServlet 调用 HandlerAdapter适配器执行 Handler 。 Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet， ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器） Cache Aside Pattern+超时剔除 旁路缓存——适合读多写少场景\n服务端同时维系DB与cache（redis） 并以DB结果为准 写：先更新DB 后删除cache 读：从cache中读 读不到从DB中读并把数据写到cache中 缺点： 首次请求数据一定不在cache里——热点数据提前放入cache 写操作频繁时cache中数据会被频繁删除 影响缓存命中率 超时剔除：向redis中添加缓存数据的时候设置TTL时间，到期后自动删除缓存，下次查询时更新缓存 引申 三种缓存读写策略：（其它的） 读写穿透：以cache为中心 写：cache中不存在 直接更新DB / cache中存在 先更新cache 后cache更新DB 读：cache读到就返回 / 读不到先从DB加载 写入到cache中后返回 缺点：首次请求一定不在cache中 写回：异步缓存写入，以cache为中心 OS的设计，Redis没有异步更新DB的功能，适合写多的场景\n类似读写穿透 但只更新cache不更新DB 异步批量更新DB Redisson分布式锁+乐观锁 分布式锁：多进程条件下 控制某个资源在同一时刻只能被一个应用所使用（线程用synchronized即可）\n源码（看门狗 Lua脚本啥的） 分布式锁的要求： 互斥性：同一时刻只能有一个节点持有锁 可重入性：允许持有锁的节点在释放锁后再次获取锁 安全性：确保即使节点崩溃或网络故障，锁不会被永久占用 高性能：锁的获取和释放应该是高效的操作 Redisson过程： 获取锁（Lua+订阅功能）：当一个线程尝试获取锁时，Redisson会在Redis中创建一个字符串类型的键值对，键是锁的名称，值是线程的唯一标识（通常是线程ID）。如果获取锁成功，Redisson会设置一个过期时间，以防止锁被长时间占用。过期时间通常使用随机值，以避免锁过期时间冲突。如果获取锁失败，Redisson会等待一段时间，然后重试。这个等待时间通常是随机的，以减少锁争用 释放锁（Lua）：当一个线程释放锁时，Redisson会检查锁的持有者是否与当前线程匹配。如果匹配，Redisson会删除锁的键值对，释放锁。如果持有锁的线程在锁过期后仍然未释放锁，其他线程可以尝试获取锁 乐观锁\u0026悲观锁 悲观锁：认为共享资源每次被访问的时候就会出现问题–\u003e共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程 eg.synchronized ReentrantLock 易发生线程阻塞 乐观锁：只在提交修改的时候验证数据是否被其它线程修改过——版本号/CAS算法（eg.AtomicInteger LongAdder） 如何实现？ 版本号：数据表中添加version字段 要修改时，线程A读取version，提交更新时，比较当前数据中的version是否与自己读到的version的值相同，若相同则version++，不同则重试更新 CAS（Compare And Swap）——原子操作——三个操作数： V：要更新的变量值(Var) E：预期值(Expected) N：拟写入的新值(New) 仅当V==E时，原子执行用N替代V，不等时说明V已被更新，告知此线程并允许重试 CAS如何实现：Unsafe类 依赖于CPU的原子指令 由JNI调用Cpp内联汇编实现 (Unsafe类的CAS方法是native方法，表明这些方法由本地代码（通常是 C 或 C++）实现，直接调用底层的硬件指令来实现原子操作。具体实现与OS CPU相关) 底层通常是while循环 eg.getAndAddInt–\u003e自旋锁 // 原子地获取并增加整数值 public final int getAndAddInt(Object o, long offset, int delta) { int v; do { // 以 volatile 方式获取对象 o 在内存偏移量 offset 处的整数值 v = getIntVolatile(o, offset); } while (!compareAndSwapInt(o, offset, v, v + delta)); // 返回旧值 return v; } CAS算法问题： ABA——初次读取为A 中间可能有其它线程把数据改为B 准备赋值时检查到仍为A–\u003eCAS误以为其没被修改过 解决：变量前添加版本号/时间戳–\u003eJDK 1.5 后的 AtomicStampedReference 类添加了 循环时间长开销大（cause自旋锁） 解决：若JVM支持处理器的pause指令可解 可延迟流水线执行指令 避免内存顺序冲突 只能保证一个共享变量的原子操作 解决：jdk1.5后的 AtomicStampedReference 类解决了（封装为一个类） 引申 (CAS) 内存顺序冲突：多个CPU同时修改同个缓存行的不同部分引起其中一个CPU操作无效 自旋锁快释放时 持锁线程有store命令 自旋线程会发出各自load命令，而此处并没任何 happen-before 排序，所以处理器是乱序执行。–\u003epause可以减少并行load数量 Redis+Lua 异步场景：Redis进行判断购买条件与“扣减库存” tomcat根据其传回的信息判断是否添加到阻塞队列并返回订单id mysql异步下单\nLua脚本判断是否重复下单 是否有库存 分别返回不同的数字 条件通过的加入阻塞队列 第二线程：阻塞队列中分别对每个订单进行处理（mysql），此时跟Redisson联动获取锁对mysql进行更改（创建订单） 无论是否报异常 都要释放锁 ","wordCount":"6426","inLanguage":"en","datePublished":"2024-11-16T12:16:45+08:00","dateModified":"2024-12-13T23:13:45+08:00","author":[{"@type":"Person","name":"Satti"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Sattiluvcat.github.io/en/posts/java/%E7%82%B9%E8%AF%84proj/"},"publisher":{"@type":"Organization","name":"Satti's Blog","logo":{"@type":"ImageObject","url":"https://Sattiluvcat.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Sattiluvcat.github.io/en/ accesskey=h title="Satti's Blog (Alt + H)"><img src=https://Sattiluvcat.github.io/img/label1.jpg alt aria-label=logo height=35>Satti's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Sattiluvcat.github.io/en/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://Sattiluvcat.github.io/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://Sattiluvcat.github.io/en/tags title=📑标签><span>📑标签</span></a></li><li><a href=https://Sattiluvcat.github.io/en/lulu/ title=😽Lulu><span>😽Lulu</span></a></li><li><a href=https://Sattiluvcat.github.io/en/archives/ title=📅时间轴><span>📅时间轴</span></a></li><li><a href=https://Sattiluvcat.github.io/en/about/ title=😎关于><span>😎关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Sattiluvcat.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/>文章</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/java/>Java💻</a></div><h1 class="post-title entry-hint-parent">点评Proj</h1><div class=post-description>又是来自黑马的烂大街项目——小小点评，也是Redis基础的一个延伸</div><div class=post-meta><span title='2024-11-16 12:16:45 +0800 +0800'>2024-11-16</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;<span title='Last updated 2024-12-13 23:13:45 +0800 +0800'>Last updated on 2024-12-13</span>&nbsp;·&nbsp;Satti</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8a%9f%e8%83%bd%e5%ae%8c%e5%96%84 aria-label=功能完善>功能完善</a><ul><li><a href=#%e6%8b%a6%e6%88%aa%e5%99%a8 aria-label=拦截器>拦截器</a></li><li><a href=#session aria-label=session>session</a></li><li><a href=#redis aria-label=Redis>Redis</a></li><li><a href=#%e7%bc%93%e5%ad%98 aria-label=缓存>缓存</a><ul><li><a href=#%e7%bc%93%e5%ad%98%e6%9b%b4%e6%96%b0%e7%ad%96%e7%95%a5 aria-label=缓存更新策略>缓存更新策略</a><ul><li><a href=#%e4%b8%bb%e5%8a%a8%e6%9b%b4%e6%96%b0 aria-label=主动更新>主动更新</a></li></ul></li><li><a href=#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f aria-label=缓存穿透>缓存穿透</a></li><li><a href=#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9 aria-label=缓存雪崩>缓存雪崩</a></li><li><a href=#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf aria-label=缓存击穿>缓存击穿</a></li></ul></li><li><a href=#%e7%a7%92%e6%9d%80 aria-label=秒杀>秒杀</a><ul><li><a href=#%e5%85%a8%e5%b1%80id aria-label=全局ID>全局ID</a></li><li><a href=#%e8%b6%85%e5%8d%96 aria-label=超卖>超卖</a></li><li><a href=#%e4%b8%80%e4%ba%ba%e4%b8%80%e5%8d%95 aria-label=一人一单>一人一单</a></li><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label=分布式锁>分布式锁</a><ul><li><a href=#redisson aria-label=Redisson>Redisson</a></li><li><a href=#%e5%bc%82%e6%ad%a5%e4%bc%98%e5%8c%96 aria-label=异步优化>异步优化</a></li></ul></li></ul></li><li><a href=#spring-security aria-label="Spring Security">Spring Security</a><ul><li><a href=#%e9%89%b4%e6%9d%83 aria-label=鉴权>鉴权</a></li></ul></li><li><a href=#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97 aria-label=消息队列>消息队列</a><ul><li><a href=#%e5%b0%81%e8%a3%85 aria-label=封装>封装</a></li></ul></li></ul></li><li><a href=#%e5%85%b6%e5%ae%83 aria-label=其它>其它</a><ul><li><a href=#jmeter aria-label=JMeter>JMeter</a></li><li><a href=#%e6%8b%86%e7%ae%b1%e8%a3%85%e7%ae%b1%e9%97%ae%e9%a2%98 aria-label=拆箱装箱问题>拆箱装箱问题</a></li><li><a href=#%e7%9f%a5%e8%af%86%e7%82%b9%e6%80%bb%e7%bb%93 aria-label=知识点总结>知识点总结</a><ul><li><a href=#jwtinterceptor aria-label=JWT+Interceptor>JWT+Interceptor</a><ul><li><a href=#%e5%bc%95%e7%94%b3 aria-label=引申>引申</a></li></ul></li><li><a href=#cache-aside-pattern%e8%b6%85%e6%97%b6%e5%89%94%e9%99%a4 aria-label="Cache Aside Pattern+超时剔除">Cache Aside Pattern+超时剔除</a><ul><li><a href=#%e5%bc%95%e7%94%b3-1 aria-label=引申>引申</a></li></ul></li><li><a href=#redisson%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e4%b9%90%e8%a7%82%e9%94%81 aria-label=Redisson分布式锁+乐观锁>Redisson分布式锁+乐观锁</a><ul><li><a href=#%e4%b9%90%e8%a7%82%e9%94%81%e6%82%b2%e8%a7%82%e9%94%81 aria-label=乐观锁&悲观锁>乐观锁&悲观锁</a></li><li><a href=#%e5%bc%95%e7%94%b3-2 aria-label=引申>引申</a></li></ul></li><li><a href=#redislua aria-label=Redis+Lua>Redis+Lua</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p> </p><p> </p><h2 id=功能完善>功能完善<a hidden class=anchor aria-hidden=true href=#功能完善>#</a></h2><h3 id=拦截器>拦截器<a hidden class=anchor aria-hidden=true href=#拦截器>#</a></h3><ol><li>Utils中实现添加拦截器Interceptor功能，在config中添加MVCConfig以添加拦截器并设置排除拦截的地址</li></ol><h3 id=session>session<a hidden class=anchor aria-hidden=true href=#session>#</a></h3><blockquote><p>存储用户基本信息即可</p></blockquote><ol><li>多台Tomcat不共享session空间（存储当前用户信息）&ndash;>切换不同Tomcat时数据丢失<ul><li>需要数据共享 内存存储 键值 ==>Redis替代</li></ul></li></ol><h3 id=redis>Redis<a hidden class=anchor aria-hidden=true href=#redis>#</a></h3><ol><li>保存用户时以随机token作为key</li><li>设置有效期 另外用户访问时持续更新时长&ndash;>在拦截器中设置</li><li>取出Hash类型的所有字段&ndash;><code>entries</code></li></ol><h3 id=缓存>缓存<a hidden class=anchor aria-hidden=true href=#缓存>#</a></h3><blockquote><p>数据交换缓冲区 临时存储数据 读写性能较高</p></blockquote><ol><li>注意：添加缓存时根据Redis中类型转换变量类型<ul><li>Redis使用String类型——以JSON形式存储，需转换</li></ul></li></ol><h4 id=缓存更新策略>缓存更新策略<a hidden class=anchor aria-hidden=true href=#缓存更新策略>#</a></h4><ol><li>内存淘汰 Redis内存不足时自动淘汰部分数据<ul><li>一致性差 无维护成本</li></ul></li><li>超时剔除 为缓存数据添加TTL时间 下次查询时更新缓存<ul><li>一致性一般</li></ul></li><li>主动更新 Cache Aside & Read/Write Through & Write Back<ul><li>一致性好</li></ul></li></ol><h5 id=主动更新>主动更新<a hidden class=anchor aria-hidden=true href=#主动更新>#</a></h5><ol><li>Cache Aside Pattern<ul><li>更新缓存无效写操作较多（若查询很少）——>删除缓存 查询时再更新缓存</li><li>保证缓存与数据库操作同时成功/失败——><ul><li>单体系统：缓存与数据库变一个事务</li><li>分布式系统：TCC等分布式事务方案</li></ul></li><li>先删缓存再改数据库or先修改数据库（线程安全性）——>先改数据库后删缓存<ul><li>封装成事务
<img loading=lazy src=image-3.png alt="alt text"></li></ul></li></ul></li></ol><h4 id=缓存穿透>缓存穿透<a hidden class=anchor aria-hidden=true href=#缓存穿透>#</a></h4><blockquote><p>客户端请求的数据在缓存和数据库中都不存在</p></blockquote><ol><li>缓存空对象：在Redis中缓存键值对null<ul><li>造成额外的内存消耗——设置TTL解决</li><li>可能造成短期不一致</li></ul></li><li>布隆过滤：客户端到Redis之间设置布隆过滤器 判断存在则放行 不存在则拒绝请求<ul><li>≈ 数据库中数据通过Hash转换后在过滤器中以二进制位形式存储</li><li>优点：内存占用较少 没有多余key</li><li>缺点：实现复杂 <strong>可能误判（判为存在）</strong></li></ul></li></ol><blockquote><p>选择缓存空对象</p></blockquote><ol start=3><li>其它解决方案：增加id复杂度 & 做好数据的基础格式校验 & 用户权限校验 & 热点参数限流</li></ol><h4 id=缓存雪崩>缓存雪崩<a hidden class=anchor aria-hidden=true href=#缓存雪崩>#</a></h4><blockquote><p>同一时段内大量缓存key同时失效/Redis服务宕机 导致大量请求到达数据库——>巨大压力</p></blockquote><ol><li>给不同key的TTL设置随机值</li><li>利用Redis集群提高服务的可用性</li><li>缓存业务添加降级限流策略（牺牲部分服务）</li><li>给业务添加多级缓存（浏览器 nginx JVM…都设置缓存）</li></ol><h4 id=缓存击穿>缓存击穿<a hidden class=anchor aria-hidden=true href=#缓存击穿>#</a></h4><blockquote><p>“热点key问题” 被高并发访问&缓存重建业务（查询数据库并更新缓存）较复杂的key突然失效 无数请求访问会给数据库带来巨大冲击</p></blockquote><ol><li>互斥锁——（查询缓存未命中后）获取互斥锁成功后才可进行缓存重建，若获取失败 休眠一会后重试<ul><li>优点：无额外内存消耗 & 保证一致性 & 实现简单</li><li>缺点：线程需要等待 性能受影响 & 可能死锁</li></ul></li><li>逻辑过期——存储热点key的value时在value中增加逻辑过期值expire（实际上不设置TTL） 手动回收<ul><li>查询缓存 检查逻辑时间是否已过期<ul><li>已过期，获取互斥锁成功，开启新线程来更新expire，本线程返回过期数据，新线程更新完毕释放锁</li><li>已过期，获取互斥锁失败，返回过期数据</li></ul></li><li>优点：线程无需等待 性能较好</li><li>缺点：不保证一致性（返回旧数据） & 有额外内存消耗 & 实现复杂</li></ul></li><li>使用逻辑过期 创建线程池</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>ExecutorService</span><span class=w> </span><span class=n>CACHE_REBUILD_EXECUTOR</span><span class=o>=</span><span class=w> </span><span class=n>Executors</span><span class=p>.</span><span class=na>newFixedThreadPool</span><span class=p>(</span><span class=n>10</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h3 id=秒杀>秒杀<a hidden class=anchor aria-hidden=true href=#秒杀>#</a></h3><h4 id=全局id>全局ID<a hidden class=anchor aria-hidden=true href=#全局id>#</a></h4><blockquote><p>针对优惠券</p></blockquote><ol><li>订单表不用自增ID：id规律性明显 & 受单表数据量限制</li><li>分布式系统下生成全局唯一ID的工具<ul><li>高可用 递增性 安全性 高性能 唯一性</li></ul></li><li>ID组成：符号位 + 时间戳（31位） + 序列号（32位）<ul><li>设置每天一个key 避免超过上限</li></ul></li></ol><h4 id=超卖>超卖<a hidden class=anchor aria-hidden=true href=#超卖>#</a></h4><ol><li>产生：对库存进行操作完成前 有线程访问 即会产生超卖</li><li>锁：<ul><li>悲观锁：线程安全问题一定发生，操作数据前先获取锁eg.Synchronized lock</li><li>乐观锁：不一定发生，只在更新数据时判断是否有其他线程对数据进行了修改</li></ul></li><li>乐观锁：两种方案<ul><li>版本号法：数据库中添加version字段，修改时需校验version与之前查到的是否一致，一致时同时更新版本号</li><li>CAS法：直接把库存当版本即可<ul><li>成功率过低</li></ul></li></ul></li></ol><h4 id=一人一单>一人一单<a hidden class=anchor aria-hidden=true href=#一人一单>#</a></h4><ol><li>加悲观锁——Synchronized 对同一个用户加锁，intern方法保证只对该值加锁 不是新创建对象（toString会新创建对象）<ul><li>当锁在事务中时，锁释放后事务尚未提交 ==> 其他线程仍有可能访问到未更新的内容</li><li>锁在方法上时，会对所有this对象都加锁and···，范围太广</li><li>选定把锁加在<strong>方法调用</strong>上</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>userId</span><span class=p>.</span><span class=na>toString</span><span class=p>().</span><span class=na>intern</span><span class=p>())</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li>锁加在方法调用上时，this的对象并非代理（Impl）对象，Spring的事务<strong>会失效</strong>，解决方法选择获取代理对象</li></ol><blockquote><p>注意有几种使Spring的事务失效的可能 有几种解决方案</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>userId</span><span class=p>.</span><span class=na>toString</span><span class=p>().</span><span class=na>intern</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>IVoucherOrderService</span><span class=w> </span><span class=n>proxy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>IVoucherOrderService</span><span class=p>)</span><span class=w> </span><span class=n>AopContext</span><span class=p>.</span><span class=na>currentProxy</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>proxy</span><span class=p>.</span><span class=na>createVoucherOrder</span><span class=p>(</span><span class=n>voucherId</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><pre><code>* 主方法中添加注解`@EnableAspectJAutoProxy(exposeProxy = true)`
* 添加AspectJweaver依赖
</code></pre><ol start=3><li>集群设备访问 失效<ul><li>测试时设置虚拟机设置（VM options）修改为多个端口号</li></ul></li></ol><h4 id=分布式锁>分布式锁<a hidden class=anchor aria-hidden=true href=#分布式锁>#</a></h4><blockquote><p>满足分布式系统/集群模式下多进程可见&互斥的锁</p></blockquote><ol><li>要求：多进程可见 + 互斥 + 高可用 + 高性能 + 安全性 + ···</li><li>对比：MySql Redis Zookeeper</li></ol><table><thead><tr><th>维度</th><th>MS</th><th>R</th><th>Zk</th></tr></thead><tbody><tr><td>互斥</td><td>自身的互斥锁</td><td>setnx等互斥命令</td><td>节点唯一性 有序性实现</td></tr><tr><td>高可用</td><td>好</td><td>好</td><td>好</td></tr><tr><td>高性能</td><td>一般</td><td>好</td><td>一般</td></tr><tr><td>安全性</td><td>断开连接自动释放锁</td><td>锁超时时间设置</td><td>临时节点 断开连接则释放</td></tr></tbody></table><ol start=3><li>实现：设置锁的同时保证互斥（设置锁&设置过期时间 语句合二为一）<ul><li>业务完成后需手动释放锁</li></ul></li></ol><pre tabindex=0><code class=language-Redis data-lang=Redis>SET lock thread1 NX EX 10
</code></pre><ol start=4><li>问题：误删（eg.某线程业务阻塞 锁超时释放 其他线程即可获取锁 此后原业务再释放即释放了其它线程的锁）<ul><li>解决：删除锁时对比value是否是本线程——修改释放锁逻辑即可</li><li>value存储某固定UUID+<strong>线程标识</strong></li></ul></li><li>新问题：判断标识与释放锁必同时进行（否则过程中发生阻塞后也会有问题——Java自身导致的）<ul><li>解决：保证原子性——Lua脚本（不用Redis的事务机制）<ul><li>一个脚本中编写多条命令</li></ul></li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-Lua data-lang=Lua><span class=line><span class=cl><span class=c1>-- 从1开始计数</span>
</span></span><span class=line><span class=cl><span class=kd>local</span> <span class=n>key</span><span class=o>=</span><span class=n>KEYS</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1>-- 非key的都用ARGV保存</span>
</span></span><span class=line><span class=cl><span class=kd>local</span> <span class=n>threadId</span><span class=o>=</span><span class=n>ARGV</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div><ol start=6><li>隐患：（极小概率）——Redisson解决<ul><li>不可重入——同个线程不可多次获取同一把锁</li><li>不可重试</li><li>超时释放——业务执行耗时较长 锁也会释放</li><li>主从一致性</li></ul></li></ol><h5 id=redisson>Redisson<a hidden class=anchor aria-hidden=true href=#redisson>#</a></h5><ol><li>设置：引入依赖——配置config——注入后直接使用</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>RedissonConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>RedissonClient</span><span class=w> </span><span class=nf>redissonClient</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Config</span><span class=w> </span><span class=n>config</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Config</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>config</span><span class=p>.</span><span class=na>useSingleServer</span><span class=p>().</span><span class=na>setAddress</span><span class=p>(</span><span class=s>&#34;redis://192.168.balabal:6379&#34;</span><span class=p>).</span><span class=na>setPassword</span><span class=p>(</span><span class=s>&#34;123456&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>org</span><span class=p>.</span><span class=na>redisson</span><span class=p>.</span><span class=na>Redisson</span><span class=p>.</span><span class=na>create</span><span class=p>(</span><span class=n>config</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol start=2><li><p>可重入锁原理👇：同一线程可以多次访问一个锁——Redis用Hash结构保存，value为访问次数，当最后value==0时释放锁（若非0，则重置有效期后继续执行业务——不在最外侧）</p><ul><li>Lua脚本编写</li></ul></li><li><p>可重试：订阅等功能实现——等待、唤醒、获取锁失败👇</p></li><li><p>超时续约：watchDog 每隔一段时间重置超时时间（<code>leaseTime=-1</code>时自动进入）👇</p></li><li><p>Redisson分布式锁过程👇（读源码）<a href=https://www.bilibili.com/video/BV1cr4y1671t/ style=color:#000;text-decoration:underline>下图来自：黑马程序员Redis入门到实战教程</a>
<img loading=lazy src=image-5.png alt="alt text"></p></li><li><p>主从一致性（主从同步有延时/同步失败时）——设置多Node 必须在所有Node都获得锁程序才获得锁（也可以继续给Node配Slave节点）</p></li></ol><h5 id=异步优化>异步优化<a hidden class=anchor aria-hidden=true href=#异步优化>#</a></h5><ol><li>（Lua脚本）Redis进行判断购买条件与“扣减库存” tomcat根据其传回的信息判断是否添加到阻塞队列并返回订单id mysql异步下单<ul><li>两线程进行</li></ul></li><li>阻塞队列 <code>BlockingQuene</code>——队列为空时 阻塞进程；队满时插入 阻塞进程</li></ol><h3 id=spring-security>Spring Security<a hidden class=anchor aria-hidden=true href=#spring-security>#</a></h3><h4 id=鉴权>鉴权<a hidden class=anchor aria-hidden=true href=#鉴权>#</a></h4><ol><li>权限：访问 执行 控制 共享</li><li>RBAC&ndash;>role-based access control<ol><li>RBAC0：用户&ndash;>角色&ndash;>许可（均为多对多） == 3+2张表（对应关系表）</li><li>RBAC1：引入角色继承机制（角色间的等级关系）</li><li>RBAC2：在0的基础上引入对角色的约束&ndash;>一个用户不能同时具有两种特定的权限</li><li>RBAC3：约束+继承</li></ol></li><li>注解 eg.<code>PreAuthorize</code>&ndash;>提前鉴权验证</li><li>基于RBAC鉴权模型添加统一功能 &ndash;> AOP（切面 = 切点 通知 连接点 ···）<ul><li>拦截指定方法并增强，无需侵入业务代码</li><li>模块化 非侵入式 可重用性 松耦合 提高性能与可拓展性</li><li>（spring boot）启动类添加注解Enable<strong>AspectJ</strong>AutoProxy<ul><li>定义接口anno 添加<code>Target</code> <code>Retention</code>注解——target的是method 在runtime有效运行</li><li>切面类编写 添加<code>Aspect</code> <code>Component</code>注解——切面类方法的具体实现</li><li>(配置AOP时 把目标类&切面类都bean（添加注解<code>@Component</code>交予容器管理）)</li><li>指定pointcut地址（目标方法地址）</li></ul></li><li></li></ul></li></ol><h3 id=消息队列>消息队列<a hidden class=anchor aria-hidden=true href=#消息队列>#</a></h3><p>待施工···</p><h4 id=封装>封装<a hidden class=anchor aria-hidden=true href=#封装>#</a></h4><ol><li>泛型</li></ol><h2 id=其它>其它<a hidden class=anchor aria-hidden=true href=#其它>#</a></h2><h3 id=jmeter>JMeter<a hidden class=anchor aria-hidden=true href=#jmeter>#</a></h3><ol><li>运行jmeter.bat即可
<img loading=lazy src=image-4.png alt="alt text"></li></ol><h3 id=拆箱装箱问题>拆箱装箱问题<a hidden class=anchor aria-hidden=true href=#拆箱装箱问题>#</a></h3><blockquote><p>Boolean-boolean Integer-int等</p></blockquote><h3 id=知识点总结>知识点总结<a hidden class=anchor aria-hidden=true href=#知识点总结>#</a></h3><h4 id=jwtinterceptor>JWT+Interceptor<a hidden class=anchor aria-hidden=true href=#jwtinterceptor>#</a></h4><ol><li>JWT组成：Header Payload Signature（前二Base64url解码后是JSON格式 签名通过前二+密钥with签名算法得到）<ol><li>Payload 部分默认不加密</li></ol></li><li>JWT如何进行身份验证？<ol><li><strong>用户</strong>向服务器发送用户名、密码以及验证码用于<strong>登陆系统</strong>。</li><li>如果用户<strong>校验正确</strong>，<strong>服务端返回已经签名的 Token，即 JWT</strong></li><li><strong>用户每次</strong>向后端发<strong>请求都在 Header 中带上 JWT</strong></li></ol><ul><li>（此处可省略）用户端最好将JWT保存到localstorage 而非Cookie（CSRF风险）</li></ul><ol start=4><li>服务端<strong>检查 JWT 并从中获取用户相关信息</strong></li></ol></li><li>防止JWT被篡改——签名比对</li><li>加强安全性方法<ol><li><strong>Payload 要加入 exp</strong> （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长</li><li>JWT 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险</li><li>不要将隐私信息存放在 Payload 中</li><li>密钥不要泄露。JWT 安全的核心在于签名，签名安全的核心在密钥</li></ol></li><li>JWT优势：<ol><li><strong>无状态</strong>：服务器不需要存储每次会话的客户端信息（传来JWT后用加密算法比对签名即可）</li><li>避免CSRF（跨站请求伪造）：CSRF 攻击依赖 Cookie ，Session 认证中 Cookie 中的 SessionID 是由浏览器发送到服务端的，只要发出请求，Cookie 就会被携带（身份就被确定）</li><li>适合移动端——Session认证需要Cookie 故不适合（移动端特点：无状态 兼容性强（cookie跨域问题） 安全性差）</li></ol></li><li>JWT常见问题：<ol><li>注销登录后JWT依然有效：存入Redis（违背无状态）+ 保持令牌有效期短并经常轮换</li><li>续签JWT：（申请两个jwt）客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。如果服务端判断 accessJWT 过期，客户端将 refreshJWT 传给服务端。如果有效，服务端生成新的 accessJWT 给客户端。否则，客户端重新登录</li><li>体积过大：减少payload信息 + 换用传统的token（save in redis）</li></ol></li><li>Interceptor：属于Spring MVC（Filter属于Servlet 对所有访问都增强 此只对SpringMVC访问增强）<ol><li>动态拦截方法调用的机制，在SpringMVC中动态拦截Controller方法的执行</li></ol></li></ol><h5 id=引申>引申<a hidden class=anchor aria-hidden=true href=#引申>#</a></h5><ol><li>SpringMVC工作流程：<ul><li>客户端（浏览器）发送请求， DispatcherServlet拦截请求。</li><li>DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 URL 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器），并会将请求涉及到的拦截器和 Handler 一起封装。</li><li>DispatcherServlet 调用 HandlerAdapter适配器执行 Handler 。</li><li>Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，<ul><li>ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。</li></ul></li><li>ViewResolver 会根据逻辑 View 查找实际的 View。</li><li>DispaterServlet 把返回的 Model 传给 View（视图渲染）。</li><li>把 View 返回给请求者（浏览器）</li></ul></li></ol><h4 id=cache-aside-pattern超时剔除>Cache Aside Pattern+超时剔除<a hidden class=anchor aria-hidden=true href=#cache-aside-pattern超时剔除>#</a></h4><blockquote><p>旁路缓存——适合读多写少场景</p></blockquote><ol><li>服务端同时维系DB与cache（redis） 并以DB结果为准<ol><li>写：先更新DB 后删除cache</li><li>读：从cache中读 读不到从DB中读并把数据写到cache中</li></ol></li><li>缺点：<ol><li>首次请求数据一定不在cache里——热点数据提前放入cache</li><li>写操作频繁时cache中数据会被频繁删除 影响缓存命中率</li></ol></li><li>超时剔除：向redis中添加缓存数据的时候设置TTL时间，到期后自动删除缓存，下次查询时更新缓存</li></ol><h5 id=引申-1>引申<a hidden class=anchor aria-hidden=true href=#引申-1>#</a></h5><ol><li>三种缓存读写策略：（其它的）<ol><li>读写穿透：以cache为中心<ol><li>写：cache中不存在 直接更新DB / cache中存在 先更新cache 后cache更新DB</li><li>读：cache读到就返回 / 读不到先从DB加载 写入到cache中后返回</li><li>缺点：首次请求一定不在cache中</li></ol></li><li>写回：异步缓存写入，以cache为中心</li></ol><blockquote><p>OS的设计，Redis没有异步更新DB的功能，适合写多的场景</p></blockquote><ol><li>类似读写穿透 但只更新cache不更新DB <strong>异步批量更新DB</strong></li></ol></li></ol><h4 id=redisson分布式锁乐观锁>Redisson分布式锁+乐观锁<a hidden class=anchor aria-hidden=true href=#redisson分布式锁乐观锁>#</a></h4><blockquote><p>分布式锁：多<strong>进程</strong>条件下 控制某个资源在同一时刻只能被一个应用所使用（线程用synchronized即可）</p></blockquote><ol><li>源码（看门狗 Lua脚本啥的）</li><li>分布式锁的要求：<ul><li>互斥性：同一时刻只能有一个节点持有锁</li><li>可重入性：允许持有锁的节点在释放锁后再次获取锁</li><li>安全性：确保即使节点崩溃或网络故障，<strong>锁不会被永久占用</strong></li><li>高性能：锁的获取和释放应该是高效的操作</li></ul></li><li>Redisson过程：<ol><li>获取锁（Lua+订阅功能）：当一个线程尝试获取锁时，Redisson会在Redis中创建一个字符串类型的键值对，键是锁的名称，值是线程的唯一标识（通常是线程ID）。如果获取锁成功，Redisson会设置一个过期时间，以防止锁被长时间占用。过期时间通常使用随机值，以避免锁过期时间冲突。如果获取锁失败，Redisson会等待一段时间，然后重试。这个等待时间通常是随机的，以减少锁争用</li><li>释放锁（Lua）：当一个线程释放锁时，Redisson会检查锁的持有者是否与当前线程匹配。如果匹配，Redisson会删除锁的键值对，释放锁。如果持有锁的线程在锁过期后仍然未释放锁，其他线程可以尝试获取锁</li></ol></li></ol><h5 id=乐观锁悲观锁>乐观锁&悲观锁<a hidden class=anchor aria-hidden=true href=#乐观锁悲观锁>#</a></h5><ol><li>悲观锁：认为共享资源每次被访问的时候就会出现问题&ndash;>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程 eg.synchronized ReentrantLock<ol><li>易发生线程阻塞</li></ol></li><li>乐观锁：只在提交修改的时候验证数据是否被其它线程修改过——版本号/CAS算法（eg.AtomicInteger LongAdder）<ol><li>如何实现？<ol><li>版本号：数据表中添加<code>version</code>字段 要修改时，线程A读取<code>version</code>，提交更新时，比较当前数据中的<code>version</code>是否与自己读到的<code>version</code>的值相同，若相同则<code>version++</code>，不同则重试更新</li><li>CAS（Compare And Swap）——原子操作——三个操作数：<ul><li>V：要更新的变量值(Var)</li><li>E：预期值(Expected)</li><li>N：拟写入的新值(New)</li><li>仅当V==E时，原子执行用N替代V，不等时说明V已被更新，告知此线程并允许重试</li></ul></li></ol></li></ol></li><li>CAS如何实现：<code>Unsafe</code>类 依赖于CPU的原子指令 由JNI调用Cpp内联汇编实现<ol><li>(Unsafe类的CAS方法是<code>native</code>方法，表明这些方法由本地代码（通常是 C 或 C++）实现，直接调用底层的硬件指令来实现原子操作。具体实现与OS CPU相关)</li><li>底层通常是while循环 eg.<code>getAndAddInt</code>&ndash;><strong>自旋锁</strong></li></ol></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 原子地获取并增加整数值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>getAndAddInt</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>o</span><span class=p>,</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>offset</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>delta</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>v</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>do</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 以 volatile 方式获取对象 o 在内存偏移量 offset 处的整数值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getIntVolatile</span><span class=p>(</span><span class=n>o</span><span class=p>,</span><span class=w> </span><span class=n>offset</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>compareAndSwapInt</span><span class=p>(</span><span class=n>o</span><span class=p>,</span><span class=w> </span><span class=n>offset</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>delta</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 返回旧值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>v</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ol><li>CAS算法问题：<ol><li>ABA——初次读取为A 中间可能有其它线程把数据改为B 准备赋值时检查到仍为A&ndash;>CAS误以为其没被修改过</li></ol><ul><li>解决：变量前添加版本号/时间戳&ndash;>JDK 1.5 后的 <code>AtomicStampedReference</code> 类添加了</li></ul><ol><li>循环时间长开销大（cause自旋锁）</li></ol><ul><li>解决：若JVM支持处理器的<code>pause</code>指令可解<ol><li>可延迟流水线执行指令</li><li>避免内存顺序冲突</li></ol></li></ul><ol><li>只能保证一个共享变量的原子操作</li></ol><ul><li>解决：jdk1.5后的 <code>AtomicStampedReference</code> 类解决了（封装为一个类）</li></ul></li></ol><h5 id=引申-2>引申<a hidden class=anchor aria-hidden=true href=#引申-2>#</a></h5><ol><li>(CAS) 内存顺序冲突：多个CPU同时修改同个缓存行的不同部分引起其中一个CPU操作无效<ol><li>自旋锁快释放时 持锁线程有store命令 自旋线程会发出各自load命令，而此处并没任何 happen-before 排序，所以处理器是乱序执行。&ndash;>pause可以减少并行load数量</li></ol></li></ol><h4 id=redislua>Redis+Lua<a hidden class=anchor aria-hidden=true href=#redislua>#</a></h4><blockquote><p>异步场景：Redis进行判断购买条件与“扣减库存” tomcat根据其传回的信息判断是否添加到阻塞队列并返回订单id mysql异步下单</p></blockquote><ol><li>Lua脚本判断是否重复下单 是否有库存 分别返回不同的数字 条件通过的加入阻塞队列</li><li>第二线程：阻塞队列中分别对每个订单进行处理（mysql），此时跟Redisson联动获取锁对mysql进行更改（创建订单） 无论是否报异常 都要释放锁</li></ol><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></div><footer class=post-footer><ul class=post-tags><li><a href=https://Sattiluvcat.github.io/en/tags/java/>Java</a></li><li><a href=https://Sattiluvcat.github.io/en/tags/redis/>Redis</a></li></ul><nav class=paginav><a class=prev href=https://Sattiluvcat.github.io/en/posts/java/cs186/><span class=title>« Prev</span><br><span>CS186</span>
</a><a class=next href=https://Sattiluvcat.github.io/en/posts/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/><span class=title>Next »</span><br><span>计算机网络</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 点评Proj on x" href="https://x.com/intent/tweet/?text=%e7%82%b9%e8%af%84Proj&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E7%2582%25B9%25E8%25AF%2584proj%2f&amp;hashtags=Java%2cRedis"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 点评Proj on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E7%2582%25B9%25E8%25AF%2584proj%2f&amp;title=%e7%82%b9%e8%af%84Proj&amp;summary=%e7%82%b9%e8%af%84Proj&amp;source=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E7%2582%25B9%25E8%25AF%2584proj%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 点评Proj on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E7%2582%25B9%25E8%25AF%2584proj%2f&title=%e7%82%b9%e8%af%84Proj"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 点评Proj on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E7%2582%25B9%25E8%25AF%2584proj%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 点评Proj on whatsapp" href="https://api.whatsapp.com/send?text=%e7%82%b9%e8%af%84Proj%20-%20https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E7%2582%25B9%25E8%25AF%2584proj%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 点评Proj on telegram" href="https://telegram.me/share/url?text=%e7%82%b9%e8%af%84Proj&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E7%2582%25B9%25E8%25AF%2584proj%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 点评Proj on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e7%82%b9%e8%af%84Proj&u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E7%2582%25B9%25E8%25AF%2584proj%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://www-sattiluvcat-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><script id=dsq-count-scr src=//www-sattiluvcat-github-io.disqus.com/count.js async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://Sattiluvcat.github.io/en/>Satti's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")</script></body></html>