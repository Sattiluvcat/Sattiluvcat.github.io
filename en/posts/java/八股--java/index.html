<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")}</script></head><title>八股——Java | Satti's Blog</title><meta name=keywords content="Java"><meta name=description content="Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding"><meta name=author content="Satti"><link rel=canonical href=https://Sattiluvcat.github.io/en/posts/java/%E5%85%AB%E8%82%A1--java/><link crossorigin=anonymous href=/assets/css/stylesheet.4cbb49d9c9f8d5f7e0569491a51742137ff9f891ee8adfe0816ac791d024bb96.css integrity="sha256-TLtJ2cn41ffgVpSRpRdCE3/5+JHuit/ggWrHkdAku5Y=" rel="preload stylesheet" as=style><link rel=icon type=image/png href=/favicon-48x48.png sizes=48x48><link rel=icon type=image/svg+xml href=/favicon.svg><link rel="shortcut icon" href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta name=apple-mobile-web-app-title content="MyWebSite"><link rel=manifest href=/site.webmanifest><link rel=alternate hreflang=en href=https://Sattiluvcat.github.io/en/posts/java/%E5%85%AB%E8%82%A1--java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")}</script><meta property="og:title" content="八股——Java"><meta property="og:description" content="Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding"><meta property="og:type" content="article"><meta property="og:url" content="https://Sattiluvcat.github.io/en/posts/java/%E5%85%AB%E8%82%A1--java/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-11T16:43:40+08:00"><meta property="article:modified_time" content="2025-04-10T15:47:40+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="八股——Java"><meta name=twitter:description content="Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://Sattiluvcat.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Java💻","item":"https://Sattiluvcat.github.io/en/posts/java/"},{"@type":"ListItem","position":3,"name":"八股——Java","item":"https://Sattiluvcat.github.io/en/posts/java/%E5%85%AB%E8%82%A1--java/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"八股——Java","name":"八股——Java","description":"Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding","keywords":["Java"],"articleBody":" 基础 概念 Java特点： 平台无关性——编译器将源代码翻译为字节码，字节码可在任何安装了JVM（java虚拟机）的系统上运行 面向对象——strictly OOP，易于维护与重用（类、对象、继承、多态、抽象与封装） 内存管理——有自己的垃圾回收机制，自动管理内存和回收不再使用的对象 为什么Java是跨平台的？ Java程序经过编译后形成字节码（.class）文件，不同平台通过不同版本的JVM将字节码文件翻译为机器码后运行 JVM/JDK/JRE关系 JVM-java虚拟机，将字节码解释/编译为机器码并执行。提供内存管理、垃圾回收、安全性等功能 JRE-java运行的环境（需要的最小环境），包含JVM与一组Java类库。不包含开发工具 JDK-java开发工具包，包含JVM、**编译器（javac）、调试器（jdb）**等开发工具与类库。提供开发、编译、调试与运行的全部工具与环境 编译与解释共存？ 编译型：Java 源代码通过 javac 编译器编译成字节码，而非机器码 –\u003e 平台无关性 解释型：JVM 通过解释器将字节码逐行翻译成机器码并执行 –\u003e 即时编译JIT JIT：将热点代码（方法调用计数器计数确定）直接编译为机器码，后续执行时无需再次解释 编译和解释型的区别？ 编译型：程序执行前，整个源代码被编译为机器码/字节码，生成可执行文件 –\u003e 速度快 but 跨平台性差 解释型：程序执行时，逐行解释执行源代码（解释器动态解释），不生成独立的可执行文件 –\u003e 速度慢 but 可跨平台 数据类型 基本数据类型： 1字节；byte, boolean | 2字节：short, char | 4字节：int, float | 8字节：double, long 包装类：Character \u0026 Integer \u0026 首字母大写 char无符号，不可为负，故从0开始 类型转换： 隐式转换（自动） 显式转换（强制） 字符串转换：如字符串转为 int ，可用 Integer.parseInt() 数值间转换：整型 \u003c==\u003e 字符型，可用包装类的工具方法实现（如Character类、Integer类） 类型转换的问题： 数据丢失：范围大类型到范围小类型。如 long 到 int，会截断保留低位 数据溢出：范围小类型到范围大类型。会填充高位，原数据不变 精度损失：浮点数类型的转换 –\u003e 表示方式不同，double（高精度） 转 float 可能损失精度 类型不匹配 BigDecimal vs double double会精度丢失 –\u003e 二进制浮点运算，有时不能准确表示小数（如0.1） BigDecimal精确计算，注意用字符串创建新对象，不用浮点 –\u003e BigDecimal num1 = new BigDecimal(\"0.1\"); 装箱、拆箱 自动装箱happens when： 赋值（Java1.5后自动）： // before Java1.5 Integer iObject=Integer.valueof(3); int i=iObject.intValue(); // after Java1.5 Integer iObject=3; int i=iObject; 方法调用：实质也是赋值，将int与Integer颠倒使用 自动装箱弊端：循环中自动装箱（颠倒使用时），会创建大量无用对象 \u0026 垃圾回收工作量大 Why Java has Integer? 前提：Integer是int类型的包装类，把int类型包装成Object对象，即对象封装 作用： 泛型：Java中，泛型只能使用引用类型，而不能使用基本类型。如列表只能用List 泛型允许在定义类、接口或方法时使用类型参数（如Box），使用时再指定具体类型 转换：Java中，基本类型和引用类型不能直接进行转换，必用包装类。如int转String（转为Integer后.toString()） 集合：Java集合只能存储对象 Integer相比int优点（区别）？ 基本类型 vs 引用类型：基本类型不需实例化即可使用 ==\u003e int存储一个整数不需额外的内存分配（性能更快），Integer要为对象分配内存 引用类型，对象的引用和对象本身分开存储；基本类型，变量对应的内存块存储数据自身 So：基本类型读写效率、内存效率更高 自动拆装箱 空指针异常：Integer变量必须通过实例化对象来赋值，若其未经初始化会出现空指针异常（int默认赋0） Integer的缓存 实现静态缓存池（默认存储-128~127），通过Integer.valueOf(int)方法创建该范围内的对象时，会复用缓存中的现有对象（from内存） 面向对象 面向对象是什么？与特性 OOP：编程范式，将现实世界中的事物抽象为对象，对象具有字段（属性）与方法（行为）。具有灵活性与可拓展性 特性： 封装：将对象的属性（数据）和行为（方法）结合，仅用接口与外界交互。–\u003e增强安全性和简化编程，使对象更独立 继承：使子类可自动共享父类数据结构和方法，代码复用。–\u003e建立类与类间的层次关系，结构更清晰 多态：允许不同类的对象对同一消息作出响应，即同一个接口，使用不同实例而执行不同操作。编译时多态（重载）和运行时多态（重写）–\u003e灵活性与拓展性 多态体现？ 方法重载：同一类中可以有多个同名方法，但参数列表不同。编译器确定调用哪个方法 方法重写：子类能够提供对父类中同名方法的具体实现（不同子类可以实现不同，但参数不变）。JVM在运行时根据对象实际类型确定调用哪个方法 接口与实现：多个类可以实现同一个接口，并用接口类型的引用来调用这些类的方法 如Dog是Animal的实现类，创建实例时用：Animal dog=new Dog();（dog是Dog类的实例，Animal是dog的接口类型） 向上/下转型：子类父类共有方法可用向上转型调用，子类特有方法需要父类对象向下转型后调用 （向上转型）子类对象转换为父类对象，自动进行（如Animal dog=new Dog();） （向下转型）父类对象转换为子类对象，执行前需确认引用实际指向的对象，避免ClassCastException 多态作用 meaning：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。需要继承、接口类等语法机制 作用：提高代码的扩展性和复用性。 OOP的设计原则 单一职责原则SRP：一个类应该只负责一项职责 开放封闭原则OCP：软件实体应该对扩展（entends，子类）开放，对修改封闭。（即可以继承这个类，但不能修改类本身） 里氏替换原则LSP：子类对象应该能够替换掉所有父类对象。（不改变父类预期行为等） 接口隔离原则ISP：客户端不应该依赖那些它不需要的接口 依赖倒置原则DIP：高层模块不应该依赖低层模块，二者都应该依赖于抽象 最少知识原则：一个对象应当对其他对象有最少的了解 抽象类与普通类区别 实例化：抽象类不能被实例化，只能被继承 方法实现：抽象类中的方法可以有实现也可以没有实现 继承：一个类只能继承一个类（any），但可继承（普通类）/实现（抽象类）多个接口 限制：普通类可以被其他类继承\u0026使用，抽象类一般用作基类 抽象类 vs 接口 二者特点： 抽象类：可以有成员变量、构造方法和具体方法–\u003e适用继承关系 接口：可以多实现，只能有常量和抽象方法（无构造方法）（Java8后可以有默认方法与静态方法–\u003e定义行为规范与类的功能 区别： 实现：接口用implements，抽象类用extends，一个类多接口单抽象类 方法：接口不能有方法的实现，java8中可定义default方法体。抽象类无限制 访问修饰符： 接口成员变量默认public static final，必须赋初值不能被修改（final特性），所有成员方法都是public、abstract的 抽象类中成员变量默认default，可被子类重新定义or赋值，抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号 变量：接口只能包含（静态）常量；抽象类可包含实例变量与静态常量 抽象类可加final吗？ no。抽象类是被继承的，final禁止类的继承 or 方法重写 接口可以定义什么方法？ 抽象方法：核心，所有实现接口的类必须实现这些方法 默认方法：允许接口提供具体实现。实现类可以重写默认方法 静态方法：属于接口本身，可以通过接口名直接调用，不需实现类的对象 私有方法：Java9引入。为默认/私有方法提供辅助功能 抽象类可以被实例化吗？ 自身不能被实例化–\u003e不能直接new一个对象。但可以有构造器，创建子类实例时间接使用（不需指定super，先调用父类构造器，后调用子类构造器） 静态变量与静态方法 静态变量：属于类而非具体的对象 共享性：所有该类的实例共享同一个静态变量。一个实例修改，其它实例均知晓 初始化：在类被加载时初始化，只分配一次内存 访问方式：可以直接通过类名访问，也可以通过实例访问（建议类名） 静态方法： 无实例依赖：可在没有创建类实例的情况下调用，不能直接访问非静态的成员变量 or 方法（因为无上下文的实例） 直接访问静态成员 多态性：不支持重写，可以被Hide 使用场景： 静态变量：需要在所有对象间共享的数据，如计数器、常量等 静态方法：常用于助手方法（utility methods）获取类级别的信息或者是没有依赖于实例的数据处理 非静态内部类与静态内部类区别（以下只列出非静态特点） 外部类实例的依赖 访问外部类的变量、方法 不能定义静态成员 不能独立实例化 可以访问外部类的私有成员 非静态内部类怎么直接访问外部方法 编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。生成非静态内部类的构造方法时，将外部类实例作为参数传入 父类、子类的静态方法，在new子类对象时的加载顺序 父类静态–\u003e子类静态–\u003e父类构造器–\u003e子类构造器 拷贝 深浅拷贝： 浅拷贝：只复制对象本身和其内部的值类型字段，不复制对象内部的引用类型字段–\u003e共享引用 深拷贝：将对象内部的所有引用类型字段的内容也复制（完全独立） 实现深拷贝的方法： 实现 Cloneable 接口并重写 clone() 方法：要求对象及其所有引用类型字段都实现接口并重写方法（clone()通过递归克隆实现深拷贝） 序列化与反序列化：对象序列化为字节流，再从字节流反序列化为对象–\u003e要求对象与引用类型都实现 Serializable 接口 手动递归复制：对象及引用类型字段 如List里new AyyayList\u003c\u003e(list) 特性 泛型 什么是泛型 允许类、接口和方法在定义时使用一个或多个类型参数，使用时类型参数可以被指定为具体的类型 why need 泛型 适用于多种数据类型执行相同的代码–\u003e代码复用 泛型中的类型在使用时指定，不需要强制类型转换（如：不指定时，取出时需转换）–\u003e保证类型安全，编译器来检查 反射 需要开发者调用某些方法实现，Spring底层大量使用反射（有涉及反射的相关代码）\n什么是反射 运行时，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。动态获取的信息以及动态调用对象的方法的功能==\u003e反射机制 特性 运行时类信息访问——完整信息，父类、接口、包名、构造函数、方法、字段 动态对象创建——反射API动态地创建对象实例，即使在编译时不知道具体的类名（newInstance()） 动态方法调用——运行时动态地调用对象的方法，包括私有方法（Method类地invoke()方法） 访问与修改字段值——允许程序在运行时访问和修改对象的字段值，即使是私有的（Field类的get()/set()方法） 应用场景 加载数据库驱动 配置文件加载——IOC加载Bean 将所有XML或properties配置文件夹载入内存–\u003e解析其内容，得到对应实体类的 字节码字符串 等–\u003e利用反射，根据字符串得到类的实例–\u003e动态配置实例属性 注解 注解原理 本质是一个继承了Annotation接口的接口，实现类是Java运行时生成的动态代理类（用这个类存储注解中的属性等，调用注解方法时，代理类返回存储的值） 注解作用域Scope 类级别、方法级别、字段级别、（构造函数作用域、局部变量作用域） 可以指定属性，如访问级别、注释等 对象 创建对象的方式 new Class或Constructor类的newInstance()方法（即反射机制） clone() \u0026 反序列化（即深拷贝） clone()要实现Cloneable接口，反序列化（类）要实现Serializable接口 new的对象什么时候回收 垃圾回收器回收，回收时机取决于： 引用计数法：某对象的引用计数为0时==\u003e不再被引用 可达性分析算法：从根对象出发，通过对象的引用链遍历，拖不存在到达某对象的引用链–\u003e回收 终结器：重写finalize()方法的对象，回收对象前会调用该方法 异常 哪些异常 基于Throwable及其子类，子类包括Error与Exception Error：表示运行时环境的错误，程序无法处理。如StackOverFlowError Exception： 非运行时异常：必须编译时捕获或抛出，一般为外部错误。如FileNotFoundException，除RuntimeException及其子类的异常 受编译器检查（code时就检查） 运行时异常：程序错误导致。如NullPointerException、ArrayIndexOutOfBoundException 不受编译器检查（运行时才能发现） 异常处理 try-catch-finally： try{} catch (Exception1 e1){ // 处理第一类异常的逻辑，比如👇 throw new Exception1(\"Exception Happend!\"); } catch (Exception2 e2){} finally { // 可选，定义无论有否异常都要执行的代码块 // 一般用于资源释放 } throws：方法中声明可能抛出的异常类型，将异常传递给调用者处理 try与finally，return哪一个 返回finally中的return值–\u003etry中的返回值暂存，执行finally，最终try的结果被覆盖 Java1.8新特性——Stream \u0026 completableFuture Java的stream API 提供高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。 提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理 stream API案例 过滤 List\u003cString\u003e ans=list.stream() .filter(s -\u003e s.length()\u003e3) .collect(Collectors.toList()); 求和 stream流的并行API是什么 ParallelStream。将源数据fork为多个子流进行多线程操作，处理结果join为一个流对象–\u003e底层为通用的fork/join池 序列化 怎么把一个对象从一个jvm转移到其它jvm 序列化与反序列化：字节流 消息传递机制：消息队列/网络套接字通信，需自定协议来序列化对象 远程方法调用（RPC） 共享数据库或缓存 Java默认序列化的缺点 主流序列化框架：Protobuf、FastJson\n无法跨语言：序列化框架与协议其他语言没有实现 易被攻击：反序列化通过ObjectInputStream上调用readObject()进行，可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化–\u003e可执行任意类型的代码 序列化后流太大：二进制数组越大，占用空间越多 具体怎么转对象为二进制字节流 序列化用ObjectOutPutStream的writeObject，获取输出流，可写入二进制文件中，创建输入流并读取对象进行反序列化 需要确保类实现了Serializable接口，并且所有成员变量都是Serializable的（原生类型如int自动支持，其它引用类型需要实现该接口） 设计模式 代理模式和适配器模式的区别 目的：代理模式关注控制对对象的访问，适配器用于接口转换，使不兼容的类能一起工作 结构：代理一般包含抽象主题、真是主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色 应用场景：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作 I/O Java怎么实现网络IO高并发编程 Java NIO–\u003e同步非阻塞IO模型，基于IO多路复用实现 NIO、BIO、AIO BIO：blocking IO，基于流模型，同步阻塞交互–\u003e一个线程处理一个IO NIO：non-blocking IO，Java1.4引入，多路复用，同步非阻塞 AIO：asynchronous IO，Java1.7引入，异步非阻塞 NIO实现 用到NIO的框架–\u003eNetty\n同步核心为Selector，代替线程本身的轮询IO事件 特殊 ==与equals的区别 重写了equals的类：==比较内存的首地址（即是否指向同个对象），equals比较内容 如String、包装类与List、Set集合类 使用Object.equals()的类：都比较内存首地址 native方法 允许Java调用外部的本地代码，如Cpp代码。native是一种声明，标记方法的实现在外部定义 实现native方法需要：JNI头文件生成（C/Cpp的头文件）–\u003e本地代码实现–\u003e编译本地代码（动态链接库on Win或共享库 on Linux）–\u003e加载本地库，JVM调用native方法的实现 排序 实现Comparable接口，重写compareTo方法 public class Students implements Comparable\u003cStudent\u003e{ private int id; private int score; // 略 @Override public int compareTo(Student other){ if(this.score!=other.score) return Integer.compare(other.score,this.score); // 降序 else return Integer.compare(this.id,other.id); // 升序 } } 集合 总体概念 数组与集合的区别 数组定长，集合动态长度 数组可以包含基本类型与对象（引用类型），集合仅对象 数组可以直接访问元素，集合需要迭代器等方法访问 哪些集合 List——有序Collection，常用实现类有LinkedList、ArrayList、Vector、Stack ArrayList：线程不安全，底层使用数组（扩容时创建更大数组后复制）。支持快速随机访问元素，插入删除慢 LinkedList：底层双向链表，插入删除快，访问慢 Map——键值对集合，没继承Collection接口。主要实现TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap HashMap 哈希原本的存储结构即数组。解决哈希冲突的方法–\u003e放的地方变多【开放地址（线性探测，向后放一位，注意取模 \u0026 二次探测，向前后走i^2位）、建立溢出区】/算的方法变多（多个哈希函数计算直到不冲突） LinkedHashMap：继承HashMap，在其基础上增加了双向链表，保持插入顺序 HashTable：数组+链表，线程安全–\u003e每个方法加synchronized TreeMap：红黑树 ConcurrentHashMap：数组+链表+红黑树，线程安全 Set——元素不重复、无序，常用实现HashSet、LinkedHashSet、TreeSet HashSet：通过HashMap实现。key存元素，value统一==\u003e不有序\u0026线程不安全（HashMap） LinkedHashSet：HashSet子类，通过LinkedHashMap实现，双向链表维护元素插入顺序 TreeSet：TreeMap实现。添加元素时按比较规则插入到合适的位置，保证集合有序 线程安全的集合？ 线程安全的类： Vector–\u003e内部方法基本都加synchronized HashTable–\u003e每个公共方法加synchronized（仅单线程操作），不支持null键和值==\u003e不建议用 并发Map（java.util.concurrent）： ConcurrentHashMap。JDK1.8取消segment，对每一行加锁 ConcurrentSkipListMap：基于跳表 并发Set（包同上）： ConcurrentSkipListSet：有序集合，底层ConcurrentSkipListMap CopyOnWriteArraySet：无序集合==\u003e线程安全的HashSet 并发List（同上）： CopyOnWriteArrayList：写时复制（写的时候加Lock锁，复制数组，期间其它线程读旧数组，写完指向新数组） 并发Queue： ConcurrentLinkedQueue：适用高并发，使用CAS BlockingQueue：简化数据共享–\u003e读写阻塞等待（没数据了还要读，该线程就一直等待） 并发Deque： LinkedBlockingDeque：每个节点维护前驱和后驱节点，没有读写锁分离，同一时间允许一个线程操作 ConcurrentLinkedDeque： Collections和Collection的区别 Collection是所有集合类的基础接口 Collections是工具类，提供静态方法 遍历集合的方法： for / for-each（增强for循环） Iterator迭代器 / ListIterator列表迭代器（迭代器的子类） forEach：list.forEach(element -\u003e System.out.println(element)); Stream API：list.stream().forEach(element -\u003e System.out.println(element)); 可能产生ConcurrentModificationException的情况 检测到集合内部结构在遍历时被修改，立刻抛出 如：迭代器中（包括Iterator和增强for–\u003e底层为迭代器）调用集合方法remove/set–\u003e应用迭代器的remove/set 建议用线程安全的实现类 List 常见实现与不同 Vector、ArrayList、LinkedList（CopyOnWriteArrayList···） Vector 与 ArrayList 为动态数组，Vector线程安全，都适合随机读取 LinkedList适合增删 删除指定元素的时间复杂度 ArrayList–\u003eO(n)，该元素后面的所有元素都要挪动==\u003e最后一位可以直接删 LinkedList–\u003eO(n)，要顺序定位，首尾不用 CopyOnWriteArrayList–\u003e写时可以读，并发性能好 ArrayList变成线程安全的方法 用Collections类的synchronizedList方法包装ArrayList List\u003cString\u003e sycList=Collections.synchronizedList(list); 用Vector或CopyOnWriteArrayList代替 为什么ArrayList线程不安全 问题：部分值为null \u0026 索引越界 \u0026 size与add数量不符 底层：以add为例 public boolean add(E e){ ensureCapacityIntenal(size+1); // 判断数组大小是否足够，不够就扩容 elementData[size++]=e; // （实际大小已经至少是size+1了）size位赋为e，size+1（仅记录数组长度，与实际长度不同时变） return true; } 分析：线程1发现size为9，容量为10（不用扩），线程2发现size为9，容量为10（不用扩） 1设置index为9的位，2设置index为9的位，1令size++，2令size++==\u003eindex为10的位为null 1设置index为9的位，1令size++，2设置index为10（此时的size）的位==\u003e索引越界 ==\u003esize与add的数量不符 ArrayList的扩容机制 计算新容量==\u003e一般为1.5倍（因为用移位算，速度快，newSize=oldSize+(oldSize\u003e\u003e1)） 创建新数组–\u003e复制元素–\u003e更新引用–\u003e完成扩容 CopyOnWriteArrayList如何保证线程安全 底层是用volatile修饰的数组：private transient volatile Object[] array; 写入时加互斥锁ReentrantLock–\u003e拷贝到长度加1的新数组–\u003e新数组放入新值–\u003e替换引用–\u003efinally释放锁 Map Map遍历方法 entryset： // 也可以用 keySet()，只得到 key 的集 for(Map.Entry\u003cInteger,Integer\u003e entry:map.entrySet()){ int key=entry.getKey(),val=entry.getValue(); } 迭代器–\u003e适合迭代删除 Iterator\u003cEntry\u003cInteger,Integer\u003e\u003e iterator=map.entrySet().iterator(); while(iterator.hasNext()){ Entry\u003cInteger,Integer\u003e entry=iterator.next(); } lambda表达式+forEach方法==\u003emap.forEach((key,value)-\u003ekey=key+1) stream API HashMap底层原理 JDK1.7前为数组+链表（解决hash冲突）–\u003eJDK1.8链表长度超过8且数组长度大于64转用红黑树（n–\u003elog(n)） HashMap线程安全吗 否。问题有：JDK1.7前数组扩容时可能Entry链死循环/数据丢失–\u003eJDK1.8 put时数据覆盖 死循环：头插法，扩容时旧链表节点被逆序转移到新链表（旧链表按顺序读取节点，继续头插法插入新链表）–\u003e当线程B完成复制时，线程A再开始复制 解决方案：(Collections.synchronizedMap同步加锁)/HashTable/ConcurrentHashMap put的过程 计算索引–\u003e检查空否–\u003e（非空）检查key是否相同（hashCode同\u0026\u0026equals）（同则直接更新）–\u003e（不同）链表/红黑树查找，找不到则加入–\u003e检查链表长度–\u003e检查负载因子0.75（键值对数量与数组大小的比值）–\u003e扩容，新建两倍大的数组，重新计算哈希码并插入 HashMap的get方法安全吗 空指针异常，but初始化后可以用null作为键 多线程环境 HashMap一般用什么做key String。不可变，稳定（hashCode与equals方法的正确性） 为什么用红黑树而非平衡二叉树 完全平衡要求任何结点的左右子树的高度差不超 1–\u003e频繁的左右旋 红黑树只要求整个树最长路径不超最短的两倍–\u003e不用频繁调整 重写equals和hashCode的注意事项 同时重写！ \u0026\u0026 o1.equals(o2)==\u003eo1.hashCode() == o2.hashCode()（反之不然） HashMap扩容机制 注意：HashMap初始容量为16 容量一般增为两倍，哈希码与新容量做按位与，若得1则新索引为原索引+原容量（高位赋1，即若新容量为16，则xxx–\u003e1xxx）；若得0则不变 所以不用重新算hash，且可以认为均匀地分散节点（0/1随机） 负载因子 默认0.75，元素个数超过容量的75%就扩容–\u003e太低会有大量空桶（空间浪费），太高会有大量碰撞（性能不好） ConcurrentHashMap怎么实现 JDK1.7.数组+链表。大数组Segment（即可重入锁ReentrantLock），小数组HashEntry存储键值对–\u003e一段数据一个锁，其它段数据可被访问，当前段可被读 JDK1.8.数组+链表/红黑树。（计算哈希值时，通过扰动函数优化哈希分布）volatile+CAS/synchronized–\u003e添加元素时若容器（map）为空则volatile+CAS初始化，若容器不为空但位置（数组中的位置）空用volatile+CAS初始化，若位置不为空（发生了哈希冲突）用synchronized，遍历数据并替换/新增节点到桶并判断是否需转换 对头结点加（悲观）锁保证线程安全（类似一行数据） \u0026 CAS为乐观锁，synchronized为悲观锁–\u003e发生哈希碰撞时证明线程竞争比较激烈，悲观锁效率更高 CAS：比较并交换，比较当前要修改的值与线程的预期值是否相等，是则修改，否则重新读值 Node.val 和 Node.next 声明为 volatile，确保读操作无需加锁 Set Set为什么无重复 根据hashCode确定存储位置，根据equals判断是否有相同元素 有序Set是？记录插入顺序的集合是？ TreeSet（红黑树） \u0026 LinkedHashSet（双向链表）有序 TreeSet需要重写compareTo()函数/Comparator比较器，插入或删除时通过该函数进行比较 记录插入顺序的集合通常指的是LinkedHashSet（放入链表尾） 并发 多线程 Java线程与OS线程一样么 本质上相同，1v1线程模型，Java底层用pthread_create创建线程 使用多线程注意什么 避免数据混乱\n原子性：提供互斥访问，但同一时刻只能有一个线程操作数据–\u003eatomic包 \u0026 synchronized关键字 可见性：对主内存的修改可被其它线程看见–\u003esynchronized关键字 \u0026 volatile关键字 有序性：指令重排序导致线程A观察其它线程的指令执行顺序杂乱无序–\u003ehappens-before原则保证 指令重排序：编译器/CPU/JVM为提高处理速度对指令重排 保证数据一致性的方案 事务管理 锁：共享资源的互斥访问 版本控制：乐观锁，更新时记录版本信息，避免同时修改同一数据 创建线程的方式有哪些 继承Thread类：重写run()方法，用start()启动线程–\u003e可用this访问当前线程 实现Runnable接口：重写run()方法，用new Thread(new 实现类())创建实例–\u003e需用Thread.currentThread()访问当前线程 实现Callable接口：类似👆，但其call()方法可以用返回值且可抛出异常，需将其包装进FutureTask（Thread构造器只接受Runnable参数，FutureTask实现了Runnable） MyCallable callable=new MyCallable(); FutureTask\u003cInteger\u003e futureTask=new FutureTask\u003c\u003e(callable); Thread t=new Thread(futureTask); t.start(); 线程池（Executor框架）：创建–提交任务到线程池–关闭 增加程序复杂度，错误配置可能导致死锁 but 可以重用预先创建的线程，避免线程创建销毁开销，提高程序性能 怎么停止线程运行 异常法：线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态，是中断则抛出异常 沉睡停止：线程sleep，用interrupt标记中断，之后抛出中断异常 stop()：已弃用 return：interrupt标记中断，run判断状态，是中断则return interrupt怎么让线程抛出异常 每个线程都一个与之关联的布尔属性来表示其中断状态，若被其它线程调用interrupt()： 执行低级别可中断方法（如sleep()/Thread.join()/Object.wait()，解除阻塞并抛出异常 else：设置中断状态，之后轮询判断是否停止 Java线程的状态有哪些 可通过getStatus()查看 线程状态 对应 NEW 尚未启动，未调用start RUNNABLE 就绪+正在运行，调用了start等待调度 BLOCKED 等待监视器锁，陷入阻塞 WAITING 等待另一线程执行特定操作，eg.notify() TIMED_WAITING 具有指定等待时间的等待状态 TERMINATED 完成执行，终止 sleep和wait的区别 分类：sleep 是 Thread 类的静态方法；wait 是 Object 类的实例方法（依赖实例） 锁释放：sleep后线程会暂停执行指定的时间，但不会释放持有的对象锁；wait释放锁，进入等待直到其他线程调用相同对象的 notify() 或 notifyAll()唤醒 会释放CPU 使用条件：sleep可在任意位置调用；wait须在同步块/同步方法中调用（需先持有该对象的锁），否则抛IllegalMonitorStateException 唤醒：sleep休眠时间结束自动恢复到就绪状态；wait需notify blocked和waiting有啥区别 触发条件：blocked通常因为试图获得被其它线程持有的锁，被阻塞到锁可用；waiting等待其它线程执行某些操作，不消耗CPU资源，不参与锁竞争 唤醒机制：等锁释放，获得则进入RUNNABLE；显式唤醒 notify 和 notifyAll 的区别 共同点：最多一个线程能获得锁；不能控制谁得到锁 区别： notify唤醒一个线程，其他线程依然处于wait，若该线程结束未唤醒其它线程，则其它线程永远等待 源码标注唤醒任意线程，但依赖于具体jvm实现，hotspot唤醒先进先出 notifyAll所有线程竞争锁，成功的执行，执行后剩下的线程继续竞争 线程间怎么通信 共享数据，volatile关键字等 wait、notify、notifyAll locks包里的Condition接口的await、signal、signalAll，Lock接口提供更灵活的锁（如可重入锁） 通信方式有哪些 Object 类的 wait()、notify() 和 notifyAll() 方法–\u003e基于对象的监视器（锁）机制 Lock 和 Condition 接口 volatile关键字 CountDownLatch，同步工具类，允许线程等待其它线程完成操作后继续执行 CountDownLatch(int count) 指定需要等待的线程数 countDown() 减少计数器的值 await() 当前线程等待到计数器为0–\u003e到0后所有等待的线程被唤醒 CyclicBarrier，同步辅助类，允许一组线程相互等待到所有线程到达某公共屏障点 CyclicBarrier(int parties,Runnable barrierAction)，指定参与线程数量与到达后的操作 await，当前线程等待 Semaphore，计数信号量，控制同时访问特定资源的线程数 acquire、release、构造函数指定初始许可数量 怎么停止线程 通过协作式逻辑控制终止，避免Thread.stop()暴力或Thread.suspend()/resume()易死锁\n共享标志位主动终止：定义可见的状态变量，工作线程循环检测 适用简单无阻塞逻辑，需确保可见性 线程中断机制：Thread.interrupt()设置中断标志位 适用可中断阻塞操作 Future取消任务：使用线程池提交任务，并通过 Future.cancel() 停止线程 适用线程池管理任务 某些 I/O 或同步操作无法通过中断直接响应（Socket.accept()，LOck.lock()），需结合资源关闭操作（调用stop()） 适用不可中断的阻塞操作；注意显式关闭资源触发异常，需结合中断状态判断回滚 并发安全 juc包中常用的类 线程池：ThreadPoolExecutor创建管理线程池（核心、最大线程数、任务队列） \u0026 Executors线程池工厂类 并发集合：ConcurrentHashMap \u0026 CopyOnWriteArrayList 同步工具：CountDownLatch \u0026 CyclicBarrier \u0026 Semaphore 原子类：AtomicInteger硬件级别的原子指令 \u0026 AtomicReference用于对对象引用的原子操作 怎么保证多线程安全 synchronized：同一时刻只有一个线程可以访问该代码（应用：对象锁）==\u003e拿到锁 volatile：用于变量，保证可见性 Lock \u0026 ReentrantLock：更灵活，可重入锁 原子类 线程局部变量：ThreadLocal类位每个线程提供独立的变量副本==\u003e不再竞争 并发集合 JUC工具类 java中有哪些常用的锁 内置锁synchronized：包括无锁、偏向锁、轻量级锁、重量级锁级别 ReentrantLock： 显式锁类，用lock()和unlock()获取和释放锁。提供可中断的锁等待、定时锁、公平锁（按线程请求顺序分配锁）等选项 读写锁ReadWriteLock：允许多个读单个写 乐观锁\u0026悲观锁：悲观（Reentrantlock \u0026 Synchronized），乐观只在更新数据时检查是否已被其它线程修改（版本号/时间戳实现） 自旋锁：等待是循环检查锁是否可用，而非放弃CPU并阻塞 Synchronized底层 适用简单同步情况/代码块同步/对象作为锁\n（基于JVM实现）编译后在同步的代码块前后加monitorenter和monitorexit字节码指令–\u003eenter时尝试获取对象锁，锁的计数器加1；exit时减1；为0时锁释放，等待队列的线程继续竞争锁 排它锁–\u003e线程被阻塞/唤醒会从用户态切换到内核态 内存：加锁的过程会清除工作内存中的共享变量，再从主内存读取；释放时把工作内存中的共享变量写回主内存 reentrantlock底层 高级锁功能/性能优化/复杂同步结构\n基于 AbstractQueuedSynchronizer（AQS）抽象类，通过内部类Sync实现具体锁操作——需手动获取\u0026释放锁 可中断性：线程在等待锁时，可以被其他线程中断而提前结束等待–\u003eLockSupport.park() 和 LockSupport.unpark() 超时时间：一段时间后还未获得锁则放弃–\u003etryAcquireNanos 方法 公平与非公平：默认非公平（同一时刻竞争锁） 公平锁中线程会在运行、休眠中切换（用户态转内核态），相对非公平锁执行速度更慢–\u003e非公平锁，线程会先用CAS尝试，获取失败才进入等待队列 可重入性：同一个线程可以多次获得同一把锁，而不会死锁–\u003e内部holdCount技术实现（为0时其它线程才能获得锁） synchronized支持重入吗 支持。基于原子性的内部锁机制（可重入）–\u003e调用synchronized方法的内部调用该对象的另一个synchronized方法是允许的（重复请求同一个对象的锁） synchronized锁的升级过程 无锁：没开偏向锁的状态（JDK1.6后默认开启，但有JVM启动后的延迟） 偏向锁：当一个线程拿到偏向锁时，下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID作比较==\u003e相同则直接获取 轻量级锁：（主要通过CAS实现）用CAS将该对象的MarkWord拷贝到线程的锁记录Lock Record中，后将MarkWord中（应当）指向锁记录的指针指向线程A的锁空间 重量级锁：（两个以上的线程获取锁）若CAS未成功则始终自旋，消耗CPU–\u003e重量级锁会把线程通过OS调度后挂起（节省CPU资源） JVM对Synchronized的优化 锁膨胀 锁消除：若JVM检测不到某代码被共享/竞争的可能，则消除同步锁 锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁 自适应自旋锁：通过自身循环尝试获取锁，避免线程的挂起\u0026恢复操作–\u003e挂起线程和恢复线程都需要从用户态转入内核态（操作慢） AQS介绍 底层：用一个Volatile的int类型的成员变量来表示同步状态State，通过内置的FIFO队列（双向链表）来完成资源获取的排队，通过CAS完成对State值的修改 获取/释放锁的方法由协作类自己实现，每个实现类都要实现tryAcquire、tryRelease等方法 ThreadLocal作用、原理、… 作用： 线程隔离——每个拥有独立的变量副本 降低耦合度——可以减少参数的传递（同一线程的多个函数间） 性能优势——避免线程间的同步开销 原理：Thread类中的ThreadLocalMap字段（key是ThreadLocal本身，value是ThreadLocal的泛型对象值） 问题：线程结束时，其ThreadLocalMap也会随之销毁，但是ThreadLocal对象本身不会立即被回收–\u003e直到没有其他引用指向它==\u003e若未显式调用remove()方法，可能内存泄漏 实现乐观锁的方式 CAS操作：原子变量类，都使用的CAS 版本号控制：更新时比较版本号 时间戳：更新时比较时间戳 CAS的缺点 ABA问题 可以增加版本号stamp或标记 循环时间长开销大：自旋CAS，给CPU带来大开销 只能保证一个共享变量的原子操作：多个变量可以用AtomicReference或者synchronized volatile关键字有什么用 轻量级的同步机制\n保证变量对所有线程可见 禁止指令重排序优化–\u003e内存屏障实现 写-写屏障：写操作前所有其它写操作都已完成 读-写屏障：读操作后的普通写操作不会重排序到读之前 写-读屏障：写操作后的普通读操作不会重排序到写之前，并强制刷新缓存，保证可见性 指令重排序的原理 为提高性能，进行重排序，但要遵守： 单线程环境下不改变程序运行的结果 存在数据依赖关系的不允许重排序（eg.area=width*height，area赋值不会在宽、高之前） volatile可以保证线程安全吗 否。不保证原子性，如非原子操作i++ 什么情况产生死锁\u0026如何解决 同时满足以下条件发生： 互斥（多个线程不能同时使用同一资源） 持有并等待：线程A持有资源1，等待资源2（被阻塞），但不会释放资源1 不可剥夺：直到使用完资源1前不可释放 环路等待：两线程获取资源的顺序构成环形链 破坏任一，常见方法是用资源有序分配法（以相同顺序申请资源）破坏环路等待 线程池 工作原理 减少频繁的创建、销毁线程带来的性能损耗 线程池的参数有？ corePoolSize（线程池核心线程数量）：默认情况下，线程数量小于等于其时，即使空闲也不会被销毁 可为0 maximumPoolSize：（最多可容纳的线程数量） keepAliveTime：线程池中线程的数量大于corePoolSize，且空闲时间大于此时间，则被销毁 workQueue：工作队列 handler：拒绝策略 拒绝策略有哪些 CallerRunsPolicy：使用线程池的调用者所在的线程去执行被拒绝的任务（除非线程池被停止/任务队列有空缺） AbortPolicy：抛出“任务被线程池拒绝”异常 DiscardPolicy：静默拒绝提交（不处理） DiscardOldestPolicy：抛弃最老的任务，执行当前任务 自定义：实现RejectedExecutionHandler接口 线程池参数设置： 核心线程数：CPU密集型设置为CPU数+1，IO密集型设置为CPU*2 场景： （电商）SynchronousQueue–\u003e不缓存任务，直接扩容线程 \u0026 直接拒绝策略（避免过载） \u0026 最大设置为32（突发流量扩容） （后台）最大禁止扩容 \u0026 不回收线程 \u0026 有界阻塞队列容量1000 \u0026 CallerRunsPolicy （微服务）60s回收 \u0026 有界阻塞队列容量200 \u0026 最大64（应对慢下游） 线程池种类有哪些 ScheduledThreadPool：设置定期的执行任务，支持定时/周期性执行任务 FixedThreadPool：核心线程数和最大线程数一样 CachedThreadPool：可缓存线程池，线程数几乎可以无限增加，闲置时回收 线程池中shutdown()，shutdownNow()这两个方法有什么作用 shutdown()：置状态为SHUTDOWN，正在执行的任务继续执行，没有执行的中断，不能添加任何任务，否则抛出 RejectedExecutionException 异常 shutdownNow()：为STOP，试图停止所有正在执行的线程，不再处理还在池队列中等待的任务。–\u003e调用Thread.interrupt() 方法–\u003e如果线程中没有sleep 、wait、Condition、定时锁等应用，该方法失效 提交的任务可以撤回吗 可。向线程池提交任务时，会得到Future对象，提供方法管理任务执行 cancel(boolean mayInterruptIfRunning)方法，尝试取消执行的任务，mayInterruptIfRunning指示是否允许中断正在执行的任务（true则允许） 场景 单例模型既然已经用了synchronized，为什么还要在加volatile 创建一个既线程安全又能正确初始化的单例模式 通过 synchronized 保证了创建过程的线程安全性，避免创建多个单例对象 volatile确保对象引用的可见性和创建过程的有序性（避免重排序） 虚拟机 内存模型 JVM的内存模型 程序计数器：可以看作当前线程所执行的字节码的行号指示器，存储当前线程正在执行的java方法的JVM指令地址（若执行Native方法则为null）。生命周期与线程相同 虚拟机栈：每个线程有独立的 Java 虚拟机栈，生命周期与线程相同。每个方法执行时创建一个栈帧（存储局部变量表、操作数栈、动态链接、方法出口等信息）–\u003e可能抛 StackOverflowError 和 OutOfMemoryError 异常 本地方法栈：与虚拟机栈类似（hotspot中二者合一），主要为虚拟机使用到的 Native 方法服务。执行时创建栈帧–\u003e可能抛 StackOverflowError 和 OutOfMemoryError 异常 堆：JVM中最大的内存区域，被所有线程共享，JVM启动时创建，存放对象实例–\u003e可能抛 OutOfMemoryError 异常 元空间（jdk1.8后）：jdk1.8后取代方法区，使用本地内存。存储已被JVM加载的类信息、常量、静态变量等–\u003e可能抛 OutOfMemoryError 异常（内存不足时） （运行时常量池）：方法区（元空间）的一部分，存放编译时生成的字面量、符号引用等，有动态性，运行时的新常量也可放入。–\u003e可能抛 OutOfMemoryError 异常 直接内存：不属于JVM运行时数据区的一部分，通过NIO类引入，是堆外内存，可以显著提高I/O性能–\u003e可能抛 OutOfMemoryError 异常 JVM内存模型中堆和栈的区别 用途：栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据 vs 堆用于存储对象的实例（包括类的实例和数组） 生命周期：栈中数据生命周期明确（一个方法调用结束，对应的栈帧即被销毁，其中的局部变量即被移除） vs 生命周期不明确（对象在垃圾回收机制（GC）检测不到引用时被回收） 存取速度：栈通常更快（先进后出，操作简单） vs 对象的分配与回收耗时，GC运行也影响性能 存储空间：栈的空间相对较小，且固定，由操作系统管理，栈溢出通常因为递归过深或局部变量过大 vs 堆的空间较大，动态扩展，由JVM管理，堆溢出通常因为创建了太多大对象或未回收不再使用的对象 可见性：栈中数据对线程私有 vs 队中数据共享 栈中存储对象还是指针 栈中存储基本类型的数据和对象的引用（堆存储对象实例） 堆分为哪几部分 新生代： Eden Space：大多新创建的对象存放此处，满时触发Minor GC（新生代垃圾回收） Survivior Space：S0\u0026S1，每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间以继续其生命周期（轮流充当对象的中转站，区分短暂与长期存活的对象） 老年代：一次或多次Minor GC仍存活的对象被移动到老年代。其中对象生命周期较长，Major GC（Full GC，设计老年代的垃圾回收）发生的频率更低，但执行时间通常更长。老年代空间通常比新生代大 元空间：Java 8开始，永久代（Permanent Generation）被元空间取代，存储类的元数据信息，如类的字段、方法等。使用本地内存，不在堆中 大对象区：某些JVM实现中分配，指需要大量连续内存空间的对象，直接分配在老年代，避免内存碎片化\u0026频繁移动的性能开销 程序计数器的作用\u0026为什么私有 多线程运行，线程切换时可以通过程序计数器定位下一条指令，不同线程执行的代码的指令地址不同，故私有 方法区中方法的执行过程 解析方法调用（若之前未解析过，JVM根据方法符号引用找到实际方法地址） 栈帧创建 执行方法（字节码指令执行） 返回处理：返回结果，清理当前栈帧，恢复调用者的执行环境 方法区中有什么 类信息 常量池：存储类和接口中的常量 静态变量：类初始化时赋值 即时编译器编译后的代码缓存 String s = new String（“abc”）执行过程对应哪些内存区域 new对象==\u003e堆内存存储字符串对象 abc字符串实际被final修饰，一个字符串常量，若字符串常量池中存在，则在堆中创建对象并保存其引用到常量池；不存在则在常量池中创建 引用类型有哪些 强：代码中普遍存在的赋值方式，比如A a = new A()–\u003e强引用关联的对象永远不会被GC回收 软：可以用SoftReference描述，指有用但不必须的对象–\u003e内存溢出时会回收此类引用的对象 弱：WeakReference–\u003e下一次GC时回收，不管内存是否足够 虚：alias幻影引用，PhantomReference，必须和ReferenceQueue一起使用–\u003e发生GC时回收，可以用来管理堆外内存 弱引用的应用 弱引用通过Java.lang.ref.WeakReference类实现，主要用途是创建非强制性的对象引用，内存压力大时被GC清理，避免内存泄漏 应用场景： 缓存系统：希望缓存项能够在内存压力下自动释放 对象池：管理暂时不使用的对象 避免内存泄漏：一个不该被长期引用的对象，可避免意外保留 内存泄漏和内存溢出 泄露：程序在运行过程中不再使用的对象仍然被引用，GC无法回收，可用内存逐渐减少 常见原因：静态集合（HashMap/ArrayList等）存储对象且从未清理；事件监听（未取消对事件源的监听）；线程（未停止的线程可能持有对象引用） 溢出：JVM无法找到足够的内存，引发OutOfMemoryError 常见原因：大量对象创建（超过堆的限制）；持久引用（大型数据结构，如缓存、集合等长时间持有引用）；递归 具体的内存泄漏与溢出的例子\u0026解决方案 静态属性导致内存泄漏：static变量，如果集合/大量对象被指定为static，会在整个生命周期中占用内存 解决：减少静态变量 / 若使用单例，尽量采用懒加载（真正需要时才被创建，类似网站页面的图片） 未关闭资源导致内存溢出：忘记关闭这些资源会阻塞内存，从而GC无法清理 解决：finally关闭 / 关闭连接部分的代码不出异常 / Java7以上版本可使用try-with-resources代码方式 ThreadLocal内存泄漏：ThreadLocalMap使用ThreadLocal的弱引用作为key，若无外部强引用引用它，GC时ThreadLocal一定会被回收==\u003eThreadLocalMap中出现key为null的Entry，则无法访问对应的value–\u003e若线程不结束，value永远无法回收 解决：使用ThreadLocal的remove()方法移除当前线程的value / 不用ThreadLocal.set(null) 的方式清除value（并未清除） / 最好将ThreadLocal视为需要在finally块中关闭的资源 类初始化与类加载 对象的生命周期：创建–\u003e使用–\u003e销毁\n创建对象的过程 类加载检查：JVM遇到new时，检查该指令的参数能否在常量池定位到一个类的符号引用，并检查其代表的类是否已被加载、解析与初始化过，若无则执行类加载过程 分配内存：对象所需的内存大小在类加载完成后确定，JVM只需从 Java 堆中划分一块确定大小的内存 初始化零值：JVM将分配到的内存空间都初始化为零值（不包括对象头） 进行必要设置（如对象头）：如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、是否启用偏向锁等信息 执行init方法：对象需要的其他资源和状态信息还未设置，于是开始执行构造方法等 类加载器有哪些 启动类加载器：最顶层，负责加载Java核心库（如位于jre/lib/rt.jar中的类），cpp编写，属于JVM的一部分。无法被java程序直接引用 扩展类加载器：java实现，继承自ClassLoader类，加载java扩展目录下的jar包与类库（如jre/lib/ext或由系统变量Java.ext.dirs指定的目录），有启动类加载器加载 系统类/应用程序类加载器：java实现，负责加载用户类路径（ClassPath）上的指定类库，默认使用。父加载器是扩展类加载器 自定义类加载器：开发者根据需求定制，java动态性的重要体现 双亲委派模型：收到类加载请求时，类加载器把它委派到父类加载器中（直到顶层的启动类加载器），只有当父类反馈无法完成请求时（它的搜索范围中没有找到所需的类），子加载器才尝试自己加载 双亲委派模型的作用 保证类的唯一性：避免不同类加载器加载相同类的情况 保证安全性：Java核心库被启动类加载器加载，启动类加载器只加载信任的类路径中的类–\u003e防止冒充核心类 支持隔离与层次划分：支持不同层次的类加载器服务于不同的类加载需求，有助于实现沙箱安全机制，保证各层级加载器的职责清晰，便于维护扩展 简化加载流程：减少每个加载类需要处理的类的数量 类加载的过程 加载：通过类的全限定名（包名 + 类名），获取到对应的.class文件的二进制字节流，将字节流代表的静态存储结构转化为方法去运行时的数据结构，在内存中生成代表该类的Java.lang.Class对象，作为方法区该类的访问入口 连接： 验证：确保字节流信息符合JVM要求，保证其不会危害JVM安全（文件格式校验、元数据、字节码、符号引用验证） 准备：为静态字段分配内存并设置初值（final不设置） 解析：将常量池的符号引用（描述目标的一组符号，只要能无歧义定位目标即可）替换为直接引用（指向目标的指针、偏移量等） 初始化：执行（编译器生成的）构造器方法（如静态字段赋值、执行静态初始化块代码），非开发者编写 使用：使用类/创建对象 卸载：该类所有实例被回收 / 加载该类的ClassLoader已被回收 / 类对应的Java.lang.Class对象不再被引用（无法通过反射访问） 时卸载类 垃圾回收 什么是垃圾回收\u0026如何触发 自动管理内存，检测与管理对象，回收不再被引用的对象占用的内存，减少内存泄漏与内存管理错误的可能性\n内存不足：JVM检测到堆内存不足，无法为新对象分配内存时 手动请求：可调用System.gc()或Runtime.getRuntime().gc()回收，不保证立即执行 JVM参数：启动时通过JVM调整，可设定最大堆大小、初始堆大小等 对象数量/内存达到阈值：垃圾回收器内监控 判断垃圾的方法 引用计数法：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1，引用失效时计数器减1。为0时可回收 缺点：循环引用，永不为0 可达性分析（主要采用）：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象与引用对象的引用对象。若不可达某对象，则该对象回收 GC Roots包括：虚拟机栈栈帧中的本地变量表引用的对象、方法去中类静态属性引用的对象、本地方法栈中JNI（Java Native Interface）引用的对象、活跃线程的引用等 垃圾回收算法有哪些 标记-清除：可达性分析标记需回收对象，之后统一回收 缺点：效率低 \u0026 清除结束后会造成大量碎片空间 复制：（解决碎片问题）将内存分为两块，每次申请只使用其中一块，内存不够时将存活的复制到另一块上，再将已使用的内存整个清理掉 缺点：内存利用率太低 标记-整理：标记后将所有存活对象移动到内存一端，之后清理剩余部分 分代回收：分为新生代与老年代，经历一次GC年龄加一，超过（默认15）后进入老年代 垃圾回收器有哪些 使用复制算法 Serial：新生代单线程收集器，标记和清理都是单线程 ParNew：（新生代only）Serial收集器的多线程版本 Parallel Scavenge：（新生代only）追求高吞吐量（用户线程时间/(用户线程时间+GC线程时间)），高效利用 CPU 使用标记整理： Serial Old：老年代单线程收集器，Serial收集器的老年代版本 Parallel Old：Parallel Scavenge收集器的老年代版本 G1（Gabage First）： Java堆并行收集器，回收范围为整个堆 引入分区思路，弱化分代概念 \u0026 合理利用GC各周期的资源 停顿时间可控（可设置预期停顿时间避免雪崩） \u0026 更充分利用硬件优势缩短STW停顿时间（较CMS） 使用标记清除： CMS(Concurrent Mark Sweep) ：老年代并行收集器，追求最短GC回收停顿时间（用户线程停顿的平均时间） 会产生浮动垃圾（并发标记为存活，后来死亡，但是再标记无法知晓），浮动垃圾过多会退化为serial old 垃圾回收算法哪些阶段会stop the world（STW） 以标记-复制算法（应用于CMS新生代ParNew、G1垃圾回收器等）为例，以G1的混合回收的标记-复制为例\n标记： 初始标记：从GC Roots出发标记全部直接子节点–\u003e耗时短，STW 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象（只知存活，不知死亡）–\u003e并发，应用线程与GC线程可以同时活动，非STW 再标记：通过可达性分析重新标记在并发标记阶段发生变化的对象（only将之前不知存活的标记为存活）–\u003eSTW G1会通过SATB来记录开始时的所有存活对象，最终标记阶段会通过SATB与Remembered mark找到并发标记阶段不再被引用的对象，以此避免浮动垃圾；CMS无法找到不再被引用的对象（因此会产生浮动垃圾），只能增加被引用的对象\n清理：清点有存活对象与无存活对象的分区，不清理垃圾对象，也不复制–\u003eSTW 复制：复制算法中的转移阶段需要分配新内存和复制对象的成员变量–\u003eSTW（主要时间瓶颈） minorGC、majorGC、fullGC的区别，什么场景触发full GC Minor GC (Young GC)：只针对年轻代—Eden区空间不足时触发，将Eden与一个Survivor中的存活对象转移到另一个Survivor/老年代—频繁 Major GC (Old GC)：主要针对老年代进行回收，但不一定—老年代空间不足/年轻代晋升到老年代速度过快可能触发—频率相对Minor更低，但时间更长 Full GC：整个堆（年轻代、老年代以及永久代/元空间）回收—直接调用 / Minor GC时存活对象无法全部放入老年代或老年代空间不足 / 永久代（Java8之前）或元空间（之后）空间不足时—STW，遍历整个堆 什么时候用CMS，什么时候用G1 CMS适用：低延迟（停顿时间） / 老年代 / 碎片化管理（容易出现内存碎片，可能需要定期Full GC） G1适用：大堆内存 / 对内存碎片敏感 / 较平衡的性能（停顿时间\u0026吞吐量） GC的只有堆吗 堆和方法区（存储类信息、常量、静态变量等） ","wordCount":"23159","inLanguage":"en","datePublished":"2025-01-11T16:43:40+08:00","dateModified":"2025-04-10T15:47:40+08:00","author":[{"@type":"Person","name":"Satti"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Sattiluvcat.github.io/en/posts/java/%E5%85%AB%E8%82%A1--java/"},"publisher":{"@type":"Organization","name":"Satti's Blog","logo":{"@type":"ImageObject","url":"https://Sattiluvcat.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Sattiluvcat.github.io/en/ accesskey=h title="Satti's Blog (Alt + H)"><img src=https://Sattiluvcat.github.io/img/label1.jpg alt aria-label=logo height=35>Satti's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Sattiluvcat.github.io/en/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://Sattiluvcat.github.io/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://Sattiluvcat.github.io/en/tags title=📑标签><span>📑标签</span></a></li><li><a href=https://Sattiluvcat.github.io/en/lulu/ title=😽Lulu><span>😽Lulu</span></a></li><li><a href=https://Sattiluvcat.github.io/en/archives/ title=📅时间轴><span>📅时间轴</span></a></li><li><a href=https://Sattiluvcat.github.io/en/about/ title=😎关于><span>😎关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Sattiluvcat.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/>文章</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/java/>Java💻</a></div><h1 class="post-title entry-hint-parent">八股——Java</h1><div class=post-meta><span title='2025-01-11 16:43:40 +0800 +0800'>2025-01-11</span>&nbsp;·&nbsp;47 min&nbsp;·&nbsp;<span title='Last updated 2025-04-10 15:47:40 +0800 +0800'>Last updated on 2025-04-10</span>&nbsp;·&nbsp;Satti</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a><ul><li><a href=#%e6%a6%82%e5%bf%b5 aria-label=概念>概念</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=数据类型>数据类型</a></li><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1 aria-label=面向对象>面向对象</a></li><li><a href=#%e6%8b%b7%e8%b4%9d aria-label=拷贝>拷贝</a></li><li><a href=#%e7%89%b9%e6%80%a7 aria-label=特性>特性</a><ul><li><a href=#%e6%b3%9b%e5%9e%8b aria-label=泛型>泛型</a></li><li><a href=#%e5%8f%8d%e5%b0%84 aria-label=反射>反射</a></li><li><a href=#%e6%b3%a8%e8%a7%a3 aria-label=注解>注解</a></li></ul></li><li><a href=#%e5%af%b9%e8%b1%a1 aria-label=对象>对象</a></li><li><a href=#%e5%bc%82%e5%b8%b8 aria-label=异常>异常</a></li><li><a href=#java18%e6%96%b0%e7%89%b9%e6%80%a7stream--completablefuture aria-label="Java1.8新特性——Stream & completableFuture">Java1.8新特性——Stream & completableFuture</a></li><li><a href=#%e5%ba%8f%e5%88%97%e5%8c%96 aria-label=序列化>序列化</a></li><li><a href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=设计模式>设计模式</a></li><li><a href=#io aria-label=I/O>I/O</a></li><li><a href=#%e7%89%b9%e6%ae%8a aria-label=特殊>特殊</a></li></ul></li><li><a href=#%e9%9b%86%e5%90%88 aria-label=集合>集合</a><ul><li><a href=#%e6%80%bb%e4%bd%93%e6%a6%82%e5%bf%b5 aria-label=总体概念>总体概念</a></li><li><a href=#list aria-label=List>List</a></li><li><a href=#map aria-label=Map>Map</a></li><li><a href=#set aria-label=Set>Set</a></li></ul></li><li><a href=#%e5%b9%b6%e5%8f%91 aria-label=并发>并发</a><ul><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=多线程>多线程</a></li><li><a href=#%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8 aria-label=并发安全>并发安全</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0 aria-label=线程池>线程池</a></li><li><a href=#%e5%9c%ba%e6%99%af aria-label=场景>场景</a></li></ul></li><li><a href=#%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label=虚拟机>虚拟机</a><ul><li><a href=#%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b aria-label=内存模型>内存模型</a></li><li><a href=#%e7%b1%bb%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%8e%e7%b1%bb%e5%8a%a0%e8%bd%bd aria-label=类初始化与类加载>类初始化与类加载</a></li><li><a href=#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 aria-label=垃圾回收>垃圾回收</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach(e=>{const n=encodeURI(e.getAttribute("id")).toLowerCase(),t=document.querySelector(`.inner ul li a[href="#${n}"]`);if(e===activeElement){t.classList.add("active");const e=document.querySelector(".toc .inner"),n=t.offsetTop,s=e.clientHeight,o=t.clientHeight,i=n-s/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else t.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p> </p><p> </p><h2 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h2><h3 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h3><ol><li>Java特点：<ul><li>平台无关性——编译器将源代码翻译为字节码，字节码可在任何安装了JVM（java虚拟机）的系统上运行</li><li>面向对象——strictly OOP，易于维护与重用（类、对象、继承、多态、抽象与封装）</li><li>内存管理——有自己的垃圾回收机制，自动管理内存和回收不再使用的对象</li></ul></li><li>为什么Java是跨平台的？<ul><li>Java程序经过<strong>编译</strong>后形成<strong>字节码</strong>（.class）文件，不同平台通过<strong>不同版本的JVM</strong>将字节码文件翻译为<strong>机器码</strong>后运行</li></ul></li><li>JVM/JDK/JRE关系<ul><li>JVM-java虚拟机，将字节码解释/编译为机器码并执行。提供内存管理、垃圾回收、安全性等功能</li><li>JRE-java运行的环境（需要的最小环境），包含JVM与一组Java类库。不包含开发工具</li><li>JDK-java开发工具包，包含JVM、**<em>编译器（javac）、调试器（jdb）</em>**等开发工具与类库。提供开发、编译、调试与运行的全部工具与环境</li></ul></li><li>编译与解释共存？<ul><li>编译型：Java 源代码通过 javac 编译器编译成字节码，而非机器码 &ndash;> 平台无关性</li><li>解释型：JVM 通过解释器将字节码逐行翻译成机器码并执行 &ndash;> 即时编译JIT<ul><li>JIT：将<strong>热点代码</strong>（方法调用计数器计数确定）<strong>直接编译</strong>为机器码，后续执行时无需再次解释</li></ul></li></ul></li><li>编译和解释型的区别？<ul><li>编译型：程序<strong>执行前</strong>，<strong>整个</strong>源代码被编译为机器码/字节码，生成可执行文件 &ndash;> 速度快 but 跨平台性差</li><li>解释型：程序<strong>执行时</strong>，<strong>逐行</strong>解释执行源代码（解释器动态解释），不生成独立的可执行文件 &ndash;> 速度慢 but 可跨平台</li></ul></li></ol><h3 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h3><ol><li>基本数据类型：<ul><li>1字节；byte, boolean | 2字节：short, char | 4字节：int, float | 8字节：double, long</li><li>包装类：Character & Integer & 首字母大写</li><li>char无符号，不可为负，故从0开始</li></ul></li><li>类型转换：<ul><li>隐式转换（自动）</li><li>显式转换（强制）</li><li>字符串转换：如字符串转为 <code>int</code> ，可用 <code>Integer.parseInt()</code></li><li>数值间转换：整型 &lt;==> 字符型，可用包装类的工具方法实现（如<code>Character</code>类、<code>Integer</code>类）</li></ul></li><li>类型转换的问题：<ul><li>数据丢失：范围大类型到范围小类型。如 <code>long</code> 到 <code>int</code>，会截断保留低位</li><li>数据溢出：范围小类型到范围大类型。会填充高位，原数据不变</li><li>精度损失：浮点数类型的转换 &ndash;> 表示方式不同，<code>double</code>（高精度） 转 <code>float</code> 可能损失精度</li><li>类型不匹配</li></ul></li><li>BigDecimal vs double<ul><li>double会精度丢失 &ndash;> 二进制浮点运算，有时不能准确表示小数（如0.1）</li><li>BigDecimal精确计算，注意用字符串创建新对象，不用浮点 &ndash;> <code>BigDecimal num1 = new BigDecimal("0.1");</code></li></ul></li><li>装箱、拆箱<ul><li>自动装箱happens when：<ul><li>赋值（Java1.5后自动）：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// before Java1.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Integer</span><span class=w> </span><span class=n>iObject</span><span class=o>=</span><span class=n>Integer</span><span class=p>.</span><span class=na>valueof</span><span class=p>(</span><span class=n>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=o>=</span><span class=n>iObject</span><span class=p>.</span><span class=na>intValue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// after Java1.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Integer</span><span class=w> </span><span class=n>iObject</span><span class=o>=</span><span class=n>3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=o>=</span><span class=n>iObject</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ul><li>方法调用：实质也是赋值，将int与Integer颠倒使用</li></ul></li><li>自动装箱弊端：循环中自动装箱（颠倒使用时），会创建大量无用对象 & 垃圾回收工作量大</li></ul></li><li>Why Java has Integer?<ul><li>前提：Integer是int类型的包装类，把int类型包装成Object<strong>对象</strong>，即对象封装</li><li>作用：<ul><li>泛型：Java中，<strong>泛型只能使用引用类型</strong>，而不能使用基本类型。如列表只能用<code>List&lt;Integer></code><ul><li>泛型允许在定义类、接口或方法时使用类型参数（如<code>Box&lt;T></code>），使用时再指定具体类型</li></ul></li><li><strong><em>转换</em></strong>：Java中，基本类型和引用类型不能直接进行转换，必用包装类。如int转String（转为<code>Integer</code>后<code>.toString()</code>）</li><li>集合：Java集合只能存储对象</li></ul></li></ul></li><li>Integer相比int优点（区别）？<ul><li>基本类型 vs 引用类型：基本类型不需实例化即可使用 ==> int存储一个整数不需额外的内存分配（性能更快），Integer要为对象分配内存<ul><li>引用类型，对象的引用和对象本身分开存储；基本类型，变量对应的内存块存储数据自身</li><li>So：基本类型读写效率、内存效率更高</li></ul></li><li>自动拆装箱</li><li><strong><em>空指针异常</em></strong>：Integer变量必须通过<strong>实例化</strong>对象来赋值，若其未经初始化会出现空指针异常（int默认赋0）</li></ul></li><li>Integer的缓存<ul><li>实现静态缓存池（默认存储-128~127），通过Integer.valueOf(int)方法创建该范围内的对象时，会复用缓存中的现有对象（from内存）</li></ul></li></ol><h3 id=面向对象>面向对象<a hidden class=anchor aria-hidden=true href=#面向对象>#</a></h3><ol><li>面向对象是什么？与特性<ul><li>OOP：编程范式，将现实世界中的事物抽象为对象，对象具有字段（属性）与方法（行为）。具有灵活性与可拓展性</li><li>特性：<ul><li>封装：将对象的属性（数据）和行为（方法）结合，仅用接口与外界交互。&ndash;>增强安全性和简化编程，使对象更独立</li><li>继承：使子类可自动共享父类数据结构和方法，代码复用。&ndash;>建立类与类间的层次关系，结构更清晰</li><li>多态：允许不同类的对象对同一消息作出响应，即同一个接口，使用不同实例而执行不同操作。编译时多态（重载）和运行时多态（重写）&ndash;>灵活性与拓展性</li></ul></li></ul></li><li>多态体现？<ul><li>方法重载：同一类中可以有多个同名方法，但<strong>参数列表不同</strong>。<strong>编译器</strong>确定调用哪个方法</li><li>方法重写：子类能够提供对父类中同名方法的具体实现（不同子类可以实现不同，但<strong>参数不变</strong>）。<strong>JVM</strong>在运行时根据对象实际类型确定调用哪个方法</li><li>接口与实现：多个类可以实现同一个接口，并用接口类型的引用来调用这些类的方法<ul><li>如<code>Dog</code>是<code>Animal</code>的实现类，创建实例时用：<code>Animal dog=new Dog();</code>（<code>dog</code>是<code>Dog</code>类的实例，<code>Animal</code>是<code>dog</code>的接口类型）</li></ul></li><li>向上/下转型：子类父类共有方法可用向上转型调用，子类特有方法需要父类对象向下转型后调用<ul><li>（向上转型）子类对象转换为父类对象，自动进行（如<code>Animal dog=new Dog();</code>）</li><li>（向下转型）父类对象转换为子类对象，执行前需确认引用实际指向的对象，避免<code>ClassCastException</code></li></ul></li></ul></li><li>多态作用<ul><li>meaning：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。需要继承、接口类等语法机制</li><li>作用：提高代码的扩展性和复用性。</li></ul></li><li>OOP的设计原则<ul><li>单一职责原则SRP：一个类应该只负责一项职责</li><li>开放封闭原则OCP：软件实体应该对扩展（entends，子类）开放，对修改封闭。（即可以继承这个类，但不能修改类本身）</li><li>里氏替换原则LSP：子类对象应该能够替换掉所有父类对象。（不改变父类预期行为等）</li><li>接口隔离原则ISP：客户端不应该依赖那些它不需要的接口</li><li>依赖倒置原则DIP：高层模块不应该依赖低层模块，二者都应该依赖于抽象</li><li>最少知识原则：一个对象应当对其他对象有最少的了解</li></ul></li><li>抽象类与普通类区别<ul><li>实例化：抽象类不能被实例化，只能被继承</li><li>方法实现：抽象类中的方法可以有实现也可以没有实现</li><li>继承：一个类只能继承一个类（any），但可继承（普通类）/实现（抽象类）多个<strong>接口</strong></li><li>限制：普通类可以被其他类继承&使用，抽象类一般用作基类</li></ul></li><li>抽象类 vs 接口<ul><li>二者特点：<ul><li>抽象类：可以有成员变量、构造方法和具体方法&ndash;>适用继承关系</li><li>接口：可以多实现，只能有<strong>常量和抽象方法</strong>（无构造方法）（Java8后可以有默认方法与静态方法&ndash;>定义行为规范与类的功能</li></ul></li><li>区别：<ul><li>实现：接口用<code>implements</code>，抽象类用<code>extends</code>，一个类多接口单抽象类</li><li>方法：接口<strong>不能有方法的实现</strong>，java8中可定义default方法体。抽象类无限制</li><li>访问修饰符：<ul><li>接口成员变量默认<strong>public static final</strong>，必须赋初值不能被修改（final特性），所有成员方法都是<strong>public、abstract</strong>的</li><li>抽象类中成员变量默认<strong>default</strong>，可被子类重新定义or赋值，抽象方法被abstract修饰，<strong>不能被private、static、synchronized和native等修饰</strong>，<strong>必须以分号结尾</strong>，不带花括号</li></ul></li><li>变量：接口只能包含（静态）常量；抽象类可包含实例变量与静态常量</li></ul></li></ul></li><li>抽象类可加final吗？<ul><li>no。抽象类是被继承的，final禁止类的继承 or 方法重写</li></ul></li><li>接口可以定义什么方法？<ul><li>抽象方法：核心，所有实现接口的类必须实现这些方法</li><li>默认方法：允许接口<strong>提供具体实现</strong>。实现类<strong>可以重写</strong>默认方法</li><li>静态方法：属于接口本身，可以<strong>通过接口名直接调用</strong>，不需实现类的对象</li><li>私有方法：Java9引入。为默认/私有方法提供辅助功能</li></ul></li><li>抽象类可以被实例化吗？<ul><li>自身不能被实例化&ndash;>不能直接new一个对象。但可以有构造器，创建子类实例时间接使用（不需指定<code>super</code>，先调用父类构造器，后调用子类构造器）</li></ul></li><li>静态变量与静态方法<ul><li>静态变量：属于类而非具体的对象<ul><li>共享性：<strong>所有该类的实例共享</strong>同一个静态变量。一个实例修改，其它实例均知晓</li><li>初始化：在<strong>类被加载时初始化</strong>，只分配一次内存</li><li>访问方式：可以直接通过类名访问，也可以通过实例访问（建议类名）</li></ul></li><li>静态方法：<ul><li>无实例依赖：可在没有创建类实例的情况下调用，<strong>不能直接访问非静态</strong>的成员变量 or 方法（因为无上下文的实例）</li><li>直接访问静态成员</li><li>多态性：<strong>不支持重写</strong>，可以被<code>Hide</code></li></ul></li><li>使用场景：<ul><li>静态变量：需要在所有对象间共享的数据，如计数器、常量等</li><li>静态方法：常用于助手方法（utility methods）获取类级别的信息或者是没有依赖于实例的数据处理</li></ul></li></ul></li><li>非静态内部类与静态内部类区别（以下只列出非静态特点）<ul><li>外部类实例的依赖</li><li>访问外部类的变量、方法</li><li>不能定义静态成员</li><li>不能独立实例化</li><li>可以访问外部类的私有成员</li></ul></li><li>非静态内部类怎么直接访问外部方法<ul><li>编译器在生成字节码时会为非静态内部类维护一个指向<strong>外部类实例</strong>的引用。生成非静态内部类的构造方法时，将外部类实例作为参数传入</li></ul></li><li>父类、子类的静态方法，在new子类对象时的加载顺序<ul><li>父类静态&ndash;>子类静态&ndash;>父类构造器&ndash;>子类构造器</li></ul></li></ol><h3 id=拷贝>拷贝<a hidden class=anchor aria-hidden=true href=#拷贝>#</a></h3><ol><li>深浅拷贝：<ul><li>浅拷贝：只复制对象本身和其内部的值类型字段，不复制对象内部的引用类型字段&ndash;>共享引用</li><li>深拷贝：将对象内部的所有引用类型字段的内容也复制（完全独立）</li></ul></li><li>实现深拷贝的方法：<ul><li>实现 Cloneable 接口并重写 clone() 方法：要求对象及其所有引用类型字段都实现接口并重写方法（clone()通过<strong>递归克隆</strong>实现深拷贝）</li><li>序列化与反序列化：对象序列化为字节流，再从字节流反序列化为对象&ndash;>要求对象与引用类型都实现 Serializable 接口</li><li>手动递归复制：对象及引用类型字段<ul><li>如List里<code>new AyyayList&lt;>(list)</code></li></ul></li></ul></li></ol><h3 id=特性>特性<a hidden class=anchor aria-hidden=true href=#特性>#</a></h3><h4 id=泛型>泛型<a hidden class=anchor aria-hidden=true href=#泛型>#</a></h4><ol><li>什么是泛型<ul><li>允许类、接口和方法在定义时使用一个或多个类型参数，使用时类型参数可以被指定为具体的类型</li></ul></li><li>why need 泛型<ul><li>适用于多种数据类型执行相同的代码&ndash;>代码复用</li><li>泛型中的类型在使用时指定，不需要强制类型转换（如：不指定时，取出时需转换）&ndash;>保证类型安全，编译器来检查</li></ul></li></ol><h4 id=反射>反射<a hidden class=anchor aria-hidden=true href=#反射>#</a></h4><blockquote><p>需要开发者调用某些方法实现，Spring底层大量使用反射（有涉及反射的相关代码）</p></blockquote><ol><li>什么是反射<ul><li><strong>运行</strong>时，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。动态获取的信息以及动态调用对象的方法的功能==>反射机制</li></ul></li><li>特性<ul><li>运行时类信息访问——完整信息，父类、接口、包名、构造函数、方法、字段</li><li>动态对象创建——反射API动态地创建对象实例，即使在编译时不知道具体的类名（newInstance()）</li><li>动态方法调用——运行时动态地调用对象的方法，包括私有方法（<code>Method</code>类地<code>invoke()</code>方法）</li><li>访问与修改字段值——允许程序在运行时访问和修改对象的字段值，即使是私有的（<code>Field</code>类的<code>get()/set()</code>方法）</li></ul></li><li>应用场景<ul><li>加载数据库驱动</li><li>配置文件加载——IOC加载Bean<ul><li>将所有XML或properties配置文件夹载入内存&ndash;>解析其内容，得到对应实体类的 <em>字节码字符串</em> 等&ndash;>利用反射，根据字符串得到类的实例&ndash;>动态配置实例属性</li></ul></li></ul></li></ol><h4 id=注解>注解<a hidden class=anchor aria-hidden=true href=#注解>#</a></h4><ol><li>注解原理<ul><li>本质是一个继承了Annotation接口的<strong>接口</strong>，实现类是Java运行时生成的动态代理类（用这个类存储注解中的属性等，调用注解方法时，代理类返回存储的值）</li></ul></li><li>注解作用域Scope<ul><li>类级别、方法级别、字段级别、（构造函数作用域、局部变量作用域）</li><li>可以指定属性，如访问级别、注释等</li></ul></li></ol><h3 id=对象>对象<a hidden class=anchor aria-hidden=true href=#对象>#</a></h3><ol><li>创建对象的方式<ul><li>new</li><li><code>Class</code>或<code>Constructor</code>类的<code>newInstance()</code>方法（即反射机制）</li><li><code>clone()</code> & 反序列化（即深拷贝）<ul><li><code>clone()</code>要实现<code>Cloneable</code>接口，反序列化（类）要实现<code>Serializable</code>接口</li></ul></li></ul></li><li>new的对象什么时候回收<ul><li>垃圾回收器回收，回收时机取决于：<ul><li>引用计数法：某对象的引用计数为0时==>不再被引用</li><li>可达性分析算法：从根对象出发，通过对象的引用链遍历，拖不存在到达某对象的引用链&ndash;>回收</li><li>终结器：重写<code>finalize()</code>方法的对象，回收对象前会调用该方法</li></ul></li></ul></li></ol><h3 id=异常>异常<a hidden class=anchor aria-hidden=true href=#异常>#</a></h3><ol><li>哪些异常<ul><li>基于Throwable及其子类，子类包括<code>Error</code>与<code>Exception</code></li><li>Error：表示运行时环境的错误，程序无法处理。如<code>StackOverFlowError</code></li><li>Exception：<ul><li>非运行时异常：必须编译时捕获或抛出，一般为外部错误。如<code>FileNotFoundException</code>，除RuntimeException及其子类的异常<ul><li>受编译器检查（code时就检查）</li></ul></li><li>运行时异常：程序错误导致。如<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundException</code><ul><li>不受编译器检查（运行时才能发现）</li></ul></li></ul></li></ul></li><li>异常处理<ul><li>try-catch-finally：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=k>try</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception1</span><span class=w> </span><span class=n>e1</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 处理第一类异常的逻辑，比如👇</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Exception1</span><span class=p>(</span><span class=s>&#34;Exception Happend!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception2</span><span class=w> </span><span class=n>e2</span><span class=p>){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 可选，定义无论有否异常都要执行的代码块</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 一般用于资源释放</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>throws：方法中声明可能抛出的异常类型，将异常传递给调用者处理</li></ul></li><li>try与finally，return哪一个<ul><li>返回finally中的return值&ndash;>try中的返回值暂存，执行finally，最终try的结果被覆盖</li></ul></li></ol><h3 id=java18新特性stream--completablefuture>Java1.8新特性——Stream & completableFuture<a hidden class=anchor aria-hidden=true href=#java18新特性stream--completablefuture>#</a></h3><ol><li>Java的stream API<ul><li>提供高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。</li><li>提高代码的可读性和简洁性，还能利用多核处理器的优势进行<strong>并行</strong>处理</li></ul></li><li>stream API案例<ul><li>过滤</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>ans</span><span class=o>=</span><span class=n>list</span><span class=p>.</span><span class=na>stream</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                     </span><span class=p>.</span><span class=na>filter</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>length</span><span class=p>()</span><span class=o>&gt;</span><span class=n>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                     </span><span class=p>.</span><span class=na>collect</span><span class=p>(</span><span class=n>Collectors</span><span class=p>.</span><span class=na>toList</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></div><ul><li>求和</li></ul></li><li>stream流的并行API是什么<ul><li>ParallelStream。将源数据fork为多个子流进行多线程操作，处理结果join为一个流对象&ndash;>底层为通用的fork/join池</li></ul></li></ol><h3 id=序列化>序列化<a hidden class=anchor aria-hidden=true href=#序列化>#</a></h3><ol><li>怎么把一个对象从一个jvm转移到其它jvm<ul><li>序列化与反序列化：字节流</li><li>消息传递机制：消息队列/网络套接字通信，需自定协议来序列化对象</li><li>远程方法调用（RPC）</li><li>共享数据库或缓存</li></ul></li><li>Java默认序列化的缺点<blockquote><p>主流序列化框架：Protobuf、FastJson</p></blockquote><ul><li>无法跨语言：序列化框架与协议其他语言没有实现</li><li>易被攻击：反序列化通过<code>ObjectInputStream</code>上调用<code>readObject()</code>进行，可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化&ndash;>可执行任意类型的代码</li><li>序列化后流太大：二进制数组越大，占用空间越多</li></ul></li><li>具体怎么转对象为二进制字节流<ul><li>序列化用<code>ObjectOutPutStream</code>的<code>writeObject</code>，获取输出流，可写入二进制文件中，创建输入流并读取对象进行反序列化</li><li>需要确保类实现了Serializable接口，并且所有成员变量都是Serializable的（原生类型如int自动支持，其它引用类型需要实现该接口）</li></ul></li></ol><h3 id=设计模式>设计模式<a hidden class=anchor aria-hidden=true href=#设计模式>#</a></h3><ol><li>代理模式和适配器模式的区别<ul><li>目的：代理模式关注控制对对象的访问，适配器用于接口转换，使不兼容的类能一起工作</li><li>结构：代理一般包含抽象主题、真是主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色</li><li>应用场景：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作</li></ul></li></ol><h3 id=io>I/O<a hidden class=anchor aria-hidden=true href=#io>#</a></h3><ol><li>Java怎么实现网络IO高并发编程<ul><li>Java NIO&ndash;>同步非阻塞IO模型，基于IO多路复用实现</li></ul></li><li>NIO、BIO、AIO<ul><li>BIO：blocking IO，基于流模型，同步阻塞交互&ndash;>一个线程处理一个IO</li><li>NIO：non-blocking IO，Java1.4引入，多路复用，同步非阻塞</li><li>AIO：asynchronous IO，Java1.7引入，异步非阻塞</li></ul></li><li>NIO实现<blockquote><p>用到NIO的框架&ndash;>Netty</p></blockquote><ul><li>同步核心为Selector，代替线程本身的轮询IO事件</li></ul></li></ol><h3 id=特殊>特殊<a hidden class=anchor aria-hidden=true href=#特殊>#</a></h3><ol><li>==与equals的区别<ul><li>重写了<code>equals</code>的类：<code>==</code>比较内存的首地址（即是否指向同个对象），<code>equals</code>比较内容<ul><li>如<strong>String、包装类与List、Set集合</strong>类</li></ul></li><li>使用<code>Object.equals()</code>的类：都比较内存首地址</li></ul></li><li>native方法<ul><li>允许Java调用外部的本地代码，如Cpp代码。native是一种声明，标记方法的实现在外部定义</li><li>实现native方法需要：JNI头文件生成（C/Cpp的头文件）&ndash;>本地代码实现&ndash;>编译本地代码（动态链接库on Win或共享库 on Linux）&ndash;>加载本地库，JVM调用native方法的实现</li></ul></li><li>排序<ul><li>实现<code>Comparable</code>接口，重写<code>compareTo</code>方法</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Students</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Comparable</span><span class=o>&lt;</span><span class=n>Student</span><span class=o>&gt;</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>score</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 略</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>compareTo</span><span class=p>(</span><span class=n>Student</span><span class=w> </span><span class=n>other</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>score</span><span class=o>!=</span><span class=n>other</span><span class=p>.</span><span class=na>score</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>compare</span><span class=p>(</span><span class=n>other</span><span class=p>.</span><span class=na>score</span><span class=p>,</span><span class=k>this</span><span class=p>.</span><span class=na>score</span><span class=p>);</span><span class=w>   </span><span class=c1>// 降序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>else</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>compare</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>id</span><span class=p>,</span><span class=n>other</span><span class=p>.</span><span class=na>id</span><span class=p>);</span><span class=w>  </span><span class=c1>// 升序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ol><h2 id=集合>集合<a hidden class=anchor aria-hidden=true href=#集合>#</a></h2><h3 id=总体概念>总体概念<a hidden class=anchor aria-hidden=true href=#总体概念>#</a></h3><ol><li>数组与集合的区别<ul><li>数组定长，集合动态长度</li><li>数组可以包含基本类型与对象（引用类型），集合仅对象</li><li>数组可以直接访问元素，集合需要迭代器等方法访问</li></ul></li><li>哪些集合<ul><li><strong>List</strong>——有序Collection，常用实现类有LinkedList、ArrayList、Vector、Stack</li><li>ArrayList：<strong>线程不安全</strong>，底层使用<strong>数组</strong>（扩容时创建更大数组后复制）。支持快速随机访问元素，插入删除慢</li><li>LinkedList：底层<strong>双向链表</strong>，插入删除快，访问慢</li><li><strong>Map</strong>——键值对集合，没继承Collection接口。主要实现TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap<ul><li>HashMap<ul><li>哈希原本的存储结构即数组。<strong>解决哈希冲突的方法</strong>&ndash;><strong>放的地方变多</strong>【开放地址（线性探测，向后放一位，注意取模 & 二次探测，向前后走i^2位）、建立溢出区】/<strong>算的方法变多</strong>（多个哈希函数计算直到不冲突）</li></ul></li><li>LinkedHashMap：继承HashMap，在其基础上增加了双向链表，保持插入顺序</li><li>HashTable：数组+链表，线程安全&ndash;>每个方法加<code>synchronized</code></li><li>TreeMap：红黑树</li><li>ConcurrentHashMap：数组+链表+红黑树，线程安全</li></ul></li><li><strong>Set</strong>——元素不重复、无序，常用实现HashSet、LinkedHashSet、TreeSet</li><li>HashSet：通过HashMap实现。key存元素，value统一==>不有序&线程不安全（HashMap）</li><li>LinkedHashSet：HashSet子类，通过LinkedHashMap实现，<strong>双向链表</strong>维护元素插入顺序</li><li>TreeSet：TreeMap实现。添加元素时按比较规则插入到合适的位置，保证集合有序</li></ul></li><li>线程安全的集合？<ul><li>线程安全的类：<ul><li>Vector&ndash;>内部方法基本都加<code>synchronized</code></li><li>HashTable&ndash;>每个公共方法加<code>synchronized</code>（仅单线程操作），不支持null键和值==>不建议用</li></ul></li><li><strong>并发Map</strong>（<code>java.util.concurrent</code>）：<ul><li>ConcurrentHashMap。JDK1.8取消segment，对每一行加锁</li><li>ConcurrentSkipListMap：基于跳表</li></ul></li><li><strong>并发Set</strong>（包同上）：<ul><li>ConcurrentSkipListSet：有序集合，底层ConcurrentSkipListMap</li><li>CopyOnWriteArraySet：无序集合==>线程安全的HashSet</li></ul></li><li><strong>并发List</strong>（同上）：<ul><li>CopyOnWriteArrayList：写时复制（写的时候加Lock锁，复制数组，期间其它线程读旧数组，写完指向新数组）</li></ul></li><li><strong>并发Queue</strong>：<ul><li>ConcurrentLinkedQueue：适用高并发，使用CAS</li><li>BlockingQueue：简化数据共享&ndash;>读写阻塞等待（没数据了还要读，该线程就一直等待）</li></ul></li><li><strong>并发Deque</strong>：<ul><li>LinkedBlockingDeque：每个节点维护前驱和后驱节点，没有读写锁分离，同一时间允许一个线程操作</li><li>ConcurrentLinkedDeque：</li></ul></li></ul></li><li>Collections和Collection的区别<ul><li>Collection是所有集合类的基础接口</li><li>Collections是工具类，提供静态方法</li></ul></li><li>遍历集合的方法：<ul><li>for / for-each（增强for循环）</li><li>Iterator迭代器 / ListIterator列表迭代器（迭代器的子类）</li><li>forEach：<code>list.forEach(element -> System.out.println(element));</code></li><li>Stream API：<code>list.stream().forEach(element -> System.out.println(element));</code></li></ul></li><li>可能产生<code>ConcurrentModificationException</code>的情况<ul><li>检测到集合内部结构在遍历时被修改，立刻抛出</li><li>如：迭代器中（包括<code>Iterator</code>和增强for&ndash;>底层为迭代器）调用集合方法<code>remove</code>/<code>set</code>&ndash;>应用迭代器的<code>remove</code>/<code>set</code></li><li>建议用线程安全的实现类</li></ul></li></ol><h3 id=list>List<a hidden class=anchor aria-hidden=true href=#list>#</a></h3><ol><li>常见实现与不同<ul><li>Vector、ArrayList、LinkedList（CopyOnWriteArrayList···）</li><li>Vector 与 ArrayList 为动态数组，Vector线程安全，都适合随机读取</li><li>LinkedList适合增删</li></ul></li><li>删除指定元素的时间复杂度<ul><li>ArrayList&ndash;>O(n)，该元素后面的所有元素都要挪动==>最后一位可以直接删</li><li>LinkedList&ndash;>O(n)，要顺序定位，首尾不用</li><li>CopyOnWriteArrayList&ndash;>写时可以读，并发性能好</li></ul></li><li>ArrayList变成线程安全的方法<ul><li>用Collections类的synchronizedList方法包装ArrayList</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>sycList</span><span class=o>=</span><span class=n>Collections</span><span class=p>.</span><span class=na>synchronizedList</span><span class=p>(</span><span class=n>list</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ul><li>用Vector或CopyOnWriteArrayList代替</li></ul></li><li>为什么ArrayList线程不安全<ul><li>问题：部分值为null & 索引越界 & size与add数量不符</li><li>底层：以add为例</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>add</span><span class=p>(</span><span class=n>E</span><span class=w> </span><span class=n>e</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>ensureCapacityIntenal</span><span class=p>(</span><span class=n>size</span><span class=o>+</span><span class=n>1</span><span class=p>);</span><span class=w>   </span><span class=c1>// 判断数组大小是否足够，不够就扩容</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>elementData</span><span class=o>[</span><span class=n>size</span><span class=o>++]=</span><span class=n>e</span><span class=p>;</span><span class=w>  </span><span class=c1>// （实际大小已经至少是size+1了）size位赋为e，size+1（仅记录数组长度，与实际长度不同时变）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>分析：线程1发现size为9，容量为10（不用扩），线程2发现size为9，容量为10（不用扩）<ul><li>1设置index为9的位，2设置index为9的位，1令size++，2令size++==>index为10的位为null</li><li>1设置index为9的位，1令size++，2设置index为10（此时的size）的位==>索引越界</li><li>==>size与add的数量不符</li></ul></li></ul></li><li>ArrayList的扩容机制<ul><li>计算新容量==>一般为1.5倍（因为用移位算，速度快，<code>newSize=oldSize+(oldSize>>1)</code>）</li><li>创建新数组&ndash;>复制元素&ndash;>更新引用&ndash;>完成扩容</li></ul></li><li>CopyOnWriteArrayList如何保证线程安全<ul><li>底层是用volatile修饰的数组：<code>private transient volatile Object[] array;</code></li><li>写入时加互斥锁ReentrantLock&ndash;>拷贝到长度加1的新数组&ndash;>新数组放入新值&ndash;>替换引用&ndash;><code>finally</code>释放锁</li></ul></li></ol><h3 id=map>Map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3><ol><li>Map遍历方法<ul><li>entryset：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 也可以用 keySet()，只得到 key 的集</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=p>(</span><span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>entry</span><span class=p>:</span><span class=n>map</span><span class=p>.</span><span class=na>entrySet</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>key</span><span class=o>=</span><span class=n>entry</span><span class=p>.</span><span class=na>getKey</span><span class=p>(),</span><span class=n>val</span><span class=o>=</span><span class=n>entry</span><span class=p>.</span><span class=na>getValue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>迭代器&ndash;>适合迭代删除</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>Iterator</span><span class=o>&lt;</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=n>Integer</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>iterator</span><span class=o>=</span><span class=n>map</span><span class=p>.</span><span class=na>entrySet</span><span class=p>().</span><span class=na>iterator</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=na>hasNext</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>entry</span><span class=o>=</span><span class=n>iterator</span><span class=p>.</span><span class=na>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>lambda表达式+forEach方法==><code>map.forEach((key,value)->key=key+1)</code></li><li>stream API</li></ul></li><li>HashMap底层原理<ul><li>JDK1.7前为数组+链表（解决hash冲突）&ndash;>JDK1.8链表长度超过8且数组长度大于64转用红黑树（n&ndash;>log(n)）</li></ul></li><li>HashMap线程安全吗<ul><li>否。问题有：JDK1.7前数组扩容时可能Entry链死循环/数据丢失&ndash;>JDK1.8 put时数据覆盖<ul><li>死循环：<strong>头插法</strong>，扩容时旧链表节点被<strong>逆序</strong>转移到新链表（旧链表按顺序读取节点，继续头插法插入新链表）&ndash;>当线程B完成复制时，线程A再开始复制</li></ul></li><li>解决方案：(Collections.synchronizedMap同步加锁)/HashTable/ConcurrentHashMap</li></ul></li><li>put的过程<ul><li>计算索引&ndash;>检查空否&ndash;>（非空）检查key是否相同（<code>hashCode</code>同&&<code>equals</code>）（同则直接更新）&ndash;>（不同）链表/红黑树查找，找不到则加入&ndash;>检查链表长度&ndash;>检查负载因子0.75（键值对数量与数组大小的比值）&ndash;>扩容，新建两倍大的数组，重新计算哈希码并插入</li></ul></li><li>HashMap的get方法安全吗<ul><li>空指针异常，but初始化后可以用<code>null</code>作为键</li><li>多线程环境</li></ul></li><li>HashMap一般用什么做key<ul><li>String。不可变，稳定（hashCode与equals方法的正确性）</li></ul></li><li>为什么用红黑树而非平衡二叉树<ul><li>完全平衡要求任何结点的左右子树的高度差不超 1&ndash;>频繁的左右旋</li><li>红黑树只要求整个树最长路径不超最短的两倍&ndash;>不用频繁调整</li></ul></li><li>重写equals和hashCode的注意事项<ul><li><strong>同时重写！</strong> && o1.equals(o2)==>o1.hashCode() == o2.hashCode()（反之不然）</li></ul></li><li>HashMap扩容机制<ul><li>注意：HashMap初始容量为16</li><li>容量一般增为两倍，哈希码与新容量做按位与，若得1则新索引为原索引+原容量（高位赋1，即若新容量为16，则xxx&ndash;>1xxx）；若得0则不变</li><li>所以不用重新算hash，且可以认为均匀地分散节点（0/1随机）</li></ul></li><li>负载因子</li></ol><ul><li>默认0.75，元素个数超过容量的75%就扩容&ndash;>太低会有大量空桶（空间浪费），太高会有大量碰撞（性能不好）</li></ul><ol start=11><li>ConcurrentHashMap怎么实现</li></ol><ul><li>JDK1.7.数组+链表。大数组Segment（即可重入锁<code>ReentrantLock</code>），小数组HashEntry存储键值对&ndash;>一段数据一个锁，其它段数据可被访问，当前段可被读</li><li>JDK1.8.数组+链表/红黑树。（计算哈希值时，通过扰动函数优化哈希分布）volatile+CAS/synchronized&ndash;>添加元素时若容器（map）为空则volatile+CAS初始化，若容器不为空但位置（数组中的位置）空用volatile+CAS初始化，若位置不为空（发生了哈希冲突）用synchronized，遍历数据并替换/新增节点到桶并判断是否需转换<ul><li>对<strong>头结点加（悲观）锁</strong>保证线程安全（类似一行数据） & <strong>CAS为乐观锁，synchronized为悲观锁</strong>&ndash;>发生哈希碰撞时证明线程竞争比较激烈，悲观锁效率更高</li><li>CAS：比较并交换，比较当前要修改的值与线程的预期值是否相等，是则修改，否则重新读值</li><li>Node.val 和 Node.next 声明为 volatile，确保读操作无需加锁</li></ul></li></ul><h3 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h3><ol><li>Set为什么无重复<ul><li>根据hashCode确定存储位置，根据equals判断是否有相同元素</li></ul></li><li>有序Set是？记录插入顺序的集合是？<ul><li>TreeSet（红黑树） & LinkedHashSet（<strong>双向</strong>链表）有序<ul><li>TreeSet需要重写<code>compareTo()</code>函数/<code>Comparator</code>比较器，插入或删除时通过该函数进行比较</li></ul></li><li>记录<strong>插入</strong>顺序的集合通常指的是LinkedHashSet（放入链表尾）</li></ul></li></ol><h2 id=并发>并发<a hidden class=anchor aria-hidden=true href=#并发>#</a></h2><h3 id=多线程>多线程<a hidden class=anchor aria-hidden=true href=#多线程>#</a></h3><ol><li>Java线程与OS线程一样么<ul><li>本质上相同，1v1线程模型，Java底层用<code>pthread_create</code>创建线程</li></ul></li><li>使用多线程注意什么<blockquote><p>避免数据混乱</p></blockquote><ul><li>原子性：提供互斥访问，但同一时刻只能有一个线程操作数据&ndash;><code>atomic</code>包 & <code>synchronized</code>关键字</li><li>可见性：对主内存的修改可被其它线程看见&ndash;><code>synchronized</code>关键字 & <code>volatile</code>关键字</li><li>有序性：<strong>指令重排序</strong>导致线程A观察其它线程的指令执行顺序杂乱无序&ndash;>happens-before原则保证<ul><li>指令重排序：编译器/CPU/JVM为<strong>提高处理速度</strong>对指令重排</li></ul></li></ul></li><li>保证数据一致性的方案<ul><li>事务管理</li><li>锁：共享资源的互斥访问</li><li>版本控制：乐观锁，更新时记录版本信息，避免同时修改同一数据</li></ul></li><li>创建线程的方式有哪些<ul><li>继承Thread类：重写<code>run()</code>方法，用<code>start()</code>启动线程&ndash;>可用<code>this</code>访问当前线程</li><li>实现Runnable接口：重写<code>run()</code>方法，用<code>new Thread(new 实现类())</code>创建实例&ndash;>需用<code>Thread.currentThread()</code>访问当前线程</li><li>实现Callable接口：类似👆，但其<code>call()</code>方法可以用返回值且可抛出异常，需将其包装进<code>FutureTask</code>（Thread构造器只接受Runnable参数，<code>FutureTask</code>实现了Runnable）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>MyCallable</span><span class=w> </span><span class=n>callable</span><span class=o>=</span><span class=k>new</span><span class=w> </span><span class=n>MyCallable</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>FutureTask</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>futureTask</span><span class=o>=</span><span class=k>new</span><span class=w> </span><span class=n>FutureTask</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>callable</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Thread</span><span class=w> </span><span class=n>t</span><span class=o>=</span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=n>futureTask</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>t</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><ul><li>线程池（Executor框架）：创建&ndash;提交任务到线程池&ndash;关闭<ul><li>增加程序复杂度，错误配置可能导致死锁 but 可以重用预先创建的线程，避免线程创建销毁开销，提高程序性能</li></ul></li></ul></li><li>怎么停止线程运行<ul><li>异常法：线程调用interrupt()方法后，在线程的run方法中判断当前对象的interrupted()状态，是中断则抛出异常</li><li>沉睡停止：线程sleep，用interrupt标记中断，之后抛出中断异常</li><li>stop()：已弃用</li><li>return：interrupt标记中断，run判断状态，是中断则return</li></ul></li><li>interrupt怎么让线程抛出异常<ul><li>每个线程都一个与之关联的布尔属性来表示其中断状态，若被其它线程调用<code>interrupt()</code>：<ul><li>执行低级别可中断方法（如<code>sleep()</code>/<code>Thread.join()</code>/<code>Object.wait()</code>，解除阻塞并抛出异常</li><li>else：设置中断状态，之后轮询判断是否停止</li></ul></li></ul></li><li>Java线程的状态有哪些<ul><li>可通过<code>getStatus()</code>查看</li></ul><table><thead><tr><th style=text-align:center>线程状态</th><th style=text-align:center>对应</th></tr></thead><tbody><tr><td style=text-align:center>NEW</td><td style=text-align:center>尚未启动，未调用start</td></tr><tr><td style=text-align:center>RUNNABLE</td><td style=text-align:center>就绪+正在运行，调用了start等待调度</td></tr><tr><td style=text-align:center>BLOCKED</td><td style=text-align:center>等待监视器锁，陷入阻塞</td></tr><tr><td style=text-align:center>WAITING</td><td style=text-align:center>等待另一线程执行<strong>特定操作</strong>，eg.<code>notify()</code></td></tr><tr><td style=text-align:center>TIMED_WAITING</td><td style=text-align:center>具有指定等待时间的等待状态</td></tr><tr><td style=text-align:center>TERMINATED</td><td style=text-align:center>完成执行，终止</td></tr></tbody></table></li><li>sleep和wait的区别<ul><li>分类：sleep 是 Thread 类的静态方法；wait 是 Object 类的实例方法（依赖实例）</li><li>锁释放：sleep后线程会暂停执行指定的时间，但不会释放持有的对象锁；wait释放锁，进入等待直到其他线程调用相同对象的 notify() 或 notifyAll()唤醒<ul><li>会释放CPU</li></ul></li><li>使用条件：sleep可在任意位置调用；wait须在同步块/同步方法中调用（需先持有该对象的锁），否则抛<code>IllegalMonitorStateException</code></li><li>唤醒：sleep休眠时间结束自动恢复到就绪状态；wait需notify</li></ul></li><li>blocked和waiting有啥区别<ul><li>触发条件：blocked通常因为试图获得被其它线程持有的锁，被阻塞到锁可用；waiting等待其它线程执行某些操作，不消耗CPU资源，不参与锁竞争</li><li>唤醒机制：等锁释放，获得则进入RUNNABLE；显式唤醒</li></ul></li><li>notify 和 notifyAll 的区别<ul><li>共同点：最多一个线程能获得锁；不能控制谁得到锁</li><li>区别：<ul><li>notify唤醒一个线程，其他线程依然处于wait，若该线程结束未唤醒其它线程，则其它线程永远等待<ul><li>源码标注唤醒任意线程，但依赖于具体jvm实现，hotspot唤醒先进先出</li></ul></li><li>notifyAll所有线程竞争锁，成功的执行，执行后剩下的线程继续竞争</li></ul></li></ul></li><li>线程间怎么通信<ul><li>共享数据，volatile关键字等</li><li>wait、notify、notifyAll</li><li>locks包里的Condition接口的await、signal、signalAll，Lock接口提供更灵活的锁（如可重入锁）</li></ul></li><li>通信方式有哪些<ul><li>Object 类的 wait()、notify() 和 notifyAll() 方法&ndash;>基于<strong>对象</strong>的监视器（锁）机制</li><li>Lock 和 Condition 接口</li><li>volatile关键字</li><li>CountDownLatch，同步工具类，允许线程等待其它线程完成操作后继续执行<ul><li>CountDownLatch(int count) 指定需要等待的线程数</li><li>countDown() 减少计数器的值</li><li>await() 当前线程等待到计数器为0&ndash;>到0后所有等待的线程被唤醒</li></ul></li><li>CyclicBarrier，同步辅助类，允许一组线程相互等待到所有线程到达某公共屏障点<ul><li><code>CyclicBarrier(int parties,Runnable barrierAction)</code>，指定参与线程数量与到达后的操作</li><li>await，当前线程等待</li></ul></li><li>Semaphore，计数信号量，控制同时访问特定资源的线程数<ul><li>acquire、release、构造函数指定初始许可数量</li></ul></li></ul></li><li>怎么停止线程<blockquote><p>通过协作式逻辑控制终止，避免Thread.stop()暴力或Thread.suspend()/resume()易死锁</p></blockquote><ul><li>共享标志位主动终止：定义可见的状态变量，工作线程循环检测<ul><li>适用简单无阻塞逻辑，需确保可见性</li></ul></li><li>线程中断机制：<code>Thread.interrupt()</code>设置中断标志位<ul><li>适用可中断阻塞操作</li></ul></li><li>Future取消任务：使用线程池提交任务，并通过 <code>Future.cancel()</code> 停止线程<ul><li>适用线程池管理任务</li></ul></li><li>某些 I/O 或同步操作无法通过中断直接响应（<code>Socket.accept()</code>，<code>LOck.lock()</code>），需结合资源关闭操作（调用stop()）<ul><li>适用不可中断的阻塞操作；注意显式关闭资源触发异常，需结合中断状态判断回滚</li></ul></li></ul></li></ol><h3 id=并发安全>并发安全<a hidden class=anchor aria-hidden=true href=#并发安全>#</a></h3><ol><li>juc包中常用的类<ul><li>线程池：<code>ThreadPoolExecutor</code>创建管理线程池（核心、最大线程数、任务队列） & <code>Executors</code>线程池工厂类</li><li>并发集合：<code>ConcurrentHashMap</code> & <code>CopyOnWriteArrayList</code></li><li>同步工具：<code>CountDownLatch</code> & <code>CyclicBarrier</code> & <code>Semaphore</code></li><li>原子类：<code>AtomicInteger</code>硬件级别的原子指令 & <code>AtomicReference</code>用于对对象引用的原子操作</li></ul></li><li>怎么保证多线程安全<ul><li>synchronized：同一时刻只有一个线程可以访问该代码（应用：对象锁）==>拿到锁</li><li>volatile：用于变量，保证可见性</li><li>Lock & ReentrantLock：更灵活，可重入锁</li><li>原子类</li><li>线程局部变量：<code>ThreadLocal</code>类位每个线程提供独立的变量副本==>不再竞争</li><li>并发集合</li><li>JUC工具类</li></ul></li><li>java中有哪些常用的锁<ul><li>内置锁synchronized：包括无锁、偏向锁、轻量级锁、重量级锁级别</li><li>ReentrantLock： 显式锁类，用<code>lock()</code>和<code>unlock()</code>获取和释放锁。提供可中断的锁等待、定时锁、公平锁（按线程请求顺序分配锁）等选项</li><li>读写锁ReadWriteLock：允许多个读单个写</li><li>乐观锁&悲观锁：悲观（Reentrantlock & Synchronized），乐观只在更新数据时检查是否已被其它线程修改（版本号/时间戳实现）</li><li>自旋锁：等待是循环检查锁是否可用，而非放弃CPU并阻塞</li></ul></li><li>Synchronized底层<blockquote><p>适用简单同步情况/代码块同步/对象作为锁</p></blockquote><ul><li>（基于JVM实现）编译后在同步的代码块前后加monitorenter和monitorexit字节码指令&ndash;>enter时尝试获取对象锁，锁的计数器加1；exit时减1；为0时锁释放，等待队列的线程继续竞争锁</li><li>排它锁&ndash;>线程被阻塞/唤醒会从用户态切换到内核态</li><li>内存：加锁的过程会清除工作内存中的共享变量，再从主内存读取；释放时把工作内存中的共享变量写回主内存</li></ul></li><li>reentrantlock底层<blockquote><p>高级锁功能/性能优化/复杂同步结构</p></blockquote><ul><li>基于 AbstractQueuedSynchronizer（AQS）抽象类，通过内部类Sync实现具体锁操作——需手动获取&释放锁</li><li>可中断性：线程在等待锁时，可以被其他线程中断而提前结束等待&ndash;>LockSupport.park() 和 LockSupport.unpark()</li><li>超时时间：一段时间后还未获得锁则放弃&ndash;>tryAcquireNanos 方法</li><li>公平与非公平：默认非公平（同一时刻竞争锁）<ul><li>公平锁中线程会在运行、休眠中切换（用户态转内核态），相对非公平锁执行速度更慢&ndash;>非公平锁，线程会先用CAS尝试，获取失败才进入等待队列</li></ul></li><li>可重入性：同一个线程可以多次获得同一把锁，而不会死锁&ndash;>内部holdCount技术实现（为0时其它线程才能获得锁）</li></ul></li><li>synchronized支持重入吗<ul><li>支持。基于原子性的内部锁机制（可重入）&ndash;>调用synchronized方法的内部调用该对象的另一个synchronized方法是允许的（重复请求同一个对象的锁）</li></ul></li><li>synchronized锁的升级过程<ul><li>无锁：没开偏向锁的状态（JDK1.6后默认开启，但有JVM启动后的延迟）</li><li>偏向锁：当一个线程拿到偏向锁时，下次想要竞争锁只需要拿线程ID跟MarkWord当中存储的线程ID作比较==>相同则直接获取</li><li>轻量级锁：（主要通过CAS实现）用CAS将该对象的MarkWord拷贝到线程的锁记录Lock Record中，后将MarkWord中（应当）指向锁记录的指针指向线程A的锁空间</li><li>重量级锁：（两个以上的线程获取锁）若CAS未成功则始终自旋，消耗CPU&ndash;>重量级锁会把线程通过OS调度后挂起（节省CPU资源）
<img loading=lazy src=image-1.png alt="alt text"></li></ul></li><li>JVM对Synchronized的优化<ul><li>锁膨胀</li><li>锁消除：若JVM检测不到某代码被共享/竞争的可能，则消除同步锁</li><li>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</li><li>自适应自旋锁：通过自身循环尝试获取锁，避免线程的挂起&恢复操作&ndash;>挂起线程和恢复线程都需要从用户态转入内核态（操作慢）</li></ul></li><li>AQS介绍<ul><li>底层：用一个Volatile的int类型的成员变量来表示同步状态State，通过内置的FIFO队列（<strong>双向链表</strong>）来完成资源获取的排队，通过CAS完成对State值的修改</li><li>获取/释放锁的方法由协作类自己实现，每个实现类都要实现tryAcquire、tryRelease等方法</li></ul></li><li>ThreadLocal作用、原理、…<ul><li>作用：<ul><li>线程隔离——每个拥有独立的变量副本</li><li>降低耦合度——可以减少参数的传递（同一线程的多个函数间）</li><li>性能优势——避免线程间的同步开销</li></ul></li><li>原理：Thread类中的ThreadLocalMap字段（key是ThreadLocal本身，value是ThreadLocal的泛型对象值）</li><li>问题：线程结束时，其ThreadLocalMap也会随之销毁，但是ThreadLocal对象本身不会立即被回收&ndash;>直到没有其他引用指向它==>若未显式调用remove()方法，可能内存泄漏</li></ul></li><li>实现乐观锁的方式<ul><li>CAS操作：原子变量类，都使用的CAS</li><li>版本号控制：更新时比较版本号</li><li>时间戳：更新时比较时间戳</li></ul></li><li>CAS的缺点<ul><li>ABA问题<ul><li>可以增加版本号stamp或标记</li></ul></li><li>循环时间长开销大：自旋CAS，给CPU带来大开销</li><li>只能保证一个共享变量的原子操作：多个变量可以用AtomicReference或者synchronized</li></ul></li><li>volatile关键字有什么用<blockquote><p>轻量级的同步机制</p></blockquote><ul><li>保证变量对所有线程可见</li><li>禁止指令重排序优化&ndash;>内存屏障实现<ul><li>写-写屏障：写操作前所有其它写操作都已完成</li><li>读-写屏障：读操作后的普通写操作不会重排序到读之前</li><li>写-读屏障：写操作后的普通读操作不会重排序到写之前，并<strong>强制刷新缓存，保证可见性</strong></li></ul></li></ul></li><li>指令重排序的原理<ul><li>为提高性能，进行重排序，但要遵守：<ul><li>单线程环境下不改变程序运行的结果</li><li>存在数据依赖关系的不允许重排序（eg.area=width*height，area赋值不会在宽、高之前）</li></ul></li></ul></li><li>volatile可以保证线程安全吗<ul><li>否。不保证原子性，如非原子操作<code>i++</code></li></ul></li><li>什么情况产生死锁&如何解决<ul><li>同时满足以下条件发生：<ul><li>互斥（多个线程不能同时使用同一资源）</li><li>持有并等待：线程A持有资源1，等待资源2（被阻塞），但不会释放资源1</li><li>不可剥夺：直到使用完资源1前不可释放</li><li>环路等待：两线程获取资源的顺序构成环形链</li></ul></li><li>破坏任一，常见方法是用资源有序分配法（以相同顺序申请资源）破坏环路等待</li></ul></li></ol><h3 id=线程池>线程池<a hidden class=anchor aria-hidden=true href=#线程池>#</a></h3><ol><li>工作原理<ul><li>减少频繁的创建、销毁线程带来的性能损耗
<img loading=lazy src=image-2.png alt="alt text"></li></ul></li><li>线程池的参数有？<ul><li>corePoolSize（线程池核心线程数量）：默认情况下，线程数量小于等于其时，即使空闲也不会被销毁<ul><li>可为0</li></ul></li><li>maximumPoolSize：（最多可容纳的线程数量）</li><li>keepAliveTime：线程池中线程的数量大于corePoolSize，且空闲时间大于此时间，则被销毁</li><li>workQueue：工作队列</li><li>handler：拒绝策略</li></ul></li><li>拒绝策略有哪些<ul><li>CallerRunsPolicy：使用线程池的调用者所在的线程去执行被拒绝的任务（除非线程池被停止/任务队列有空缺）</li><li>AbortPolicy：抛出“任务被线程池拒绝”异常</li><li>DiscardPolicy：静默拒绝提交（不处理）</li><li>DiscardOldestPolicy：抛弃最老的任务，执行当前任务</li><li>自定义：实现RejectedExecutionHandler接口</li></ul></li><li>线程池参数设置：<ul><li>核心线程数：CPU密集型设置为CPU数+1，IO密集型设置为CPU*2</li><li>场景：<ul><li>（电商）SynchronousQueue&ndash;>不缓存任务，直接扩容线程 & 直接拒绝策略（避免过载） & 最大设置为32（突发流量扩容）</li><li>（后台）最大禁止扩容 & 不回收线程 & 有界阻塞队列容量1000 & CallerRunsPolicy</li><li>（微服务）60s回收 & 有界阻塞队列容量200 & 最大64（应对慢下游）</li></ul></li></ul></li><li>线程池种类有哪些<ul><li>ScheduledThreadPool：设置定期的执行任务，支持定时/周期性执行任务</li><li>FixedThreadPool：核心线程数和最大线程数一样</li><li>CachedThreadPool：可缓存线程池，线程数几乎可以无限增加，闲置时回收</li></ul></li><li>线程池中shutdown()，shutdownNow()这两个方法有什么作用<ul><li>shutdown()：置状态为SHUTDOWN，正在执行的任务继续执行，没有执行的中断，不能添加任何任务，否则抛出 RejectedExecutionException 异常</li><li>shutdownNow()：为STOP，试图停止所有正在执行的线程，不再处理还在池队列中等待的任务。&ndash;>调用Thread.interrupt() 方法&ndash;>如果线程中没有sleep 、wait、Condition、定时锁等应用，该方法失效</li></ul></li><li>提交的任务可以撤回吗<ul><li>可。向线程池提交任务时，会得到Future对象，提供方法管理任务执行</li><li><code>cancel(boolean mayInterruptIfRunning)</code>方法，尝试取消执行的任务，<code>mayInterruptIfRunning</code>指示是否允许中断正在执行的任务（true则允许）</li></ul></li></ol><h3 id=场景>场景<a hidden class=anchor aria-hidden=true href=#场景>#</a></h3><ol><li>单例模型既然已经用了synchronized，为什么还要在加volatile<ul><li>创建一个既线程安全又能正确初始化的单例模式</li><li>通过 synchronized 保证了创建过程的线程安全性，避免创建多个单例对象</li><li>volatile确保对象引用的可见性和创建过程的有序性（<strong>避免重排序</strong>）</li></ul></li></ol><h2 id=虚拟机>虚拟机<a hidden class=anchor aria-hidden=true href=#虚拟机>#</a></h2><h3 id=内存模型>内存模型<a hidden class=anchor aria-hidden=true href=#内存模型>#</a></h3><ol><li>JVM的内存模型<ul><li>程序计数器：可以看作当前线程所执行的<strong>字节码</strong>的行号指示器，存储当前线程正在执行的java方法的JVM指令地址（若执行Native方法则为null）。生命周期与线程相同</li><li>虚拟机栈：每个线程有独立的 Java 虚拟机栈，生命周期与线程相同。<strong>每个方法执行时创建一个栈帧</strong>（存储局部变量表、操作数栈、动态链接、方法出口等信息）&ndash;>可能抛 StackOverflowError 和 OutOfMemoryError 异常</li><li>本地方法栈：与虚拟机栈类似（hotspot中二者合一），主要为虚拟机使用到的 Native 方法服务。执行时创建栈帧&ndash;>可能抛 StackOverflowError 和 OutOfMemoryError 异常</li><li>堆：JVM中最大的内存区域，被所有线程共享，JVM启动时创建，存放对象实例&ndash;>可能抛 OutOfMemoryError 异常</li><li>元空间（jdk1.8后）：jdk1.8后取代方法区，使用本地内存。存储已被JVM加载的类信息、常量、静态变量等&ndash;>可能抛 OutOfMemoryError 异常（内存不足时）<ul><li>（运行时常量池）：方法区（元空间）的一部分，存放编译时生成的<strong>字面量、符号引用</strong>等，有动态性，运行时的新常量也可放入。&ndash;>可能抛 OutOfMemoryError 异常</li></ul></li><li>直接内存：不属于JVM运行时数据区的一部分，通过NIO类引入，是堆外内存，可以显著提高I/O性能&ndash;>可能抛 OutOfMemoryError 异常
<img loading=lazy src=image-3.png alt="alt text"></li></ul></li><li>JVM内存模型中堆和栈的区别<ul><li>用途：栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据 vs 堆用于存储对象的实例（包括类的实例和数组）</li><li>生命周期：栈中数据生命周期明确（一个方法调用结束，对应的栈帧即被销毁，其中的局部变量即被移除） vs 生命周期不明确（对象在垃圾回收机制（GC）检测不到引用时被回收）</li><li>存取速度：栈通常更快（先进后出，操作简单） vs 对象的分配与回收耗时，GC运行也影响性能</li><li>存储空间：栈的空间相对较小，且<strong>固定</strong>，由<strong>操作系统</strong>管理，栈溢出通常因为递归过深或局部变量过大 vs 堆的空间较大，动态扩展，由JVM管理，堆溢出通常因为创建了太多大对象或未回收不再使用的对象</li><li>可见性：栈中数据对线程私有 vs 队中数据共享</li></ul></li><li>栈中存储对象还是指针<ul><li>栈中存储基本类型的数据和对象的引用（堆存储对象实例）</li></ul></li><li>堆分为哪几部分<ul><li>新生代：<ul><li>Eden Space：大多新创建的对象存放此处，满时触发Minor GC（新生代垃圾回收）</li><li>Survivior Space：S0&amp;S1，每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间以继续其生命周期（轮流充当对象的中转站，区分短暂与长期存活的对象）</li></ul></li><li>老年代：一次或多次Minor GC仍存活的对象被移动到老年代。其中对象生命周期较长，Major GC（Full GC，设计老年代的垃圾回收）发生的频率更低，但执行时间通常更长。老年代空间通常比新生代大
<img loading=lazy src=image-4.png alt="alt text"></li><li>元空间：Java 8开始，永久代（Permanent Generation）被元空间取代，存储类的元数据信息，如类的字段、方法等。使用本地内存，不在堆中</li><li>大对象区：某些JVM实现中分配，指需要大量连续内存空间的对象，直接分配在老年代，避免内存碎片化&频繁移动的性能开销</li></ul></li><li>程序计数器的作用&为什么私有<ul><li>多线程运行，线程切换时可以通过程序计数器定位下一条指令，不同线程执行的代码的指令地址不同，故私有</li></ul></li><li>方法区中方法的执行过程<ul><li>解析方法调用（若之前未解析过，JVM根据方法符号引用找到实际方法地址）</li><li>栈帧创建</li><li>执行方法（字节码指令执行）</li><li>返回处理：返回结果，清理当前栈帧，恢复调用者的执行环境</li></ul></li><li>方法区中有什么<ul><li>类信息</li><li>常量池：存储类和接口中的常量</li><li>静态变量：类初始化时赋值</li><li>即时编译器编译后的代码缓存</li></ul></li><li>String s = new String（“abc”）执行过程对应哪些内存区域<ul><li><code>new</code>对象==>堆内存存储字符串对象</li><li><code>abc</code>字符串实际被<code>final</code>修饰，一个字符串常量，若字符串常量池中存在，则在堆中创建对象并保存其引用到常量池；不存在则在常量池中创建</li></ul></li><li>引用类型有哪些<ul><li>强：代码中普遍存在的赋值方式，比如<code>A a = new A()</code>&ndash;>强引用关联的对象<strong>永远不会被GC回收</strong></li><li>软：可以用SoftReference描述，指有用但不必须的对象&ndash;>内存溢出时会回收此类引用的对象</li><li>弱：WeakReference&ndash;>下一次GC时回收，不管内存是否足够</li><li>虚：alias幻影引用，PhantomReference，必须和ReferenceQueue一起使用&ndash;>发生GC时回收，可以用来管理堆外内存</li></ul></li><li>弱引用的应用<ul><li>弱引用通过<code>Java.lang.ref.WeakReference</code>类实现，主要用途是创建非强制性的对象引用，内存压力大时被GC清理，避免内存泄漏</li><li>应用场景：<ul><li>缓存系统：希望缓存项能够在内存压力下自动释放</li><li>对象池：管理暂时不使用的对象</li><li>避免内存泄漏：一个不该被长期引用的对象，可避免意外保留</li></ul></li></ul></li><li>内存泄漏和内存溢出<ul><li>泄露：程序在运行过程中不再使用的对象仍然被引用，GC无法回收，可用内存逐渐减少<ul><li>常见原因：静态集合（HashMap/ArrayList等）存储对象且从未清理；事件监听（未取消对事件源的监听）；线程（未停止的线程可能持有对象引用）</li></ul></li><li>溢出：JVM无法找到足够的内存，引发<code>OutOfMemoryError</code><ul><li>常见原因：大量对象创建（超过堆的限制）；持久引用（大型数据结构，如缓存、集合等长时间持有引用）；递归</li></ul></li></ul></li><li>具体的内存泄漏与溢出的例子&解决方案<ul><li>静态属性导致内存泄漏：static变量，如果集合/大量对象被指定为static，会在整个生命周期中占用内存<ul><li>解决：减少静态变量 / 若使用单例，尽量采用懒加载（真正需要时才被创建，类似网站页面的图片）</li></ul></li><li>未关闭资源导致内存溢出：忘记关闭这些资源会阻塞内存，从而GC无法清理<ul><li>解决：finally关闭 / 关闭连接部分的代码不出异常 / Java7以上版本可使用try-with-resources代码方式</li></ul></li><li>ThreadLocal内存泄漏：ThreadLocalMap使用ThreadLocal的弱引用作为key，若无外部强引用引用它，GC时ThreadLocal一定会被回收==>ThreadLocalMap中出现key为null的Entry，则无法访问对应的value&ndash;>若线程不结束，value永远无法回收<ul><li>解决：使用ThreadLocal的remove()方法移除当前线程的value / 不用ThreadLocal.set(null) 的方式清除value（并未清除） / 最好将ThreadLocal视为需要在finally块中关闭的资源</li></ul></li></ul></li></ol><h3 id=类初始化与类加载>类初始化与类加载<a hidden class=anchor aria-hidden=true href=#类初始化与类加载>#</a></h3><blockquote><p>对象的生命周期：创建&ndash;>使用&ndash;>销毁</p></blockquote><ol><li>创建对象的过程<ul><li>类加载检查：JVM遇到<code>new</code>时，检查该指令的参数能否在常量池定位到一个类的符号引用，并检查其代表的类是否已被加载、解析与初始化过，若无则执行类加载过程</li><li>分配内存：对象所需的内存大小在类加载完成后确定，JVM只需从 Java 堆中划分一块确定大小的内存</li><li>初始化零值：JVM将分配到的内存空间都初始化为零值（不包括对象头）</li><li>进行必要设置（如对象头）：如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、是否启用偏向锁等信息</li><li>执行init方法：对象需要的其他资源和状态信息还未设置，于是开始执行构造方法等</li></ul></li><li>类加载器有哪些<ul><li>启动类加载器：最顶层，负责加载Java核心库（如位于jre/lib/rt.jar中的类），cpp编写，属于JVM的一部分。无法被java程序直接引用</li><li>扩展类加载器：java实现，继承自ClassLoader类，加载java扩展目录下的jar包与类库（如jre/lib/ext或由系统变量Java.ext.dirs指定的目录），有启动类加载器加载</li><li>系统类/应用程序类加载器：java实现，负责加载用户类路径（ClassPath）上的指定类库，默认使用。父加载器是扩展类加载器</li><li>自定义类加载器：开发者根据需求定制，java动态性的重要体现</li><li>双亲委派模型：收到类加载请求时，类加载器把它委派到父类加载器中（直到顶层的启动类加载器），只有当父类反馈无法完成请求时（它的搜索范围中没有找到所需的类），子加载器才尝试自己加载
<img loading=lazy src=image.png alt="alt text"></li></ul></li><li>双亲委派模型的作用<ul><li>保证类的唯一性：避免不同类加载器加载相同类的情况</li><li>保证安全性：Java核心库被启动类加载器加载，启动类加载器只加载信任的类路径中的类&ndash;>防止冒充核心类</li><li>支持隔离与层次划分：支持不同层次的类加载器服务于不同的类加载需求，有助于实现沙箱安全机制，保证各层级加载器的职责清晰，便于维护扩展</li><li>简化加载流程：减少每个加载类需要处理的类的数量</li></ul></li><li>类加载的过程
<img loading=lazy src=image-5.png alt="alt text"><ul><li>加载：通过类的全限定名（包名 + 类名），获取到对应的.class文件的二进制字节流，将字节流代表的静态存储结构转化为方法去运行时的数据结构，在内存中生成代表该类的Java.lang.Class对象，作为方法区该类的访问入口</li><li>连接：<ul><li>验证：确保字节流信息符合JVM要求，保证其不会危害JVM安全（文件格式校验、元数据、字节码、符号引用验证）</li><li>准备：为静态字段分配内存并设置初值（final不设置）</li><li>解析：将常量池的符号引用（描述目标的一组符号，只要能无歧义定位目标即可）替换为直接引用（指向目标的指针、偏移量等）</li></ul></li><li>初始化：执行（编译器生成的）构造器方法（如静态字段赋值、执行静态初始化块代码），非开发者编写</li><li>使用：使用类/创建对象</li><li>卸载：该类所有实例被回收 / 加载该类的ClassLoader已被回收 / 类对应的Java.lang.Class对象不再被引用（无法通过反射访问） 时卸载类</li></ul></li></ol><h3 id=垃圾回收>垃圾回收<a hidden class=anchor aria-hidden=true href=#垃圾回收>#</a></h3><ol><li>什么是垃圾回收&如何触发<blockquote><p>自动管理内存，检测与管理对象，回收不再被引用的对象占用的内存，减少内存泄漏与内存管理错误的可能性</p></blockquote><ul><li>内存不足：JVM检测到堆内存不足，无法为新对象分配内存时</li><li>手动请求：可调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>回收，不保证立即执行</li><li>JVM参数：启动时通过JVM调整，可设定最大堆大小、初始堆大小等</li><li>对象数量/内存达到阈值：垃圾回收器内监控</li></ul></li><li>判断垃圾的方法<ul><li>引用计数法：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1，引用失效时计数器减1。为0时可回收<ul><li>缺点：循环引用，永不为0</li></ul></li><li>可达性分析（主要采用）：从一组称为GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象与引用对象的引用对象。若不可达某对象，则该对象回收<ul><li>GC Roots包括：虚拟机栈栈帧中的本地变量表引用的对象、方法去中类静态属性引用的对象、本地方法栈中JNI（Java Native Interface）引用的对象、活跃线程的引用等</li></ul></li></ul></li><li>垃圾回收算法有哪些<ul><li>标记-清除：可达性分析标记需回收对象，之后统一回收<ul><li>缺点：效率低 & 清除结束后会造成大量碎片空间</li></ul></li><li>复制：（解决碎片问题）将内存分为两块，每次申请只使用其中一块，内存不够时将存活的复制到另一块上，再将已使用的内存整个清理掉<ul><li>缺点：内存利用率太低</li></ul></li><li>标记-整理：标记后将所有存活对象移动到内存一端，之后清理剩余部分</li><li>分代回收：分为新生代与老年代，经历一次GC年龄加一，超过（默认15）后进入老年代</li></ul></li><li>垃圾回收器有哪些<ul><li>使用复制算法<ul><li>Serial：新生代单线程收集器，标记和清理都是单线程</li><li>ParNew：（新生代only）Serial收集器的多线程版本</li><li>Parallel Scavenge：（新生代only）追求高吞吐量（用户线程时间/(用户线程时间+GC线程时间)），高效利用 CPU</li></ul></li><li>使用标记整理：<ul><li>Serial Old：老年代单线程收集器，Serial收集器的老年代版本</li><li>Parallel Old：Parallel Scavenge收集器的老年代版本</li><li>G1（Gabage First）： Java堆并行收集器，回收范围为整个堆<ul><li>引入分区思路，弱化分代概念 & 合理利用GC各周期的资源</li><li>停顿时间可控（可设置预期停顿时间避免雪崩） & 更充分利用硬件优势缩短STW停顿时间（较CMS）</li></ul></li></ul></li><li>使用标记清除：<ul><li>CMS(Concurrent Mark Sweep) ：老年代并行收集器，追求最短GC回收停顿时间（用户线程停顿的平均时间）<ul><li>会产生<strong>浮动垃圾</strong>（并发标记为存活，后来死亡，但是再标记无法知晓），浮动垃圾过多会退化为serial old</li></ul></li></ul></li></ul></li><li>垃圾回收算法哪些阶段会stop the world（STW）<blockquote><p>以标记-复制算法（应用于CMS新生代ParNew、G1垃圾回收器等）为例，以G1的混合回收的标记-复制为例</p></blockquote><ul><li>标记：<ul><li>初始标记：从GC Roots出发标记全部直接子节点&ndash;>耗时短，STW</li><li>并发标记：从GC Roots开始对堆中对象进行可达性分析，找出<strong>存活对象</strong>（只知存活，不知死亡）&ndash;>并发，应用线程与GC线程可以同时活动，<strong>非STW</strong></li><li>再标记：通过<strong>可达性分析</strong>重新标记在并发标记阶段发生变化的对象（only将之前不知存活的标记为存活）&ndash;>STW</li></ul><blockquote><p>G1会通过SATB来记录开始时的所有存活对象，最终标记阶段会通过SATB与Remembered mark找到并发标记阶段不再被引用的对象，以此避免浮动垃圾；CMS无法找到不再被引用的对象（因此会产生浮动垃圾），只能增加被引用的对象</p></blockquote></li><li>清理：清点有存活对象与无存活对象的分区，不清理垃圾对象，也不复制&ndash;>STW</li><li>复制：复制算法中的转移阶段需要分配新内存和复制对象的成员变量&ndash;>STW（主要时间瓶颈）</li></ul></li><li>minorGC、majorGC、fullGC的区别，什么场景触发full GC<ul><li>Minor GC (Young GC)：只针对年轻代&mdash;Eden区空间不足时触发，将Eden与一个Survivor中的存活对象转移到另一个Survivor/老年代&mdash;频繁</li><li>Major GC (Old GC)：<strong>主要</strong>针对老年代进行回收，但不一定&mdash;老年代空间不足/年轻代晋升到老年代速度过快可能触发&mdash;频率相对Minor更低，但时间更长</li><li>Full GC：整个堆（年轻代、老年代以及永久代/元空间）回收&mdash;直接调用 / Minor GC时存活对象无法全部放入老年代或老年代空间不足 / 永久代（Java8之前）或元空间（之后）空间不足时&mdash;STW，遍历整个堆</li></ul></li><li>什么时候用CMS，什么时候用G1<ul><li>CMS适用：低延迟（停顿时间） / 老年代 / 碎片化管理（容易出现内存碎片，可能需要定期Full GC）</li><li>G1适用：大堆内存 / 对内存碎片敏感 / 较平衡的性能（停顿时间&吞吐量）</li></ul></li><li>GC的只有堆吗<ul><li>堆和方法区（存储类信息、常量、静态变量等）</li></ul></li></ol><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></div><footer class=post-footer><ul class=post-tags><li><a href=https://Sattiluvcat.github.io/en/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://Sattiluvcat.github.io/en/posts/notes/shell%E4%BD%BF%E7%94%A8%E5%B0%8Ftrick/><span class=title>« Prev</span><br><span>shell简单使用</span>
</a><a class=next href=https://Sattiluvcat.github.io/en/posts/java/%E5%85%AB%E8%82%A1--spring/><span class=title>Next »</span><br><span>八股——Spring</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on x" href="https://x.com/intent/tweet/?text=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f&amp;title=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&amp;summary=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&amp;source=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f&title=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on whatsapp" href="https://api.whatsapp.com/send?text=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java%20-%20https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on telegram" href="https://telegram.me/share/url?text=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fjava%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://www-sattiluvcat-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><script id=dsq-count-scr src=//www-sattiluvcat-github-io.disqus.com/count.js async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://Sattiluvcat.github.io/en/>Satti's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")</script></body></html>