<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><head><script async src="https://www.googletagmanager.com/gtag/js?id=自己的G-MEASUREMENT_ID"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","自己的G-MEASUREMENT_ID")</script></head><title>八股——Java | Satti's Blog</title>
<meta name=keywords content="Java"><meta name=description content="Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding"><meta name=author content="Satti"><link rel=canonical href=https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--java/><link crossorigin=anonymous href=/assets/css/stylesheet.c5df81d78a700d63222bf88c998222af7e6085cc41585cba2eff58e49fd49e25.css integrity="sha256-xd+B14pwDWMiK/iMmYIir35ghcxBWFy6Lv9Y5J/UniU=" rel="preload stylesheet" as=style><link rel=icon type=image/png href=/favicon-48x48.png sizes=48x48><link rel=icon type=image/svg+xml href=/favicon.svg><link rel="shortcut icon" href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta name=apple-mobile-web-app-title content="MyWebSite"><link rel=manifest href=/site.webmanifest><link rel=alternate hreflang=en href=https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--java/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script async src="https://www.googletagmanager.com/gtag/js?id=自己的G-MEASUREMENT_ID"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","自己的G-MEASUREMENT_ID")</script><meta property="og:title" content="八股——Java"><meta property="og:description" content="Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding"><meta property="og:type" content="article"><meta property="og:url" content="https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--java/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-11T16:43:40+08:00"><meta property="article:modified_time" content="2025-03-22T18:58:40+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="八股——Java"><meta name=twitter:description content="Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://Sattiluvcat.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Notes📓","item":"https://Sattiluvcat.github.io/en/posts/notes/"},{"@type":"ListItem","position":3,"name":"八股——Java","item":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--java/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"八股——Java","name":"八股——Java","description":"Java基础-集合-并发-虚拟机（简略）知识总结，来自小林coding","keywords":["Java"],"articleBody":" 基础 概念 Java特点： 平台无关性——编译器将源代码翻译为字节码，字节码可在任何安装了JVM（java虚拟机）的系统上运行 面向对象——strictly OOP，易于维护与重用（类、对象、继承、多态、抽象与封装） 内存管理——有自己的垃圾回收机制，自动管理内存和回收不再使用的对象 为什么Java是跨平台的？ Java程序经过编译后形成字节码（.class）文件，不同平台通过不同版本的JVM将字节码文件翻译为机器码后运行 JVM/JDK/JRE关系 JVM-java虚拟机，将字节码解释/编译为机器码并执行。提供内存管理、垃圾回收、安全性等功能 JRE-java运行的环境（需要的最小环境），包含JVM与一组Java类库。不包含开发工具 JDK-java开发工具包，包含JVM、**编译器（javac）、调试器（jdb）**等开发工具与类库。提供开发、编译、调试与运行的全部工具与环境 编译与解释共存？ 编译型：Java 源代码通过 javac 编译器编译成字节码，而非机器码 –\u003e 平台无关性 解释型：JVM 通过解释器将字节码逐行翻译成机器码并执行 –\u003e 即时编译JIT JIT：将热点代码（方法调用计数器计数确定）直接编译为机器码，后续执行时无需再次解释 编译和解释型的区别？ 编译型：程序执行前，整个源代码被编译为机器码/字节码，生成可执行文件 –\u003e 速度快 but 跨平台性差 解释型：程序执行时，逐行解释执行源代码（解释器动态解释），不生成独立的可执行文件 –\u003e 速度慢 but 可跨平台 数据类型 基本数据类型： 1字节；byte, boolean | 2字节：short, char | 4字节：int, float | 8字节：double, long 包装类：Character \u0026 Integer \u0026 首字母大写 char无符号，不可为负，故从0开始 类型转换： 隐式转换（自动） 显式转换（强制） 字符串转换：如字符串转为 int ，可用 Integer.parseInt() 数值间转换：整型 \u003c==\u003e 字符型，可用包装类的工具方法实现（如Character类、Integer类） 类型转换的问题： 数据丢失：范围大类型到范围小类型。如 long 到 int，会截断保留低位 数据溢出：范围小类型到范围大类型。会填充高位，原数据不变 精度损失：浮点数类型的转换 –\u003e 表示方式不同，double（高精度） 转 float 可能损失精度 类型不匹配 BigDecimal vs double double会精度丢失 –\u003e 二进制浮点运算，有时不能准确表示小数（如0.1） BigDecimal精确计算，注意用字符串创建新对象，不用浮点 –\u003e BigDecimal num1 = new BigDecimal(\"0.1\"); 装箱、拆箱 自动装箱happens when： 赋值（Java1.5后自动）： // before Java1.5 Integer iObject=Integer.valueof(3); int i=iObject.intValue(); // after Java1.5 Integer iObject=3; int i=iObject; 方法调用：实质也是赋值，将int与Integer颠倒使用 自动装箱弊端：循环中自动装箱（颠倒使用时），会创建大量无用对象 \u0026 垃圾回收工作量大 Why Java has Integer? 前提：Integer是int类型的包装类，把int类型包装成Object对象，即对象封装 作用： 泛型：Java中，泛型只能使用引用类型，而不能使用基本类型。如列表只能用List 泛型允许在定义类、接口或方法时使用类型参数（如Box），使用时再指定具体类型 转换：Java中，基本类型和引用类型不能直接进行转换，必用包装类。如int转String（转为Integer后.toString()） 集合：Java集合只能存储对象 Integer相比int优点（区别）？ 基本类型 vs 引用类型：基本类型不需实例化即可使用 ==\u003e int存储一个整数不需额外的内存分配（性能更快），Integer要为对象分配内存 引用类型，对象的引用和对象本身分开存储；基本类型，变量对应的内存块存储数据自身 So：基本类型读写效率、内存效率更高 自动拆装箱 空指针异常：Integer变量必须通过实例化对象来赋值，若其未经初始化会出现空指针异常（int默认赋0） Integer的缓存 实现静态缓存池（默认存储-128~127），通过Integer.valueOf(int)方法创建该范围内的对象时，会复用缓存中的现有对象（from内存） 面向对象 面向对象是什么？与特性 OOP：编程范式，将现实世界中的事物抽象为对象，对象具有字段（属性）与方法（行为）。具有灵活性与可拓展性 特性： 封装：将对象的属性（数据）和行为（方法）结合，仅用接口与外界交互。–\u003e增强安全性和简化编程，使对象更独立 继承：使子类可自动共享父类数据结构和方法，代码复用。–\u003e建立类与类间的层次关系，结构更清晰 多态：允许不同类的对象对同一消息作出响应，即同一个接口，使用不同实例而执行不同操作。编译时多态（重载）和运行时多态（重写）–\u003e灵活性与拓展性 多态体现？ 方法重载：同一类中可以有多个同名方法，但参数列表不同。编译器确定调用哪个方法 方法重写：子类能够提供对父类中同名方法的具体实现（不同子类可以实现不同，但参数不变）。JVM在运行时根据对象实际类型确定调用哪个方法 接口与实现：多个类可以实现同一个接口，并用接口类型的引用来调用这些类的方法 如Dog是Animal的实现类，创建实例时用：Animal dog=new Dog();（dog是Dog类的实例，Animal是dog的接口类型） 向上/下转型：子类父类共有方法可用向上转型调用，子类特有方法需要父类对象向下转型后调用 （向上转型）子类对象转换为父类对象，自动进行（如Animal dog=new Dog();） （向下转型）父类对象转换为子类对象，执行前需确认引用实际指向的对象，避免ClassCastException 多态作用 meaning：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。需要继承、接口类等语法机制 作用：提高代码的扩展性和复用性。 OOP的设计原则 单一职责原则SRP：一个类应该只负责一项职责 开放封闭原则OCP：软件实体应该对扩展（entends，子类）开放，对修改封闭。（即可以继承这个类，但不能修改类本身） 里氏替换原则LSP：子类对象应该能够替换掉所有父类对象。（不改变父类预期行为等） 接口隔离原则ISP：客户端不应该依赖那些它不需要的接口 依赖倒置原则DIP：高层模块不应该依赖低层模块，二者都应该依赖于抽象 最少知识原则：一个对象应当对其他对象有最少的了解 抽象类与普通类区别 实例化：抽象类不能被实例化，只能被继承 方法实现：抽象类中的方法可以有实现也可以没有实现 继承：一个类只能继承一个类（any），但可继承（普通类）/实现（抽象类）多个接口 限制：普通类可以被其他类继承\u0026使用，抽象类一般用作基类 抽象类 vs 接口 二者特点： 抽象类：可以有成员变量、构造方法和具体方法–\u003e适用继承关系 接口：可以多实现，只能有常量和抽象方法（无构造方法）（Java8后可以有默认方法与静态方法–\u003e定义行为规范与类的功能 区别： 实现：接口用implements，抽象类用extends，一个类多接口单抽象类 方法：接口不能有方法的实现，java8中可定义default方法体。抽象类无限制 访问修饰符： 接口成员变量默认public static final，必须赋初值不能被修改（final特性），所有成员方法都是public、abstract的 抽象类中成员变量默认default，可被子类重新定义or赋值，抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号 变量：接口只能包含（静态）常量；抽象类可包含实例变量与静态常量 抽象类可加final吗？ no。抽象类是被继承的，final禁止类的继承 or 方法重写 接口可以定义什么方法？ 抽象方法：核心，所有实现接口的类必须实现这些方法 默认方法：允许接口提供具体实现。实现类可以重写默认方法 静态方法：属于接口本身，可以通过接口名直接调用，不需实现类的对象 私有方法：Java9引入。为默认/私有方法提供辅助功能 抽象类可以被实例化吗？ 自身不能被实例化–\u003e不能直接new一个对象。但可以有构造器，创建子类实例时间接使用（不需指定super，先调用父类构造器，后调用子类构造器） 静态变量与静态方法 静态变量：属于类而非具体的对象 共享性：所有该类的实例共享同一个静态变量。一个实例修改，其它实例均知晓 初始化：在类被加载时初始化，只分配一次内存 访问方式：可以直接通过类名访问，也可以通过实例访问（建议类名） 静态方法： 无实例依赖：可在没有创建类实例的情况下调用，不能直接访问非静态的成员变量 or 方法（因为无上下文的实例） 直接访问静态成员 多态性：不支持重写，可以被Hide 使用场景： 静态变量：需要在所有对象间共享的数据，如计数器、常量等 静态方法：常用于助手方法（utility methods）获取类级别的信息或者是没有依赖于实例的数据处理 非静态内部类与静态内部类区别（以下只列出非静态特点） 外部类实例的依赖 访问外部类的变量、方法 不能定义静态成员 不能独立实例化 可以访问外部类的私有成员 非静态内部类怎么直接访问外部方法 编译器在生成字节码时会为非静态内部类维护一个指向外部类实例的引用。生成非静态内部类的构造方法时，将外部类实例作为参数传入 父类、子类的静态方法，在new子类对象时的加载顺序 父类静态–\u003e子类静态–\u003e父类构造器–\u003e子类构造器 拷贝 深浅拷贝： 浅拷贝：只复制对象本身和其内部的值类型字段，不复制对象内部的引用类型字段–\u003e共享引用 深拷贝：将对象内部的所有引用类型字段的内容也复制（完全独立） 实现深拷贝的方法： 实现 Cloneable 接口并重写 clone() 方法：要求对象及其所有引用类型字段都实现接口并重写方法（clone()通过递归克隆实现深拷贝） 序列化与反序列化：对象序列化为字节流，再从字节流反序列化为对象–\u003e要求对象与引用类型都实现 Serializable 接口 手动递归复制：对象及引用类型字段 如List里new AyyayList\u003c\u003e(list) 特性 泛型 什么是泛型 允许类、接口和方法在定义时使用一个或多个类型参数，使用时类型参数可以被指定为具体的类型 why need 泛型 适用于多种数据类型执行相同的代码–\u003e代码复用 泛型中的类型在使用时指定，不需要强制类型转换（如：不指定时，取出时需转换）–\u003e保证类型安全，编译器来检查 反射 需要开发者调用某些方法实现，Spring底层大量使用反射（有涉及反射的相关代码）\n什么是反射 运行时，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。动态获取的信息以及动态调用对象的方法的功能==\u003e反射机制 特性 运行时类信息访问——完整信息，父类、接口、包名、构造函数、方法、字段 动态对象创建——反射API动态地创建对象实例，即使在编译时不知道具体的类名（newInstance()） 动态方法调用——运行时动态地调用对象的方法，包括私有方法（Method类地invoke()方法） 访问与修改字段值——允许程序在运行时访问和修改对象的字段值，即使是私有的（Field类的get()/set()方法） 应用场景 加载数据库驱动 配置文件加载——IOC加载Bean 将所有XML或properties配置文件夹载入内存–\u003e解析其内容，得到对应实体类的 字节码字符串 等–\u003e利用反射，根据字符串得到类的实例–\u003e动态配置实例属性 注解 注解原理 本质是一个继承了Annotation接口的接口，实现类是Java运行时生成的动态代理类（用这个类存储注解中的属性等，调用注解方法时，代理类返回存储的值） 注解作用域Scope 类级别、方法级别、字段级别、（构造函数作用域、局部变量作用域） 可以指定属性，如访问级别、注释等 对象 创建对象的方式 new Class或Constructor类的newInstance()方法（即反射机制） clone() \u0026 反序列化（即深拷贝） clone()要实现Cloneable接口，反序列化（类）要实现Serializable接口 new的对象什么时候回收 垃圾回收器回收，回收时机取决于： 引用计数法：某对象的引用计数为0时==\u003e不再被引用 可达性分析算法：从根对象出发，通过对象的引用链遍历，拖不存在到达某对象的引用链–\u003e回收 终结器：重写finalize()方法的对象，回收对象前会调用该方法 异常 哪些异常 基于Throwable及其子类，子类包括Error与Exception Error：表示运行时环境的错误，程序无法处理。如StackOverFlowError Exception： 非运行时异常：必须编译时捕获或抛出，一般为外部错误。如FileNotFoundException 运行时异常：程序错误导致。如NullPointerException、ArrayIndexOutOfBoundException 异常处理 try-catch-finally： try{} catch (Exception1 e1){ // 处理第一类异常的逻辑，比如👇 throw new Exception1(\"Exception Happend!\"); } catch (Exception2 e2){} finally { // 可选，定义无论有否异常都要执行的代码块 // 一般用于资源释放 } throws：方法中声明可能抛出的异常类型，将异常传递给调用者处理 try与finally，return哪一个 返回finally中的return值–\u003etry中的返回值暂存，执行finally，最终try的结果被覆盖 Java1.8新特性——Stream \u0026 completableFuture Java的stream API 提供高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。 提高代码的可读性和简洁性，还能利用多核处理器的优势进行并行处理 stream API案例 过滤 List\u003cString\u003e ans=list.stream() .filter(s -\u003e s.length()\u003e3) .collect(Collectors.toList()); 求和 stream流的并行API是什么 ParallelStream。将源数据fork为多个子流进行多线程操作，处理结果join为一个流对象–\u003e底层为通用的fork/join池 序列化 怎么把一个对象从一个jvm转移到其它jvm 序列化与反序列化：字节流 消息传递机制：消息队列/网络套接字通信，需自定协议来序列化对象 远程方法调用（RPC） 共享数据库或缓存 Java默认序列化的缺点 主流序列化框架：Protobuf、FastJson\n无法跨语言：序列化框架与协议其他语言没有实现 易被攻击：反序列化通过ObjectInputStream上调用readObject()进行，可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化–\u003e可执行任意类型的代码 序列化后流太大：二进制数组越大，占用空间越多 具体怎么转对象为二进制字节流 序列化用ObjectOutPutStream的writeObject，获取输出流，可写入二进制文件中，创建输入流并读取对象进行反序列化 需要确保类实现了Serializable接口，并且所有成员变量都是Serializable的（原生类型如int自动支持，其它引用类型需要实现该接口） 设计模式 代理模式和适配器模式的区别 目的：代理模式关注控制对对象的访问，适配器用于接口转换，使不兼容的类能一起工作 结构：代理一般包含抽象主题、真是主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色 应用场景：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作 I/O Java怎么实现网络IO高并发编程 Java NIO–\u003e同步非阻塞IO模型，基于IO多路复用实现 NIO、BIO、AIO BIO：blocking IO，基于流模型，同步阻塞交互–\u003e一个线程处理一个IO NIO：non-blocking IO，Java1.4引入，多路复用，同步非阻塞 AIO：asynchronous IO，Java1.7引入，异步非阻塞 NIO实现 用到NIO的框架–\u003eNetty\n同步核心为Selector，代替线程本身的轮询IO事件 特殊 ==与equals的区别 重写了equals的类：==比较内存的首地址（即是否指向同个对象），equals比较内容 如String、包装类与List、Set集合类 使用Object.equals()的类：都比较内存首地址 native方法 允许Java调用外部的本地代码，如Cpp代码。native是一种声明，标记方法的实现在外部定义 实现native方法需要：JNI头文件生成（C/Cpp的头文件）–\u003e本地代码实现–\u003e编译本地代码（动态链接库on Win或共享库 on Linux）–\u003e加载本地库，JVM调用native方法的实现 排序 实现Comparable接口，重写compareTo方法 public class Students implements Comparable\u003cStudent\u003e{ private int id; private int score; // 略 @Override public int compareTo(Student other){ if(this.score!=other.score) return Integer.compare(other.score,this.score); // 降序 else return Integer.compare(this.id,other.id); // 升序 } } 集合 总体概念 数组与集合的区别 数组定长，集合动态长度 数组可以包含基本类型与对象（引用类型），集合仅对象 数组可以直接访问元素，集合需要迭代器等方法访问 哪些集合 List——有序Collection，常用实现类有LinkedList、ArrayList、Vector、Stack ArrayList：线程不安全，底层使用数组（扩容时创建更大数组后复制）。支持快速随机访问元素，插入删除慢 LinkedList：底层双向链表，插入删除快，访问慢 Map——键值对集合，没继承Collection接口。主要实现TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap HashMap 哈希原本的存储结构即数组。解决哈希冲突的方法–\u003e放的地方变多【开放地址（线性探测，向后放一位，注意取模 \u0026 二次探测，向前后走i^2位）、建立溢出区】/算的方法变多（多个哈希函数计算直到不冲突） LinkedHashMap：继承HashMap，在其基础上增加了双向链表，保持插入顺序 HashTable：数组+链表，线程安全–\u003e每个方法加synchronized TreeMap：红黑树 ConcurrentHashMap：数组+链表+红黑树，线程安全 Set——元素不重复、无序，常用实现HashSet、LinkedHashSet、TreeSet HashSet：通过HashMap实现。key存元素，value统一==\u003e不有序\u0026线程不安全（HashMap） LinkedHashSet：HashSet子类，通过LinkedHashMap实现，双向链表维护元素插入顺序 TreeSet：TreeMap实现。添加元素时按比较规则插入到合适的位置，保证集合有序 线程安全的集合？ 线程安全的类： Vector–\u003e内部方法基本都加synchronized HashTable–\u003e每个公共方法加synchronized（仅单线程操作），不支持null键和值==\u003e不建议用 并发Map（java.util.concurrent）： ConcurrentHashMap。JDK1.8取消segment，对每一行加锁 ConcurrentSkipListMap：基于跳表 并发Set（包同上）： ConcurrentSkipListSet：有序集合，底层ConcurrentSkipListMap CopyOnWriteArraySet：无序集合==\u003e线程安全的HashSet 并发List（同上）： CopyOnWriteArrayList：写时复制（写的时候加Lock锁，复制数组，期间其它线程读旧数组，写完指向新数组） 并发Queue： ConcurrentLinkedQueue：适用高并发，使用CAS BlockingQueue：简化数据共享–\u003e读写阻塞等待（没数据了还要读，该线程就一直等待） 并发Deque： LinkedBlockingDeque：每个节点维护前驱和后驱节点，没有读写锁分离，同一时间允许一个线程操作 ConcurrentLinkedDeque： Collections和Collection的区别 Collection是所有集合类的基础接口 Collections是工具类，提供静态方法 遍历集合的方法： for / for-each（增强for循环） Iterator迭代器 / ListIterator列表迭代器（迭代器的子类） forEach：list.forEach(element -\u003e System.out.println(element)); Stream API：list.stream().forEach(element -\u003e System.out.println(element)); 可能产生ConcurrentModificationException的情况 检测到集合内部结构在遍历时被修改，立刻抛出 如：迭代器中（包括Iterator和增强for–\u003e底层为迭代器）调用集合方法remove/set–\u003e应用迭代器的remove/set 建议用线程安全的实现类 List 常见实现与不同 Vector、ArrayList、LinkedList（CopyOnWriteArrayList···） Vector 与 ArrayList 为动态数组，Vector线程安全，都适合随机读取 LinkedList适合增删 删除指定元素的时间复杂度 ArrayList–\u003eO(n)，该元素后面的所有元素都要挪动==\u003e最后一位可以直接删 LinkedList–\u003eO(n)，要顺序定位，首尾不用 CopyOnWriteArrayList–\u003e写时可以读，并发性能好 ArrayList变成线程安全的方法 用Collections类的synchronizedList方法包装ArrayList List\u003cString\u003e sycList=Collections.synchronizedList(list); 用Vector或CopyOnWriteArrayList代替 为什么ArrayList线程不安全 问题：部分值为null \u0026 索引越界 \u0026 size与add数量不符 底层：以add为例 public boolean add(E e){ ensureCapacityIntenal(size+1); // 判断数组大小是否足够，不够就扩容 elementData[size++]=e; // （实际大小已经至少是size+1了）size位赋为e，size+1（仅记录数组长度，与实际长度不同时变） return true; } 分析：线程1发现size为9，容量为10（不用扩），线程2发现size为9，容量为10（不用扩） 1设置index为9的位，2设置index为9的位，1令size++，2令size++==\u003eindex为10的位为null 1设置index为9的位，1令size++，2设置index为10（此时的size）的位==\u003e索引越界 ==\u003esize与add的数量不符 ArrayList的扩容机制 计算新容量==\u003e一般为1.5倍（因为用移位算，速度快，newSize=oldSize+(oldSize\u003e\u003e1)） 创建新数组–\u003e复制元素–\u003e更新引用–\u003e完成扩容 CopyOnWriteArrayList如何保证线程安全 底层是用volatile修饰的数组：private transient volatile Object[] array; 写入时加互斥锁ReentrantLock–\u003e拷贝到长度加1的新数组–\u003e新数组放入新值–\u003e替换引用–\u003efinally释放锁 Map Map遍历方法 entryset： // 也可以用 keySet()，只得到 key 的集 for(Map.Entry\u003cInteger,Integer\u003e entry:map.entrySet()){ int key=entry.getKey(),val=entry.getValue(); } 迭代器–\u003e适合迭代删除 Iterator\u003cEntry\u003cInteger,Integer\u003e\u003e iterator=map.entrySet().iterator(); while(iterator.hasNext()){ Entry\u003cInteger,Integer\u003e entry=iterator.next(); } lambda表达式+forEach方法==\u003emap.forEach((key,value)-\u003ekey=key+1) stream API HashMap底层原理 JDK1.7前为数组+链表（解决hash冲突）–\u003eJDK1.8链表长度超过8且数组长度大于64转用红黑树（n–\u003elog(n)） HashMap线程安全吗 否。问题有：JDK1.7前数组扩容时可能Entry链死循环/数据丢失–\u003eJDK1.8 put时数据覆盖 死循环：头插法，扩容时旧链表节点被逆序转移到新链表（旧链表按顺序读取节点，继续头插法插入新链表）–\u003e当线程B完成复制，线程A开始复制时， 解决方案：(Collections.synchronizedMap同步加锁)/HashTable/ConcurrentHashMap put的过程 计算索引–\u003e检查空否–\u003e（非空）检查key是否相同（hashCode同\u0026\u0026equals）（同则直接更新）–\u003e（不同）链表/红黑树查找，找不到则加入–\u003e检查链表长度–\u003e检查负载因子0.75（键值对数量与数组大小的比值）–\u003e扩容，新建两倍大的数组，重新计算哈希码并插入 HashMap的get方法安全吗 空指针异常，but初始化后可以用null作为键 多线程环境 HashMap一般用什么做key String。不可变，稳定（hashCode与equals方法的正确性） 为什么用红黑树而非平衡二叉树 完全平衡要求任何结点的左右子树的高度差不超 1–\u003e频繁的左右旋 红黑树只要求整个树最长路径不超最短的两倍–\u003e不用频繁调整 重写equals和hashCode的注意事项 同时重写！ \u0026\u0026 o1.equals(o2)==\u003eo1.hashCode() == o2.hashCode()（反之不然） HashMap扩容机制 注意：HashMap初始容量为16 容量一般增为两倍，哈希码与新容量做按位与，若得1则新索引为原索引+原容量（高位赋1，即若新容量为16，则xxx–\u003e1xxx）；若得0则不变 所以不用重新算hash，且可以认为均匀地分散节点（0/1随机） 负载因子 默认0.75，元素个数超过容量的75%就扩容–\u003e太低会有大量空桶（空间浪费），太高会有大量碰撞（性能不好） ConcurrentHashMap怎么实现 JDK1.7.数组+链表。大数组Segment（即可重入锁ReentrantLock），小数组HashEntry存储键值对–\u003e一段数据一个锁，其它段数据可被访问，当前段可被读 JDK1.8.数组+链表/红黑树。（计算哈希值时，通过扰动函数优化哈希分布）volatile+CAS/synchronized–\u003e添加元素时若容器（map）为空则volatile+CAS初始化，若容器不为空但位置（数组中的位置）空用volatile+CAS初始化，若位置不为空（发生了哈希冲突）用synchronized，遍历数据并替换/新增节点到桶并判断是否需转换 对头结点加（悲观）锁保证线程安全（类似一行数据） \u0026 CAS为乐观锁，synchronized为悲观锁–\u003e发生哈希碰撞时证明线程竞争比较激烈，悲观锁效率更高 CAS：比较并交换，比较当前要修改的值与线程的预期值是否相等，是则修改，否则重新读值 Node.val 和 Node.next 声明为 volatile，确保读操作无需加锁 Set Set为什么无重复 根据hashCode确定存储位置，根据equals判断是否有相同元素 有序Set是？记录插入顺序的集合是？ TreeSet（红黑树） \u0026 LinkedHashSet（双向链表）有序 TreeSet需要重写compareTo()函数/Comparator比较器，插入或删除时通过该函数进行比较 记录插入顺序的集合通常指的是LinkedHashSet（放入链表尾） 并发 虚拟机 ","wordCount":"11114","inLanguage":"en","datePublished":"2025-01-11T16:43:40+08:00","dateModified":"2025-03-22T18:58:40+08:00","author":[{"@type":"Person","name":"Satti"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--java/"},"publisher":{"@type":"Organization","name":"Satti's Blog","logo":{"@type":"ImageObject","url":"https://Sattiluvcat.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Sattiluvcat.github.io/en/ accesskey=h title="Satti's Blog (Alt + H)"><img src=https://Sattiluvcat.github.io/img/label1.jpg alt aria-label=logo height=35>Satti's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Sattiluvcat.github.io/en/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://Sattiluvcat.github.io/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://Sattiluvcat.github.io/en/tags title=📑标签><span>📑标签</span></a></li><li><a href=https://Sattiluvcat.github.io/en/lulu/ title=😽Lulu><span>😽Lulu</span></a></li><li><a href=https://Sattiluvcat.github.io/en/archives/ title=📅时间轴><span>📅时间轴</span></a></li><li><a href=https://Sattiluvcat.github.io/en/about/ title=😎关于><span>😎关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Sattiluvcat.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/>文章</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/notes/>Notes📓</a></div><h1 class="post-title entry-hint-parent">八股——Java</h1><div class=post-meta><span title='2025-01-11 16:43:40 +0800 +0800'>2025-01-11</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;<span title='Last updated 2025-03-22 18:58:40 +0800 +0800'>Last updated on 2025-03-22</span>&nbsp;·&nbsp;Satti</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a><ul><li><a href=#%e6%a6%82%e5%bf%b5 aria-label=概念>概念</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=数据类型>数据类型</a></li><li><a href=#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1 aria-label=面向对象>面向对象</a></li><li><a href=#%e6%8b%b7%e8%b4%9d aria-label=拷贝>拷贝</a></li><li><a href=#%e7%89%b9%e6%80%a7 aria-label=特性>特性</a><ul><li><a href=#%e6%b3%9b%e5%9e%8b aria-label=泛型>泛型</a></li><li><a href=#%e5%8f%8d%e5%b0%84 aria-label=反射>反射</a></li><li><a href=#%e6%b3%a8%e8%a7%a3 aria-label=注解>注解</a></li></ul></li><li><a href=#%e5%af%b9%e8%b1%a1 aria-label=对象>对象</a></li><li><a href=#%e5%bc%82%e5%b8%b8 aria-label=异常>异常</a></li><li><a href=#java18%e6%96%b0%e7%89%b9%e6%80%a7stream--completablefuture aria-label="Java1.8新特性——Stream & completableFuture">Java1.8新特性——Stream & completableFuture</a></li><li><a href=#%e5%ba%8f%e5%88%97%e5%8c%96 aria-label=序列化>序列化</a></li><li><a href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=设计模式>设计模式</a></li><li><a href=#io aria-label=I/O>I/O</a></li><li><a href=#%e7%89%b9%e6%ae%8a aria-label=特殊>特殊</a></li></ul></li><li><a href=#%e9%9b%86%e5%90%88 aria-label=集合>集合</a><ul><li><a href=#%e6%80%bb%e4%bd%93%e6%a6%82%e5%bf%b5 aria-label=总体概念>总体概念</a></li><li><a href=#list aria-label=List>List</a></li><li><a href=#map aria-label=Map>Map</a></li><li><a href=#set aria-label=Set>Set</a></li></ul></li><li><a href=#%e5%b9%b6%e5%8f%91 aria-label=并发>并发</a></li><li><a href=#%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label=虚拟机>虚拟机</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p> </p><p> </p><h2 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h2><h3 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h3><ol><li>Java特点：<ul><li>平台无关性——编译器将源代码翻译为字节码，字节码可在任何安装了JVM（java虚拟机）的系统上运行</li><li>面向对象——strictly OOP，易于维护与重用（类、对象、继承、多态、抽象与封装）</li><li>内存管理——有自己的垃圾回收机制，自动管理内存和回收不再使用的对象</li></ul></li><li>为什么Java是跨平台的？<ul><li>Java程序经过<strong>编译</strong>后形成<strong>字节码</strong>（.class）文件，不同平台通过<strong>不同版本的JVM</strong>将字节码文件翻译为<strong>机器码</strong>后运行</li></ul></li><li>JVM/JDK/JRE关系<ul><li>JVM-java虚拟机，将字节码解释/编译为机器码并执行。提供内存管理、垃圾回收、安全性等功能</li><li>JRE-java运行的环境（需要的最小环境），包含JVM与一组Java类库。不包含开发工具</li><li>JDK-java开发工具包，包含JVM、**<em>编译器（javac）、调试器（jdb）</em>**等开发工具与类库。提供开发、编译、调试与运行的全部工具与环境</li></ul></li><li>编译与解释共存？<ul><li>编译型：Java 源代码通过 javac 编译器编译成字节码，而非机器码 &ndash;> 平台无关性</li><li>解释型：JVM 通过解释器将字节码逐行翻译成机器码并执行 &ndash;> 即时编译JIT<ul><li>JIT：将<strong>热点代码</strong>（方法调用计数器计数确定）<strong>直接编译</strong>为机器码，后续执行时无需再次解释</li></ul></li></ul></li><li>编译和解释型的区别？<ul><li>编译型：程序<strong>执行前</strong>，<strong>整个</strong>源代码被编译为机器码/字节码，生成可执行文件 &ndash;> 速度快 but 跨平台性差</li><li>解释型：程序<strong>执行时</strong>，<strong>逐行</strong>解释执行源代码（解释器动态解释），不生成独立的可执行文件 &ndash;> 速度慢 but 可跨平台</li></ul></li></ol><h3 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h3><ol><li>基本数据类型：<ul><li>1字节；byte, boolean | 2字节：short, char | 4字节：int, float | 8字节：double, long</li><li>包装类：Character & Integer & 首字母大写</li><li>char无符号，不可为负，故从0开始</li></ul></li><li>类型转换：<ul><li>隐式转换（自动）</li><li>显式转换（强制）</li><li>字符串转换：如字符串转为 <code>int</code> ，可用 <code>Integer.parseInt()</code></li><li>数值间转换：整型 &lt;==> 字符型，可用包装类的工具方法实现（如<code>Character</code>类、<code>Integer</code>类）</li></ul></li><li>类型转换的问题：<ul><li>数据丢失：范围大类型到范围小类型。如 <code>long</code> 到 <code>int</code>，会截断保留低位</li><li>数据溢出：范围小类型到范围大类型。会填充高位，原数据不变</li><li>精度损失：浮点数类型的转换 &ndash;> 表示方式不同，<code>double</code>（高精度） 转 <code>float</code> 可能损失精度</li><li>类型不匹配</li></ul></li><li>BigDecimal vs double<ul><li>double会精度丢失 &ndash;> 二进制浮点运算，有时不能准确表示小数（如0.1）</li><li>BigDecimal精确计算，注意用字符串创建新对象，不用浮点 &ndash;> <code>BigDecimal num1 = new BigDecimal("0.1");</code></li></ul></li><li>装箱、拆箱<ul><li>自动装箱happens when：<ul><li>赋值（Java1.5后自动）：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// before Java1.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Integer</span><span class=w> </span><span class=n>iObject</span><span class=o>=</span><span class=n>Integer</span><span class=p>.</span><span class=na>valueof</span><span class=p>(</span><span class=n>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=o>=</span><span class=n>iObject</span><span class=p>.</span><span class=na>intValue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// after Java1.5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Integer</span><span class=w> </span><span class=n>iObject</span><span class=o>=</span><span class=n>3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=o>=</span><span class=n>iObject</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ul><li>方法调用：实质也是赋值，将int与Integer颠倒使用</li></ul></li><li>自动装箱弊端：循环中自动装箱（颠倒使用时），会创建大量无用对象 & 垃圾回收工作量大</li></ul></li><li>Why Java has Integer?<ul><li>前提：Integer是int类型的包装类，把int类型包装成Object<strong>对象</strong>，即对象封装</li><li>作用：<ul><li>泛型：Java中，<strong>泛型只能使用引用类型</strong>，而不能使用基本类型。如列表只能用<code>List&lt;Integer></code><ul><li>泛型允许在定义类、接口或方法时使用类型参数（如<code>Box&lt;T></code>），使用时再指定具体类型</li></ul></li><li><strong><em>转换</em></strong>：Java中，基本类型和引用类型不能直接进行转换，必用包装类。如int转String（转为<code>Integer</code>后<code>.toString()</code>）</li><li>集合：Java集合只能存储对象</li></ul></li></ul></li><li>Integer相比int优点（区别）？<ul><li>基本类型 vs 引用类型：基本类型不需实例化即可使用 ==> int存储一个整数不需额外的内存分配（性能更快），Integer要为对象分配内存<ul><li>引用类型，对象的引用和对象本身分开存储；基本类型，变量对应的内存块存储数据自身</li><li>So：基本类型读写效率、内存效率更高</li></ul></li><li>自动拆装箱</li><li><strong><em>空指针异常</em></strong>：Integer变量必须通过<strong>实例化</strong>对象来赋值，若其未经初始化会出现空指针异常（int默认赋0）</li></ul></li><li>Integer的缓存<ul><li>实现静态缓存池（默认存储-128~127），通过Integer.valueOf(int)方法创建该范围内的对象时，会复用缓存中的现有对象（from内存）</li></ul></li></ol><h3 id=面向对象>面向对象<a hidden class=anchor aria-hidden=true href=#面向对象>#</a></h3><ol><li>面向对象是什么？与特性<ul><li>OOP：编程范式，将现实世界中的事物抽象为对象，对象具有字段（属性）与方法（行为）。具有灵活性与可拓展性</li><li>特性：<ul><li>封装：将对象的属性（数据）和行为（方法）结合，仅用接口与外界交互。&ndash;>增强安全性和简化编程，使对象更独立</li><li>继承：使子类可自动共享父类数据结构和方法，代码复用。&ndash;>建立类与类间的层次关系，结构更清晰</li><li>多态：允许不同类的对象对同一消息作出响应，即同一个接口，使用不同实例而执行不同操作。编译时多态（重载）和运行时多态（重写）&ndash;>灵活性与拓展性</li></ul></li></ul></li><li>多态体现？<ul><li>方法重载：同一类中可以有多个同名方法，但<strong>参数列表不同</strong>。<strong>编译器</strong>确定调用哪个方法</li><li>方法重写：子类能够提供对父类中同名方法的具体实现（不同子类可以实现不同，但<strong>参数不变</strong>）。<strong>JVM</strong>在运行时根据对象实际类型确定调用哪个方法</li><li>接口与实现：多个类可以实现同一个接口，并用接口类型的引用来调用这些类的方法<ul><li>如<code>Dog</code>是<code>Animal</code>的实现类，创建实例时用：<code>Animal dog=new Dog();</code>（<code>dog</code>是<code>Dog</code>类的实例，<code>Animal</code>是<code>dog</code>的接口类型）</li></ul></li><li>向上/下转型：子类父类共有方法可用向上转型调用，子类特有方法需要父类对象向下转型后调用<ul><li>（向上转型）子类对象转换为父类对象，自动进行（如<code>Animal dog=new Dog();</code>）</li><li>（向下转型）父类对象转换为子类对象，执行前需确认引用实际指向的对象，避免<code>ClassCastException</code></li></ul></li></ul></li><li>多态作用<ul><li>meaning：子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。需要继承、接口类等语法机制</li><li>作用：提高代码的扩展性和复用性。</li></ul></li><li>OOP的设计原则<ul><li>单一职责原则SRP：一个类应该只负责一项职责</li><li>开放封闭原则OCP：软件实体应该对扩展（entends，子类）开放，对修改封闭。（即可以继承这个类，但不能修改类本身）</li><li>里氏替换原则LSP：子类对象应该能够替换掉所有父类对象。（不改变父类预期行为等）</li><li>接口隔离原则ISP：客户端不应该依赖那些它不需要的接口</li><li>依赖倒置原则DIP：高层模块不应该依赖低层模块，二者都应该依赖于抽象</li><li>最少知识原则：一个对象应当对其他对象有最少的了解</li></ul></li><li>抽象类与普通类区别<ul><li>实例化：抽象类不能被实例化，只能被继承</li><li>方法实现：抽象类中的方法可以有实现也可以没有实现</li><li>继承：一个类只能继承一个类（any），但可继承（普通类）/实现（抽象类）多个<strong>接口</strong></li><li>限制：普通类可以被其他类继承&使用，抽象类一般用作基类</li></ul></li><li>抽象类 vs 接口<ul><li>二者特点：<ul><li>抽象类：可以有成员变量、构造方法和具体方法&ndash;>适用继承关系</li><li>接口：可以多实现，只能有<strong>常量和抽象方法</strong>（无构造方法）（Java8后可以有默认方法与静态方法&ndash;>定义行为规范与类的功能</li></ul></li><li>区别：<ul><li>实现：接口用<code>implements</code>，抽象类用<code>extends</code>，一个类多接口单抽象类</li><li>方法：接口<strong>不能有方法的实现</strong>，java8中可定义default方法体。抽象类无限制</li><li>访问修饰符：<ul><li>接口成员变量默认<strong>public static final</strong>，必须赋初值不能被修改（final特性），所有成员方法都是<strong>public、abstract</strong>的</li><li>抽象类中成员变量默认<strong>default</strong>，可被子类重新定义or赋值，抽象方法被abstract修饰，<strong>不能被private、static、synchronized和native等修饰</strong>，<strong>必须以分号结尾</strong>，不带花括号</li></ul></li><li>变量：接口只能包含（静态）常量；抽象类可包含实例变量与静态常量</li></ul></li></ul></li><li>抽象类可加final吗？<ul><li>no。抽象类是被继承的，final禁止类的继承 or 方法重写</li></ul></li><li>接口可以定义什么方法？<ul><li>抽象方法：核心，所有实现接口的类必须实现这些方法</li><li>默认方法：允许接口<strong>提供具体实现</strong>。实现类<strong>可以重写</strong>默认方法</li><li>静态方法：属于接口本身，可以<strong>通过接口名直接调用</strong>，不需实现类的对象</li><li>私有方法：Java9引入。为默认/私有方法提供辅助功能</li></ul></li><li>抽象类可以被实例化吗？<ul><li>自身不能被实例化&ndash;>不能直接new一个对象。但可以有构造器，创建子类实例时间接使用（不需指定<code>super</code>，先调用父类构造器，后调用子类构造器）</li></ul></li><li>静态变量与静态方法<ul><li>静态变量：属于类而非具体的对象<ul><li>共享性：<strong>所有该类的实例共享</strong>同一个静态变量。一个实例修改，其它实例均知晓</li><li>初始化：在<strong>类被加载时初始化</strong>，只分配一次内存</li><li>访问方式：可以直接通过类名访问，也可以通过实例访问（建议类名）</li></ul></li><li>静态方法：<ul><li>无实例依赖：可在没有创建类实例的情况下调用，<strong>不能直接访问非静态</strong>的成员变量 or 方法（因为无上下文的实例）</li><li>直接访问静态成员</li><li>多态性：<strong>不支持重写</strong>，可以被<code>Hide</code></li></ul></li><li>使用场景：<ul><li>静态变量：需要在所有对象间共享的数据，如计数器、常量等</li><li>静态方法：常用于助手方法（utility methods）获取类级别的信息或者是没有依赖于实例的数据处理</li></ul></li></ul></li><li>非静态内部类与静态内部类区别（以下只列出非静态特点）<ul><li>外部类实例的依赖</li><li>访问外部类的变量、方法</li><li>不能定义静态成员</li><li>不能独立实例化</li><li>可以访问外部类的私有成员</li></ul></li><li>非静态内部类怎么直接访问外部方法<ul><li>编译器在生成字节码时会为非静态内部类维护一个指向<strong>外部类实例</strong>的引用。生成非静态内部类的构造方法时，将外部类实例作为参数传入</li></ul></li><li>父类、子类的静态方法，在new子类对象时的加载顺序<ul><li>父类静态&ndash;>子类静态&ndash;>父类构造器&ndash;>子类构造器</li></ul></li></ol><h3 id=拷贝>拷贝<a hidden class=anchor aria-hidden=true href=#拷贝>#</a></h3><ol><li>深浅拷贝：<ul><li>浅拷贝：只复制对象本身和其内部的值类型字段，不复制对象内部的引用类型字段&ndash;>共享引用</li><li>深拷贝：将对象内部的所有引用类型字段的内容也复制（完全独立）</li></ul></li><li>实现深拷贝的方法：<ul><li>实现 Cloneable 接口并重写 clone() 方法：要求对象及其所有引用类型字段都实现接口并重写方法（clone()通过<strong>递归克隆</strong>实现深拷贝）</li><li>序列化与反序列化：对象序列化为字节流，再从字节流反序列化为对象&ndash;>要求对象与引用类型都实现 Serializable 接口</li><li>手动递归复制：对象及引用类型字段<ul><li>如List里<code>new AyyayList&lt;>(list)</code></li></ul></li></ul></li></ol><h3 id=特性>特性<a hidden class=anchor aria-hidden=true href=#特性>#</a></h3><h4 id=泛型>泛型<a hidden class=anchor aria-hidden=true href=#泛型>#</a></h4><ol><li>什么是泛型<ul><li>允许类、接口和方法在定义时使用一个或多个类型参数，使用时类型参数可以被指定为具体的类型</li></ul></li><li>why need 泛型<ul><li>适用于多种数据类型执行相同的代码&ndash;>代码复用</li><li>泛型中的类型在使用时指定，不需要强制类型转换（如：不指定时，取出时需转换）&ndash;>保证类型安全，编译器来检查</li></ul></li></ol><h4 id=反射>反射<a hidden class=anchor aria-hidden=true href=#反射>#</a></h4><blockquote><p>需要开发者调用某些方法实现，Spring底层大量使用反射（有涉及反射的相关代码）</p></blockquote><ol><li>什么是反射<ul><li><strong>运行</strong>时，对于任意一个类，都能够知道这个类中的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性。动态获取的信息以及动态调用对象的方法的功能==>反射机制</li></ul></li><li>特性<ul><li>运行时类信息访问——完整信息，父类、接口、包名、构造函数、方法、字段</li><li>动态对象创建——反射API动态地创建对象实例，即使在编译时不知道具体的类名（newInstance()）</li><li>动态方法调用——运行时动态地调用对象的方法，包括私有方法（<code>Method</code>类地<code>invoke()</code>方法）</li><li>访问与修改字段值——允许程序在运行时访问和修改对象的字段值，即使是私有的（<code>Field</code>类的<code>get()/set()</code>方法）</li></ul></li><li>应用场景<ul><li>加载数据库驱动</li><li>配置文件加载——IOC加载Bean<ul><li>将所有XML或properties配置文件夹载入内存&ndash;>解析其内容，得到对应实体类的 <em>字节码字符串</em> 等&ndash;>利用反射，根据字符串得到类的实例&ndash;>动态配置实例属性</li></ul></li></ul></li></ol><h4 id=注解>注解<a hidden class=anchor aria-hidden=true href=#注解>#</a></h4><ol><li>注解原理<ul><li>本质是一个继承了Annotation接口的<strong>接口</strong>，实现类是Java运行时生成的动态代理类（用这个类存储注解中的属性等，调用注解方法时，代理类返回存储的值）</li></ul></li><li>注解作用域Scope<ul><li>类级别、方法级别、字段级别、（构造函数作用域、局部变量作用域）</li><li>可以指定属性，如访问级别、注释等</li></ul></li></ol><h3 id=对象>对象<a hidden class=anchor aria-hidden=true href=#对象>#</a></h3><ol><li>创建对象的方式<ul><li>new</li><li><code>Class</code>或<code>Constructor</code>类的<code>newInstance()</code>方法（即反射机制）</li><li><code>clone()</code> & 反序列化（即深拷贝）<ul><li><code>clone()</code>要实现<code>Cloneable</code>接口，反序列化（类）要实现<code>Serializable</code>接口</li></ul></li></ul></li><li>new的对象什么时候回收<ul><li>垃圾回收器回收，回收时机取决于：<ul><li>引用计数法：某对象的引用计数为0时==>不再被引用</li><li>可达性分析算法：从根对象出发，通过对象的引用链遍历，拖不存在到达某对象的引用链&ndash;>回收</li><li>终结器：重写<code>finalize()</code>方法的对象，回收对象前会调用该方法</li></ul></li></ul></li></ol><h3 id=异常>异常<a hidden class=anchor aria-hidden=true href=#异常>#</a></h3><ol><li>哪些异常<ul><li>基于Throwable及其子类，子类包括<code>Error</code>与<code>Exception</code></li><li>Error：表示运行时环境的错误，程序无法处理。如<code>StackOverFlowError</code></li><li>Exception：<ul><li>非运行时异常：必须编译时捕获或抛出，一般为外部错误。如<code>FileNotFoundException</code></li><li>运行时异常：程序错误导致。如<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundException</code></li></ul></li></ul></li><li>异常处理<ul><li>try-catch-finally：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=k>try</span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception1</span><span class=w> </span><span class=n>e1</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 处理第一类异常的逻辑，比如👇</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Exception1</span><span class=p>(</span><span class=s>&#34;Exception Happend!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception2</span><span class=w> </span><span class=n>e2</span><span class=p>){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 可选，定义无论有否异常都要执行的代码块</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 一般用于资源释放</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>throws：方法中声明可能抛出的异常类型，将异常传递给调用者处理</li></ul></li><li>try与finally，return哪一个<ul><li>返回finally中的return值&ndash;>try中的返回值暂存，执行finally，最终try的结果被覆盖</li></ul></li></ol><h3 id=java18新特性stream--completablefuture>Java1.8新特性——Stream & completableFuture<a hidden class=anchor aria-hidden=true href=#java18新特性stream--completablefuture>#</a></h3><ol><li>Java的stream API<ul><li>提供高效且易于使用的数据处理方式，特别适合集合对象的操作，如过滤、映射、排序等。</li><li>提高代码的可读性和简洁性，还能利用多核处理器的优势进行<strong>并行</strong>处理</li></ul></li><li>stream API案例<ul><li>过滤</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>ans</span><span class=o>=</span><span class=n>list</span><span class=p>.</span><span class=na>stream</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                     </span><span class=p>.</span><span class=na>filter</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>length</span><span class=p>()</span><span class=o>&gt;</span><span class=n>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                     </span><span class=p>.</span><span class=na>collect</span><span class=p>(</span><span class=n>Collectors</span><span class=p>.</span><span class=na>toList</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></div><ul><li>求和</li></ul></li><li>stream流的并行API是什么<ul><li>ParallelStream。将源数据fork为多个子流进行多线程操作，处理结果join为一个流对象&ndash;>底层为通用的fork/join池</li></ul></li></ol><h3 id=序列化>序列化<a hidden class=anchor aria-hidden=true href=#序列化>#</a></h3><ol><li>怎么把一个对象从一个jvm转移到其它jvm<ul><li>序列化与反序列化：字节流</li><li>消息传递机制：消息队列/网络套接字通信，需自定协议来序列化对象</li><li>远程方法调用（RPC）</li><li>共享数据库或缓存</li></ul></li><li>Java默认序列化的缺点<blockquote><p>主流序列化框架：Protobuf、FastJson</p></blockquote><ul><li>无法跨语言：序列化框架与协议其他语言没有实现</li><li>易被攻击：反序列化通过<code>ObjectInputStream</code>上调用<code>readObject()</code>进行，可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化&ndash;>可执行任意类型的代码</li><li>序列化后流太大：二进制数组越大，占用空间越多</li></ul></li><li>具体怎么转对象为二进制字节流<ul><li>序列化用<code>ObjectOutPutStream</code>的<code>writeObject</code>，获取输出流，可写入二进制文件中，创建输入流并读取对象进行反序列化</li><li>需要确保类实现了Serializable接口，并且所有成员变量都是Serializable的（原生类型如int自动支持，其它引用类型需要实现该接口）</li></ul></li></ol><h3 id=设计模式>设计模式<a hidden class=anchor aria-hidden=true href=#设计模式>#</a></h3><ol><li>代理模式和适配器模式的区别<ul><li>目的：代理模式关注控制对对象的访问，适配器用于接口转换，使不兼容的类能一起工作</li><li>结构：代理一般包含抽象主题、真是主题和代理三个角色，适配器模式包含目标接口、适配器和被适配者三个角色</li><li>应用场景：代理模式常用于添加额外功能或控制对对象的访问，适配器模式常用于让不兼容的接口协同工作</li></ul></li></ol><h3 id=io>I/O<a hidden class=anchor aria-hidden=true href=#io>#</a></h3><ol><li>Java怎么实现网络IO高并发编程<ul><li>Java NIO&ndash;>同步非阻塞IO模型，基于IO多路复用实现</li></ul></li><li>NIO、BIO、AIO<ul><li>BIO：blocking IO，基于流模型，同步阻塞交互&ndash;>一个线程处理一个IO</li><li>NIO：non-blocking IO，Java1.4引入，多路复用，同步非阻塞</li><li>AIO：asynchronous IO，Java1.7引入，异步非阻塞</li></ul></li><li>NIO实现<blockquote><p>用到NIO的框架&ndash;>Netty</p></blockquote><ul><li>同步核心为Selector，代替线程本身的轮询IO事件</li></ul></li></ol><h3 id=特殊>特殊<a hidden class=anchor aria-hidden=true href=#特殊>#</a></h3><ol><li>==与equals的区别<ul><li>重写了<code>equals</code>的类：<code>==</code>比较内存的首地址（即是否指向同个对象），<code>equals</code>比较内容<ul><li>如<strong>String、包装类与List、Set集合</strong>类</li></ul></li><li>使用<code>Object.equals()</code>的类：都比较内存首地址</li></ul></li><li>native方法<ul><li>允许Java调用外部的本地代码，如Cpp代码。native是一种声明，标记方法的实现在外部定义</li><li>实现native方法需要：JNI头文件生成（C/Cpp的头文件）&ndash;>本地代码实现&ndash;>编译本地代码（动态链接库on Win或共享库 on Linux）&ndash;>加载本地库，JVM调用native方法的实现</li></ul></li><li>排序<ul><li>实现<code>Comparable</code>接口，重写<code>compareTo</code>方法</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Students</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Comparable</span><span class=o>&lt;</span><span class=n>Student</span><span class=o>&gt;</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>score</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 略</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>compareTo</span><span class=p>(</span><span class=n>Student</span><span class=w> </span><span class=n>other</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>score</span><span class=o>!=</span><span class=n>other</span><span class=p>.</span><span class=na>score</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>compare</span><span class=p>(</span><span class=n>other</span><span class=p>.</span><span class=na>score</span><span class=p>,</span><span class=k>this</span><span class=p>.</span><span class=na>score</span><span class=p>);</span><span class=w>   </span><span class=c1>// 降序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>else</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>compare</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>id</span><span class=p>,</span><span class=n>other</span><span class=p>.</span><span class=na>id</span><span class=p>);</span><span class=w>  </span><span class=c1>// 升序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ol><h2 id=集合>集合<a hidden class=anchor aria-hidden=true href=#集合>#</a></h2><h3 id=总体概念>总体概念<a hidden class=anchor aria-hidden=true href=#总体概念>#</a></h3><ol><li>数组与集合的区别<ul><li>数组定长，集合动态长度</li><li>数组可以包含基本类型与对象（引用类型），集合仅对象</li><li>数组可以直接访问元素，集合需要迭代器等方法访问</li></ul></li><li>哪些集合<ul><li><strong>List</strong>——有序Collection，常用实现类有LinkedList、ArrayList、Vector、Stack</li><li>ArrayList：<strong>线程不安全</strong>，底层使用<strong>数组</strong>（扩容时创建更大数组后复制）。支持快速随机访问元素，插入删除慢</li><li>LinkedList：底层<strong>双向链表</strong>，插入删除快，访问慢</li><li><strong>Map</strong>——键值对集合，没继承Collection接口。主要实现TreeMap、HashMap、HashTable、LinkedHashMap、ConcurrentHashMap<ul><li>HashMap<ul><li>哈希原本的存储结构即数组。<strong>解决哈希冲突的方法</strong>&ndash;><strong>放的地方变多</strong>【开放地址（线性探测，向后放一位，注意取模 & 二次探测，向前后走i^2位）、建立溢出区】/<strong>算的方法变多</strong>（多个哈希函数计算直到不冲突）</li></ul></li><li>LinkedHashMap：继承HashMap，在其基础上增加了双向链表，保持插入顺序</li><li>HashTable：数组+链表，线程安全&ndash;>每个方法加<code>synchronized</code></li><li>TreeMap：红黑树</li><li>ConcurrentHashMap：数组+链表+红黑树，线程安全</li></ul></li><li><strong>Set</strong>——元素不重复、无序，常用实现HashSet、LinkedHashSet、TreeSet</li><li>HashSet：通过HashMap实现。key存元素，value统一==>不有序&线程不安全（HashMap）</li><li>LinkedHashSet：HashSet子类，通过LinkedHashMap实现，<strong>双向链表</strong>维护元素插入顺序</li><li>TreeSet：TreeMap实现。添加元素时按比较规则插入到合适的位置，保证集合有序</li></ul></li><li>线程安全的集合？<ul><li>线程安全的类：<ul><li>Vector&ndash;>内部方法基本都加<code>synchronized</code></li><li>HashTable&ndash;>每个公共方法加<code>synchronized</code>（仅单线程操作），不支持null键和值==>不建议用</li></ul></li><li><strong>并发Map</strong>（<code>java.util.concurrent</code>）：<ul><li>ConcurrentHashMap。JDK1.8取消segment，对每一行加锁</li><li>ConcurrentSkipListMap：基于跳表</li></ul></li><li><strong>并发Set</strong>（包同上）：<ul><li>ConcurrentSkipListSet：有序集合，底层ConcurrentSkipListMap</li><li>CopyOnWriteArraySet：无序集合==>线程安全的HashSet</li></ul></li><li><strong>并发List</strong>（同上）：<ul><li>CopyOnWriteArrayList：写时复制（写的时候加Lock锁，复制数组，期间其它线程读旧数组，写完指向新数组）</li></ul></li><li><strong>并发Queue</strong>：<ul><li>ConcurrentLinkedQueue：适用高并发，使用CAS</li><li>BlockingQueue：简化数据共享&ndash;>读写阻塞等待（没数据了还要读，该线程就一直等待）</li></ul></li><li><strong>并发Deque</strong>：<ul><li>LinkedBlockingDeque：每个节点维护前驱和后驱节点，没有读写锁分离，同一时间允许一个线程操作</li><li>ConcurrentLinkedDeque：</li></ul></li></ul></li><li>Collections和Collection的区别<ul><li>Collection是所有集合类的基础接口</li><li>Collections是工具类，提供静态方法</li></ul></li><li>遍历集合的方法：<ul><li>for / for-each（增强for循环）</li><li>Iterator迭代器 / ListIterator列表迭代器（迭代器的子类）</li><li>forEach：<code>list.forEach(element -> System.out.println(element));</code></li><li>Stream API：<code>list.stream().forEach(element -> System.out.println(element));</code></li></ul></li><li>可能产生<code>ConcurrentModificationException</code>的情况<ul><li>检测到集合内部结构在遍历时被修改，立刻抛出</li><li>如：迭代器中（包括<code>Iterator</code>和增强for&ndash;>底层为迭代器）调用集合方法<code>remove</code>/<code>set</code>&ndash;>应用迭代器的<code>remove</code>/<code>set</code></li><li>建议用线程安全的实现类</li></ul></li></ol><h3 id=list>List<a hidden class=anchor aria-hidden=true href=#list>#</a></h3><ol><li>常见实现与不同<ul><li>Vector、ArrayList、LinkedList（CopyOnWriteArrayList···）</li><li>Vector 与 ArrayList 为动态数组，Vector线程安全，都适合随机读取</li><li>LinkedList适合增删</li></ul></li><li>删除指定元素的时间复杂度<ul><li>ArrayList&ndash;>O(n)，该元素后面的所有元素都要挪动==>最后一位可以直接删</li><li>LinkedList&ndash;>O(n)，要顺序定位，首尾不用</li><li>CopyOnWriteArrayList&ndash;>写时可以读，并发性能好</li></ul></li><li>ArrayList变成线程安全的方法<ul><li>用Collections类的synchronizedList方法包装ArrayList</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>sycList</span><span class=o>=</span><span class=n>Collections</span><span class=p>.</span><span class=na>synchronizedList</span><span class=p>(</span><span class=n>list</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><ul><li>用Vector或CopyOnWriteArrayList代替</li></ul></li><li>为什么ArrayList线程不安全<ul><li>问题：部分值为null & 索引越界 & size与add数量不符</li><li>底层：以add为例</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>add</span><span class=p>(</span><span class=n>E</span><span class=w> </span><span class=n>e</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>ensureCapacityIntenal</span><span class=p>(</span><span class=n>size</span><span class=o>+</span><span class=n>1</span><span class=p>);</span><span class=w>   </span><span class=c1>// 判断数组大小是否足够，不够就扩容</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>elementData</span><span class=o>[</span><span class=n>size</span><span class=o>++]=</span><span class=n>e</span><span class=p>;</span><span class=w>  </span><span class=c1>// （实际大小已经至少是size+1了）size位赋为e，size+1（仅记录数组长度，与实际长度不同时变）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>分析：线程1发现size为9，容量为10（不用扩），线程2发现size为9，容量为10（不用扩）<ul><li>1设置index为9的位，2设置index为9的位，1令size++，2令size++==>index为10的位为null</li><li>1设置index为9的位，1令size++，2设置index为10（此时的size）的位==>索引越界</li><li>==>size与add的数量不符</li></ul></li></ul></li><li>ArrayList的扩容机制<ul><li>计算新容量==>一般为1.5倍（因为用移位算，速度快，<code>newSize=oldSize+(oldSize>>1)</code>）</li><li>创建新数组&ndash;>复制元素&ndash;>更新引用&ndash;>完成扩容</li></ul></li><li>CopyOnWriteArrayList如何保证线程安全<ul><li>底层是用volatile修饰的数组：<code>private transient volatile Object[] array;</code></li><li>写入时加互斥锁ReentrantLock&ndash;>拷贝到长度加1的新数组&ndash;>新数组放入新值&ndash;>替换引用&ndash;><code>finally</code>释放锁</li></ul></li></ol><h3 id=map>Map<a hidden class=anchor aria-hidden=true href=#map>#</a></h3><ol><li>Map遍历方法<ul><li>entryset：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// 也可以用 keySet()，只得到 key 的集</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=p>(</span><span class=n>Map</span><span class=p>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>entry</span><span class=p>:</span><span class=n>map</span><span class=p>.</span><span class=na>entrySet</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=kt>int</span><span class=w> </span><span class=n>key</span><span class=o>=</span><span class=n>entry</span><span class=p>.</span><span class=na>getKey</span><span class=p>(),</span><span class=n>val</span><span class=o>=</span><span class=n>entry</span><span class=p>.</span><span class=na>getValue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>迭代器&ndash;>适合迭代删除</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=n>Iterator</span><span class=o>&lt;</span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=n>Integer</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>iterator</span><span class=o>=</span><span class=n>map</span><span class=p>.</span><span class=na>entrySet</span><span class=p>().</span><span class=na>iterator</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=na>hasNext</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>entry</span><span class=o>=</span><span class=n>iterator</span><span class=p>.</span><span class=na>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>lambda表达式+forEach方法==><code>map.forEach((key,value)->key=key+1)</code></li><li>stream API</li></ul></li><li>HashMap底层原理<ul><li>JDK1.7前为数组+链表（解决hash冲突）&ndash;>JDK1.8链表长度超过8且数组长度大于64转用红黑树（n&ndash;>log(n)）</li></ul></li><li>HashMap线程安全吗<ul><li>否。问题有：JDK1.7前数组扩容时可能Entry链死循环/数据丢失&ndash;>JDK1.8 put时数据覆盖<ul><li>死循环：<strong>头插法</strong>，扩容时旧链表节点被<strong>逆序</strong>转移到新链表（旧链表按顺序读取节点，继续头插法插入新链表）&ndash;>当线程B完成复制，线程A开始复制时，</li></ul></li><li>解决方案：(Collections.synchronizedMap同步加锁)/HashTable/ConcurrentHashMap</li></ul></li><li>put的过程<ul><li>计算索引&ndash;>检查空否&ndash;>（非空）检查key是否相同（<code>hashCode</code>同&&<code>equals</code>）（同则直接更新）&ndash;>（不同）链表/红黑树查找，找不到则加入&ndash;>检查链表长度&ndash;>检查负载因子0.75（键值对数量与数组大小的比值）&ndash;>扩容，新建两倍大的数组，重新计算哈希码并插入</li></ul></li><li>HashMap的get方法安全吗<ul><li>空指针异常，but初始化后可以用<code>null</code>作为键</li><li>多线程环境</li></ul></li><li>HashMap一般用什么做key<ul><li>String。不可变，稳定（hashCode与equals方法的正确性）</li></ul></li><li>为什么用红黑树而非平衡二叉树<ul><li>完全平衡要求任何结点的左右子树的高度差不超 1&ndash;>频繁的左右旋</li><li>红黑树只要求整个树最长路径不超最短的两倍&ndash;>不用频繁调整</li></ul></li><li>重写equals和hashCode的注意事项<ul><li><strong>同时重写！</strong> && o1.equals(o2)==>o1.hashCode() == o2.hashCode()（反之不然）</li></ul></li><li>HashMap扩容机制<ul><li>注意：HashMap初始容量为16</li><li>容量一般增为两倍，哈希码与新容量做按位与，若得1则新索引为原索引+原容量（高位赋1，即若新容量为16，则xxx&ndash;>1xxx）；若得0则不变</li><li>所以不用重新算hash，且可以认为均匀地分散节点（0/1随机）</li></ul></li><li>负载因子</li></ol><ul><li>默认0.75，元素个数超过容量的75%就扩容&ndash;>太低会有大量空桶（空间浪费），太高会有大量碰撞（性能不好）</li></ul><ol start=11><li>ConcurrentHashMap怎么实现</li></ol><ul><li>JDK1.7.数组+链表。大数组Segment（即可重入锁<code>ReentrantLock</code>），小数组HashEntry存储键值对&ndash;>一段数据一个锁，其它段数据可被访问，当前段可被读</li><li>JDK1.8.数组+链表/红黑树。（计算哈希值时，通过扰动函数优化哈希分布）volatile+CAS/synchronized&ndash;>添加元素时若容器（map）为空则volatile+CAS初始化，若容器不为空但位置（数组中的位置）空用volatile+CAS初始化，若位置不为空（发生了哈希冲突）用synchronized，遍历数据并替换/新增节点到桶并判断是否需转换<ul><li>对<strong>头结点加（悲观）锁</strong>保证线程安全（类似一行数据） & <strong>CAS为乐观锁，synchronized为悲观锁</strong>&ndash;>发生哈希碰撞时证明线程竞争比较激烈，悲观锁效率更高</li><li>CAS：比较并交换，比较当前要修改的值与线程的预期值是否相等，是则修改，否则重新读值</li><li>Node.val 和 Node.next 声明为 volatile，确保读操作无需加锁</li></ul></li></ul><h3 id=set>Set<a hidden class=anchor aria-hidden=true href=#set>#</a></h3><ol><li>Set为什么无重复<ul><li>根据hashCode确定存储位置，根据equals判断是否有相同元素</li></ul></li><li>有序Set是？记录插入顺序的集合是？<ul><li>TreeSet（红黑树） & LinkedHashSet（<strong>双向</strong>链表）有序<ul><li>TreeSet需要重写<code>compareTo()</code>函数/<code>Comparator</code>比较器，插入或删除时通过该函数进行比较</li></ul></li><li>记录<strong>插入</strong>顺序的集合通常指的是LinkedHashSet（放入链表尾）</li></ul></li></ol><h2 id=并发>并发<a hidden class=anchor aria-hidden=true href=#并发>#</a></h2><h2 id=虚拟机>虚拟机<a hidden class=anchor aria-hidden=true href=#虚拟机>#</a></h2><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></div><footer class=post-footer><ul class=post-tags><li><a href=https://Sattiluvcat.github.io/en/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://Sattiluvcat.github.io/en/posts/notes/shell%E4%BD%BF%E7%94%A8%E5%B0%8Ftrick/><span class=title>« Prev</span><br><span>shell简单使用</span>
</a><a class=next href=https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1--spring/><span class=title>Next »</span><br><span>八股——Spring</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on x" href="https://x.com/intent/tweet/?text=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f&amp;title=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&amp;summary=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&amp;source=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f&title=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on whatsapp" href="https://api.whatsapp.com/send?text=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java%20-%20https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on telegram" href="https://telegram.me/share/url?text=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股——Java on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%85%ab%e8%82%a1%e2%80%94%e2%80%94Java&u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1--java%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://www-sattiluvcat-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><script id=dsq-count-scr src=//www-sattiluvcat-github-io.disqus.com/count.js async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://Sattiluvcat.github.io/en/>Satti's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")</script></body></html>