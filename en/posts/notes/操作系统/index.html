<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><head><script async src="https://www.googletagmanager.com/gtag/js?id=自己的G-MEASUREMENT_ID"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","自己的G-MEASUREMENT_ID")</script></head><title>操作系统OS | Satti's Blog</title><meta name=keywords content="408"><meta name=description content="关于操作系统的学习笔记"><meta name=author content="Satti"><link rel=canonical href=https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/><link crossorigin=anonymous href=/assets/css/stylesheet.af5e671f6a7d21c7f5c73f39af31c43555fd91c98b39460c5187f1f8bccfacdf.css integrity="sha256-r15nH2p9Icf1xz85rzHENVX9kcmLOUYMUYfx+LzPrN8=" rel="preload stylesheet" as=style><link rel=icon type=image/png href=/favicon-48x48.png sizes=48x48><link rel=icon type=image/svg+xml href=/favicon.svg><link rel="shortcut icon" href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta name=apple-mobile-web-app-title content="MyWebSite"><link rel=manifest href=/site.webmanifest><link rel=alternate hreflang=en href=https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script async src="https://www.googletagmanager.com/gtag/js?id=自己的G-MEASUREMENT_ID"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","自己的G-MEASUREMENT_ID")</script><meta property="og:title" content="操作系统OS"><meta property="og:description" content="关于操作系统的学习笔记"><meta property="og:type" content="article"><meta property="og:url" content="https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-28T19:35:56+08:00"><meta property="article:modified_time" content="2024-11-05T19:19:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="操作系统OS"><meta name=twitter:description content="关于操作系统的学习笔记"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://Sattiluvcat.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Notes📓","item":"https://Sattiluvcat.github.io/en/posts/notes/"},{"@type":"ListItem","position":3,"name":"操作系统OS","item":"https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"操作系统OS","name":"操作系统OS","description":"关于操作系统的学习笔记","keywords":[408],"articleBody":" 操作系统 定义 系统资源的管理者\u0026提供方便的接口与环境\u0026最接近硬件的软件\n功能：处理机(CPU)管理\u0026存储器管理\u0026文件管理\u0026设备管理 程序运行 将相关数据从磁盘放入内存 = 存储器 进程被CPU管理 = 处理机 接口\u0026环境 flowchart LR 接口--\u003eGUI 接口--\u003e程序接口 用户接口--\u003e程序接口 用户接口--\u003e脱机命令接口 接口--\u003e命令接口 命令接口--\u003e脱机命令接口 命令接口--\u003e联机命令接口 联机命令接口---交互式命令接口 交互式命令接口--\u003ecmd 批处理--\u003e.bat 脱机命令接口---批处理 GUI 图形化用户接口 硬件拓展 无软件支持的计算机 = 裸机 覆盖了软件 = 扩充机器（虚拟机） 四个特征 并发 共享 是最基本的特征 互为存在条件\n并发 宏观上同时发生 微观上交替（= 同时段发生）\n单核CPU同一时刻只能执行一个程序=并发 多核可以实现并行（同一时刻进行多个程序） 共享 资源共享 系统资源可供内存中多个并发进程共同使用 两种资源共享方式：\n互斥共享 一时段一进程 eg.摄像头 同时共享 一时段多进程 虚拟 物理实体变为逻辑上的对应物\nflowchart LR 虚拟技术--\u003e空分复用技术 虚拟技术--\u003e时分复用技术 空分复用技术--\u003eeg.虚拟存储器 时分复用技术--\u003eeg.虚拟处理器 没有并发性 虚拟性 = 不存在 异步性 多个程序并发 资源有限时进程执行以未知速度推进\n没有并发性 异步性 = 不存在 发展与分类 flowchart TB subgraph 手工操作 缺点1--\u003e独占全机 缺点1--\u003e资源利用率低 资源利用率低--\u003e计算机快\u0026人工慢 end 手工操作--\u003e批处理阶段 subgraph 批处理阶段 subgraph 单道批处理系统 主要结构--\u003e磁带\u0026监督程序 缺点2--\u003e内存中仅能运行一道程序 end 单道批处理系统--\u003e多道批处理系统 subgraph 多道批处理系统 输入计算输出错峰运行 缺点3--\u003e运行过程时不能调试 end end 批处理阶段--\u003e分时操作系统 subgraph 分时操作系统 特点--\u003e以时间片为单位轮流服务用户 优点--\u003e及时响应解决人机交互问题 缺点4--\u003e不能优先处理紧急任务 end 分时操作系统--\u003e实时操作系统 subgraph 实时操作系统 在严格时限内处理事件---可以优先响应 特点1--\u003e及时性\u0026可靠性 分类--\u003e硬实时系统 硬实时系统---严格时限 分类--\u003e软实时系统 软实时系统---偶尔接受迟滞 end 实时操作系统--\u003e网络操作系统 实时操作系统--\u003e分布式操作系统 实时操作系统--\u003e个人计算机操作系统 subgraph 不重要 网络操作系统 分布式操作系统 个人计算机操作系统 end 运行机制 指令 = 机器指令 非cmd\n两种 flowchart LR 内核程序Kernal--\u003e特权指令 应用程序--\u003e非特权指令 特权指令--\u003e内核态 非特权指令--\u003e用户态 内核程序 = 最接近硬件的部分 特权指令 = 管理者操作 内核态/用户态 = CPU状态（用PSW存储状态） PSW 程序状态字寄存器 内核态=核心态=管态 用户态=目态 切换状态：\n内核到用户：特权指令修改PSW 用户到内核：触发中断 硬件自动完成 中断与异常 中断作用 唯一让CPU从用户态变为内核态的途径 = 保障并发\n中断类型 内中断（异常）：中断信号来自CPU内部 当前执行指令\n指令自身非法/遇到特权指令 eg.trap程序引发/fault错误条件 Kernal可能修补/abort致命错误 外中断（中断）：与当前指令无关 eg.时钟中断 eg.I/O中断 基本原理 CPU检测到中断后查询中断向量表 找到中断处理程序的内存位置\n系统调用 一组系统调用组成程序接口\n应用程序通常通过库函数进行系统调用 有些库函数不调用 有些语言直接进行系统调用 eg.汇编语言 向系统内核提出请求对共享资源进行操作 即系统调用 发出trap指令提出请求（用户态） 执行trap后引发内中断进入核心态 体系结构 大/宏内核操作系统：所有内核功能（Linux UNIX等）\neg.进程 存储 设备 + 微内核部分 性能高 内核代码庞大 结构混乱 微内核操作系统：与硬件关系最紧密的功能（Windows NT） eg.时钟管理 中断处理 原语（设备驱动 CPU切换） 优缺点反之 引导 过程 1\nCPU从主存（ = RAM + ROM（BIOS））执行ROM引导程序 将磁盘中主引导记录（MBR）读入内存 执行磁盘引导程序 扫描分区表 从活动分区（主分区）读入分区引导记录（PBR） 执行程序 主分区即安装了操作系统的分区 从根目录找到启动管理器并执行 完成开机🥳 虚拟机 Virtual Machine (VMware \u0026 Virtual Box)\n虚拟机管理程序（VMM monitor）\n第一类VMM 运行在硬件上（CPU 磁盘 内存进行划分） 用户空间分为虚拟用户态\u0026虚拟内核态（但实际均为用户态） 若执行特权指令 由内核中的VMM进行虚拟执行 第二类VMM 运行在宿主操作系统（Host OS）上（如Vmware） VMM大部在用户态 VM驱动部分在内核态 对比：第一类性能更好 可容纳更多虚拟机 运行在最高特权级(Ring 0) 但可迁移性不强 第二类反之 进程管理 进程基础知识 基本 定义 程序：静态 = 指令集合 进程：动态 = 程序的执行过程\n进程组成 PCB（Process Control Block）进程控制块 For操作系统\n进程存在唯一标志 保存：PID UID \u0026 进程控制与管理信息 \u0026 资源分配清单 \u0026 处理机信息 PID（进程ID 唯一不重复） 程序段：程序代码 For进程\n程序运行：程序-\u003e硬盘（exe）-\u003e内存PCB-\u003eCPU取出指令 数据段：运行过程中产生的数据 For进程 进程实体（进程映像）=PCB+程序段+数据段 静态 进程 进程实体的运行过程 动态 特征 动态性：最基本的特征 并发性：内存中有多个进程实体 独立性：获得资源的基本单位 异步性 结构性：每个进程都有一个PCB\n状态与转换 创建态 就绪态 运行态 阻塞态 终止态\n就绪态——等待处理机调度 运行态——占用整个CPU运行 阻塞态——运行态进程请求等待某事件发生 下CPU（进程主动） 事件发生后改为就绪态（被动） 进程的组织 链式：队列指针 索引：索引表指针\n进程控制 实现进程状态转换\n原语实现——具原子性 = 不可中断\n特权指令 关中断指令\u0026开中断指令实现原子性 关中断开启——不再检查中断信号 创建/撤销进程时使用的原语：PCB更新——资源分配——合适的队列\n申请空白PCB——找到对应PCB 为新进程分配资源——若运行 剥夺CPU并分配 初始化PCB——终止所有子进程 PCB插入就绪队列——资源归还并删除PCB 阻塞/唤醒原语——成对使用（因何阻塞必因何唤醒）\n切换进程的原语：将现行运行环境存入PCB\n进程通信IPC 两进程间的数据交互 不同进程的内存地址不重叠 通信需要操作系统支持\n共享存储 设定共享存储区 映射到进程的虚拟地址空间\n互斥访问 由进程自己实现 基于存储区：灵活性高 高级通信 基于数据结构：低级通信 消息传递 消息包括消息头\u0026消息体 操作均由原语完成\n直接通信：两进程明确消息的接收方与发送方 在内存中存储发送了的消息 形成消息队列 间接通信：发到内存中的信箱 另一进程从信箱读取 信箱公用 管道通信 某时段内单向传输（半双工通信） I/O进程不固定数量\n一种共享文件pipe 内存中一个大小固定的内存缓冲区 队列 先进先出 线程与多线程 同个进程中可能有多个线程 程序执行的最小单位（相当于小进程）\n提升并发度 不用切换进程（同进程内线程切换）系统开销小 每个线程有自己的线程ID与TCB线程控制块 几乎不拥有系统资源（来自所属的进程） 通信方便 同进程内不需系统干预 线程实现方式 用户级线程（早期）——由线程库实现\u0026管理 程序实现 与操作系统无关 并发程度很低（阻塞） 1 内核级线程（KTL） 进程与对应的内核级线程都在内核态的操作系统 内核级线程一一管理用户级线程 线程切换管理成本更高 多线程模型 一对一：一内核一用户 多对一：一内核多用户（退化） 多对多：多内核多用户（内核更少） 线程状态与转换 就绪——运行——阻塞 线程组织与控制 TCB(≈PCB)=线程标识符（TID）+程序计数器PC+其他寄存器+堆栈指针+线程运行状态+优先级 调度时保存PC+其他寄存器+堆栈指针 调度 处理机调度 确定处理任务的先后顺序\n三个层次 高级调度（作业调度）——从外存调入内存开始任务 低级调度（进程调度）——最基本 快速 内存到CPU 中级调度（内存调度）——从外存调到内存 从挂起队列调回内存（内存不足） 进程调度时机 不能调度的eg.处理中断 原语 处于内核程序临界区（操作系统内） 可调度eg包括主动与被动 方式： 非抢占方式——反之 抢占方式——更紧急的任务优先执行 当前任务中止 适用分时、实时操作系统 包括：选择进程+进程切换 调度器（调度程序）scheduler与闲逛进程idle 触发调度器eg.创建新进程+进程退出+进程阻塞+I/O中断（maybe唤醒阻塞进程） 抢占式调度：时钟中断触发 非抢占式：only阻塞/退出才触发 闲逛进程idle——优先级最低 占一个完整的指令周期（提醒作用） 调度算法评价指标 CPU利用率=利用时间/总时间 系统吞吐量=单位时间内完成作业的数量 周转时间=作业提交至系统-\u003e作业完成的时间 平均周转时间=各作业周转时间和/作业数 带权周转时间=周转时间/实际运行时间（\u003e=1） 平均带权周转时间=带权和/作业数 等待时间=等待处理机状态时间和 for进程：等待被服务的时间 for作业：建立进程后的等待时间+作业在外存后备队列的等待时间 响应时间=提交请求-\u003e首次响应的时间 调度算法 先来先服务FCFS first come first serve 非抢占式 公平 but 长作业有利 短作业不利 不会饥饿（长期得不到服务） 短作业优先SJF shortest job first——当前已到达 运行时间最短 =短进程优先 非抢占（抢占版为最短剩余时间优先算法SRNT 新达到进程/进程完成时 剩余时间最短者抢占当前进程 SRNT平均等待时间、平均周转时间最少 若所有进程几乎同时到达 SJF平均等待时间、平均周转时间最少 时间短 but 不公平 长作业不利 会饥饿 maybe饿死 高响应比优先HRRN highest response ratio next——每次调度时先计算响应比 响应比同先来先服务 响应比=(等待时间+要求服务时间)/要求服务时间 非抢占式 考虑了要求服务时间 不会饥饿\n（适用于交互式系统的调度算法👇） 时间片轮转RR round-robin——根据到达顺序轮流执行一个时间片 only用于进程调度 可抢占式——时钟中断 公平 but 切换频繁\u0026不区分紧急程度 时间片过大——增大进程响应时间 过小——进程切换过于频繁 不会饥饿 优先级——设置优先级：系统\u003e用户 前台\u003e后台 更偏好I/O型（I/O可以和CPU并行工作） 也可用于I/O 非抢占 有抢占式版本 考虑优先级 but 可能导致饥饿 多级反馈队列——设置多级就绪队列 优先级从高到低 时间片从小到大 规则： 新进程先进第1级队列 FCFS分配时间片 时间片用完还未结束 则进入下级队尾（最下级的就进入本级队尾） k级队列为空时 再为k+1级分配时间片 被抢占的进程进入此队队尾 用于进程调度 抢占式（有非抢占式版本） 相对公平 响应快 短进程完成较快 避免用户作假 灵活调整偏好程度 maybe饥饿 多级队列——按进程类型设置不同优先级 队列间可采取固定优先级/时间片划分 各队列可采用不同调度策略 进程同步 互斥等 进程同步与互斥 进程同步——进程的次序（对抗异步性——未知速度） 进程互斥——临界资源（一时段一程序访问）互斥 进入区（检查可否进入 设置正在访问标志）——临界区——退出区（解除标志）——剩余区 临界区空闲则让进 忙则等待 有限等待——能在有限时间内进入临界区 让权等待 进程互斥的软件实现 单标志法——一个flag=允许进入临界区的进程号 空闲让进不符 双标志先检查法——进程数个flag 表达本进程是否进入临界区 忙则等待不符（检查与上锁不是同时发生） 双标志后检查法——先上锁后检查 空闲让进 有限等待不符 Peterson——自己flag为true \u0026 上其它锁 \u0026 若其它flag为true且上锁则自己while空循环等待 进程互斥硬件实现 中断屏蔽——开/关中断指令实现 简单高效 but 不适用多处理机（only单处理机）\u0026特权指令 TS指令 TestAndSetLock——执行过程不允许中断 1 让权等待不符——无法进入的程序会占用CPU并循环TSL指令 SWAP指令（即XCHG）——类TSL指令 1 互斥锁 主要缺点：忙等 需要连续循环忙等的互斥锁 = 自旋锁 适用多处理机系统 信号量机制 用户进程用一对原语对信号量操作\n信号量：变量（整数/记录型变量） 整型信号量——仅初始化、P、V操作 存在忙等 记录型信号量——灵活使用阻塞态 就绪态等 value表示资源的剩余数量 遵循让权等待 1 1 一对原语：wait(S) signal(S) 简称为P、V操作 必成对出现 信号量机制应用 实现进程互斥——value定为互斥信号量mutex（进入临界区的名额） 初值为1 进程同步——保证操作顺序——设置同步信号量S 初值0（反互斥之道而行之） 先V（进程一结束后）后P（进程二开始前）——V释放资源 P获取资源 前驱关系 PV例题 生产者消费者问题 bg：生产者生产一个产品放入缓冲区 消费者每次取出一个产品 缓冲区有大小限制且为临界资源 PV关系：缓冲区空否——同步信号量（初值为n） 满否——同步信号量（初值为0） 访问——互斥信号量 P操作：互斥信号always在同步信号后（不空/满才访问） V：whatever 多生产多消费者 bg：生产者A生产a 消费者C只要c BD同理 缓冲区仅能放有限数量 PV：互斥——访问 同步——几个a/b（For消费者） 同步——还可以放多少（For生产者） 共4个 若缓冲区大小为1 maybe可以不加互斥信号量 吸烟者 bg：3个抽烟者和1个供应者 卷烟需要3种材料 一抽烟者有1种 供应者每次供应2种 1对应抽烟者拿走 PV：互斥——访问 同步——1 2 3是否卷好 可以省略互斥 读者-写者 bg：共享一个文件 可以多个读 一个写则其它均不可 写时让已有的读与写全部退出 PV：互斥——记录读进程个数（互斥访问计数器） 互斥——写锁 读写锁等 哲学家进餐 bg：圆桌 每人两边各有一只筷子 哲学家要么思考要么进食（需要两只筷子） PV：对筷子设置互斥 无限制会死锁——限制最多四人进餐/… 管程 信号量机制——编写程序困难易出错 =\u003e 引入管程替代PV\n组成≈类（过程≈Java中的方法） 特征：管城内的数据只能被其内部的过程访问 + 只有通过管程的过程才能访问内部的共享数据 + 每次仅有一个进程在管程内执行过程 Java中的类似机制：synchronized 被其 修饰的函数在同一时段内只能被一个线程调用 死锁 概述 概念 死锁：各进程互相等待对方的资源 = 都阻塞 管理者的问题 饥饿：长期得不到资源 某进程无法推进 管理者的问题 死循环：进程执行时跳不出循环 条件 互斥——资源使用互斥 不剥夺——其他进程不能强行夺走资源 请求和保持——已经保持了至少一个资源 但还有请求 循环等待——资源的循环等待链 循环等待时不一定会发生死锁 发生死锁的情况 资源竞争 进程推进顺序非法（请求与释放的顺序不当） 信号量使用不当 = 不可剥夺的资源分配不合理\n处理策略 预防（破坏形成条件） + 避免（防止进入不安全状态） + 检测与解除\n预防死锁（静态策略） 互斥条件破坏——改为共享资源 eg.SPOOLing技术 适用范围窄 不剥夺破坏——请求无法满足时释放所有资源/操作系统将资源强行剥夺 复杂+降低吞吐量+maybe饥饿+只适用易保存回复资源 请求保持破坏——静态分配方法（运行前申请所有资源 不满足则不运行 运行后不请求） 资源利用率低 maybe饥饿 循环等待破坏——顺序资源分配法（资源编号 每个进程按编号递增请求资源 同号一次申请完） 难新增资源+资源浪费+编程麻烦 避免死锁（动态策略） 安全序列：按此序列分配资源则每个进程都能完成 安全 = 一定不死锁 不安全 = 不一定死锁 银行家算法：进程申请时 预判分配会否导致不安全 会则阻塞该进程 安全性算法：根据资源分配循环找安全序列 n个进程 m种资源 = n*m矩阵 =\u003e最大需求矩阵Max n*m的分配矩阵Allocation 最多还需要多少资源Need 长m的一维数组Available表示还有多少可用资源 长m的一维数组Request表示本次申请的各种资源\n不断重复上述步骤 检测与解除 检测：保存资源的请求与分配信息（数据结构）+检测是否死锁（算法） 两种边：请求与分配 最终能消除所有边 = “可完全简化” = 一定没有死锁 死锁定理：若不能消除 = 发生死锁 还连着的边 = 处于死锁[^2]: 暂时挂到外存 解除： 资源剥夺法：挂起[^2]某些死锁进程 并将其资源分给其它死锁进程 注意防止饥饿 撤销进程法：强制撤销部分/全部死锁进程 并剥夺资源 代价大 进程回退法：一个/多个死锁进程回退到避免死锁的地步 需设置还原点 进程选择考虑：进程优先级 已执行时间 还要多久完成 已使用多少资源 交互式or批处理式 内存 内存基础 内存中存储程序的最小单位——存储单元 按字节编址 = 每个存储单元大小为1B 1K=2^10^ 1M=2^20^ 1G=2^30^ 逻辑地址（编程时指定的相对地址）转换为物理地址（绝对地址）方法： 绝对装入——编译时指定绝对地址 不存在操作系统时应用 静态重定位（可重定位装入）——装入模块（exe）装入时转换 必分配要求的全部内存空间 运行期间位置不能移动 动态重定位（……）——程序要执行时再进行转换 需要重定位寄存器——寄存装入模块存放的起始位置 允许程序在内存中移动 链接方式 静态链接——运行前链接为装入模块 装入时动态链接——装入内存时 边装入边链接 运行时动态链接——执行时需要某模块才链接 内存管理 概念 功能：内存空间的分配与回收 + 内存空间的扩展 + 地址转换 + 内存保护 内存保护方法： CPU中设置上下限寄存器——限定进程可访问的空间 重定位寄存器（基址寄存器）+界地址寄存器（限长寄存器）=起始物理地址 + 最大逻辑地址 最大逻辑地址判定是否越界异常 起始物理地址确定被查询数据的具体位置 覆盖与交换（内存空间的扩展） 覆盖：不能同时进行的程序段共享同一片覆盖区 一个固定区（程序段不会被调入调出）+若干覆盖区 程序员提前声明 对用户不透明——已淘汰 交换：内存紧张时 内存中某进程暂时换出外存 外存中某进程换入内存 外存（磁盘）包括文件区\u0026对换区——对换区IO速度比文件区更快（对换区主要追求效率） 可优先换出阻塞/优先级低进程/…… PCB常驻内存 不会被换出（储存进程换出在外存的位置） 连续分配管理方式 为进程分配连续的内存空间\n单一连续分配：内存 = 系统区 + 用户区 内存中只能有一个用户程序 无外部碎片 有内部碎片（分配的内存区域有部分没有用上） 固定分区分配——用户空间划分为固定大小的分区 每个分区运行一道作业（分区大小可相同/不相同） 分区说明表（数组/链表表示）：记录分区大小 起始地址 状态等 无外部碎片 but 用户程序过大只能覆盖 会产生内部碎片 动态分区分配（可变分区分配） 动态分区分配的几个问题 空闲分区表/链存储内存使用情况\n…链：空闲分区起始加前向指针 末尾加后向指针 多个空闲分区分配——动态分区分配算法\n分区的分配与回收——简单的修改表项操作\n特点：没有内存碎片 but 有外部碎片\n外部碎片：内存中某些空闲分区因太小而难以利用 可通过紧凑（拼凑Compaction）解决——换入换出 装入方式选择？ 动态重定位 紧凑之后？ 修改起始地址——PCB 也要放入CPU的基址寄存器 动态分区分配算法 首次适应算法：从低地址开始查找 找到第一个满足大小的空闲分区 空闲分区按地址递增的次序排列 算法开销小 性能最好 最佳适应算法：优先使用更小的空闲区 按容量递增次序排列 会产生很多外部碎片 + 算法开销大 最坏适应算法：优先使用最大的连续空闲区 容量递减次序 可能大进程无处安放 + 算法开销大 邻近适应算法：首次适应 + 每次从上次查找结束的位置开始检索 地址递增次序\u0026上次查找结束 高地址的大分区可能被用完 基本分页存储管理（非连续分配管理方式） 分页存储： 内存空间分为大小相等的分区 每个分区就是一个页框 每个页框有编号 即页框号 页框=页帧=内存块=物理块=物理页面 页框号=页帧号=内存块号=物理块号=物理页号 页框号从0开始 进程的逻辑地址空间分为与页框大小相等的部分 每个部分即为页面 每个页面标号为页号 页面=页 页号从0开始 页面与页框一一对应 各页面不必连续存放 页表 通常保存在PCB中\n一进程对应一张页表 进程的每个页面对应一个页表项（=页号+块号） 记录进程页面和实际存放的内存块间的映射关系 问题：每个页表项占多少字节？ 从内存块号范围（如0~2^20^-1）确定（二进制表示至少需要20bit 即内存块号大小） 用B（字节）表示至少3B（1B=8bit） 即至少用3B表示块号 页号不占存储空间——页表项连续存放 问题：如何实现地址转换？ 确定页号+页内偏移量 基本地址变换机构 逻辑地址到物理地址的转换\n注意越界检查——从系统区的PCB调出数据 放到页表寄存器（页表始址 + 页表长度） 页表长度即页表中有多少页表项 实际会拓展页表项大小——最好一个页框能装下整数个页表项（跟进程存储相独立） 具有快表地地址变换机构 快表TLB（联想寄存器translation lookaside buffer）——访问速度比内存快很多的高速缓存（Cache） 非内存（内存中的页表被称为慢表） 存放最近访问的页表项的副本 普通Cache中存放其它内容的副本 在快表中查询是否有需查找的页表项 若未命中则访问内存中慢表——内存中最近访问过的页表项存放到快表中 两级页表 将页表拆分为很多小页表——页目录表存储小页表存放位置 二级页表存放进程页面的存放位置 二级页表可以离散存储 逻辑地址结构 = 一级页号 + 二级页号 + 页内偏移量 各级页表最多存储页表项数量 = 各页面可存放的最多页表项 基本分段存储管理（非连续分配管理方式） 分段：程序自身逻辑划分为若干段 每段有段名（低级语言——汇编语言 按段名编程） 每段从0开始编址 段号位数决定了每个进程最多分多少段 段内地址数决定了每段最大长度 段表：保存逻辑段存放位置 = 段号 + 段长 + 基址（段号隐含 不占内存） 各段表项长度相同 地址变换——段表寄存器（段表始址+段表长度）\u0026段内地址与段长 进行越界中断检查 分页\u0026分段 页是信息的物理单位 对用户不可见 进程地址空间为一维 段是信息的逻辑单位 对用户可见 进程地址空间为二维 更易实现信息共享与保护 不会被修改的代码（即纯代码）才可以共享 段页式管理方式（非连续分配管理方式） 分页分段优缺点：分页不会产生外部碎片 但不能按逻辑实现信息共享 分段反之 段页式 = 先分段 \u0026 每段再分页 逻辑地址结构 = 段号 + 页号 + 页内偏移量 一个段表 + n个页表 页部分对用户不可见 只需指定段号与段内偏移量 检查段号 页号是否越界 虚拟内存（内存的扩充） 局部性原理 时间局部性——某指令/数据若被调用过 不久后很可能再次被调用 空间局部性——某存储单元若被访问过 不久后其附近存储单元很可能被访问 很多数据在内存中连续存放 程序指令也是顺序存放 虚拟内存——很快会用到的部分装入内存 剩下的在外存 + 若执行时某信息不在内存 操作系统将其调入 + 内存不够时将暂时不用的调出 特征： 多次性——无需一次性装入 对换性——作业运行时允许换入换出 虚拟性——逻辑上扩充内存容量 管理：请求分页管理方式\u0026请求分段管理方式\u0026请求段页式管理方式 实现：操作系统提供请求调页功能 + 页面置换功能（For分页 分段类似） 请求分页管理方式 页表机制：操作系统需知页面是否已调入内存/外存存放位置 内存空间不够时进行页面置换——修改过的页面调出覆盖外存中旧数据 未修改的不变 缺页中断：若页面不在内存则产生 缺页的进程阻塞 调页完成后唤醒就绪 中断处理程序需要保存CPU现场 中断信号来自CPU 为内中断 地址变换机构：新增请求调页 \u0026 页面置换 \u0026 修改请求页表中的新增表项 调入的页面对应的表项会直接加入快表 页面置换算法 选择哪个页面被换出\n最佳置换算法OPT：淘汰以后永不使用/最长时间不访问的页面 保证最低缺页率 不可能实现 先进先出FIFO：淘汰最早进入内存的页面 为进程分配的物理块数（内存块）增多时 缺页次数反而增加 = Belady异常 只有FIFO有Belady 性能差 最近最久未使用置换算法LRU：淘汰自上次访问至今时间最长的页面 性能好 but 实现困难开销大 时钟置换CLOCK/最近未用NRU：（简单版）内存中页面用指针链接为循环队列 被访问时访问位设为1 淘汰时遇1置0 遇0淘汰 最多经过两轮扫描进行淘汰页面 未考虑是否修改 改进版时钟置换：设置修改位 0表示未被修改 1表示被修改 优先淘汰(0,0)（访问位，修改位） 二轮淘汰(0,1) 并把扫描过的页面访问位置0 三轮淘汰(0,0)，四轮淘汰(0,1)（访问位均为0，故总有页面被淘汰） 算法开销小 \u0026 性能可 页面分配策略 驻留集 请求分页存储管理中给进程分配的物理块集合\n虚拟存储技术的系统中 驻留集一般小于进程总大小 页面分配置换策略 固定分配 \u0026 可变分配 驻留集大小在进程运行期间是否可变 局部置换 \u0026 全局置换 缺页时 只能选进程自己的物理块进行置换 可选其他进程的物理块/操作系统保留的物理块 固定分配局部置换 难以在初期确定合理的物理块数目 可变分配全局置换——选择未锁定页面换出外存 将其分配（只要缺页就分配新物理块） 被选中的进程缺页率增加 可变分配局部置换——频繁缺页 系统会多分配物理块 调入页面时机 预调页策略——相邻页面调入 主要用于进程首次调入 请求调页策略——缺页时调入 抖动现象（颠簸） 刚换出的页面马上需换入内存\n原因：频繁访问的页面数目高于可用的物理块数（物理块不够） 工作集：某时间间隔里 进程实际访问页面的集合 一般驻留集\u003c工作集 否则会频繁缺页 内存映射文件Memory-Mapped Files 将文件映射到进程的虚拟地址空间——以访问内存的方式访问文件 读入写出由操作系统负责 多个进程可以映射同个文件 实现共享 文件管理 在磁盘（外存）中\n文件的逻辑结构 逻辑结构 For用户（看来 内部数据如何组织） 物理结构 For操作系统（看来 文件数据如何存放在外存）\nflowchart LR 逻辑结构--\u003e无结构文件 逻辑结构--\u003e有结构文件 有结构文件--\u003e顺序文件 有结构文件--\u003e索引文件 有结构文件--\u003e索引顺序文件 顺序文件--\u003e顺序存储 顺序文件--\u003e链式存储 无结构文件（流式文件）——内部数据为一系列二进制流/字符流 eg.txt 有结构文件（记录式文件） 每条记录有一个数据项可作为关键字 定长记录——各条记录长度相等 可变长记录——不等 有结构文件的逻辑结构 各记录排列的顺序\n顺序文件：记录按顺序排列（逻辑上的顺序） 定长/可变长记录 串结构——记录的顺序与关键词无关 顺序结构——记录顺序按关键词顺序 定长记录的顺序文件可实现随机存取 若采用顺序结构可快速找到关键字对应的记录（折半查找） 可变长记录的顺序文件不能随机存取 索引文件（加快文件检索速度）——可变长记录的顺序文件改进 索引表自身为定长记录的顺序文件 可能会占用很大的内存空间 索引顺序文件——索引表改进 将文件数据分组 索引顺序文件储存分组信息 查找：先在索引顺序文件中顺序找分组 后在分组中顺序找记录 多级索引顺序文件——索引顺序文件改进 文件目录 文件控制块FCB——包含文件基本信息 FCB有序集合即为文件目录 目录结构： 单极目录结构 不允许文件重名 两级目录结构 = 主文件目录 + 用户文件目录 允许不同用户的文件重名 多级目录结构（树形结构）——用文件路径名标识文件 eg./users/local/bin 树形结构不便于文件共享 无环图目录结构——增加一些指向同节点的有向边（相当于共享） 可设置共享计数器 索引结点：存放FCB中除文件名外的信息（用索引结点指针存放） 加快查找效率 文件物理结构 磁盘块：磁盘中分为many磁盘块 大小与内存块、页面大小相同 逻辑块号 + 块内地址 = 文件的逻辑地址 连续分配：要求每个文件在磁盘上占有一组连续的块 文件目录需记录文件存放在磁盘中的起始块号\u0026长度（总共占用几块） 优点：支持顺序访问与直接访问 \u0026 顺序读写时速度最快（距离近 磁头移动更快） 缺点：存储空间利用率低 会产生磁盘碎片 链接分配：离散分配 指针链接 隐式链接——必须从上一个逻辑块中读到下一个块的物理地址 只支持顺序读取 but 不会产生碎片 显式链接——链接各物理块的指针显式存放在一张表中（文件分配表FAT File Allocation Table） 一个磁盘仅一张FAT 开机时读入内存并常驻 FAT各表项在物理上连续存储 且长度相同 支持顺序/随机访问 不会产生外部碎片 but FAT需要占用一定存储空间 索引分配：离散分配 每个文件都有一张索引表（记录文件逻辑块对应的物理块） 索引表存放的磁盘块称为索引块（FCB中记录索引块位置） 文件数据存放的称为数据块 索引表过大 解决方案： 链接方案——顺序读取各索引块 多层索引——需多次读磁盘 混合索引——多种索引分配方式结合 eg.有的直接地址索引 有的一级间接（单层索引表） 有的二级间接索引 各级索引表不能超过一个块 文件存储空间管理 存储空间划分与初始化 将物理磁盘划分为文件卷（逻辑卷/逻辑盘） eg.C盘 文件卷包括目录区（存放FCB 存储空间管理的信息等）\u0026文件区 空闲表法——建立空闲表（包括空闲盘块号\u0026空闲盘块数） 分配回收与内存的动态分区分配类似 空闲链表法——空闲盘块链/空闲盘区链（连续的盘块组成盘区） OS保存链头链尾指针 盘区链适用于离散分配\u0026连续分配 位示图法 每一格代表一个盘块 盘块号=ni+j（n为字长 i为字号 j为位号） 空闲标0 不空标1 成组链接法（UNIX采用） 空闲表/链表法不适用于大型文件系统 文件基本操作 创建文件：在外存中找到文件所需空间 + 创建该文件对应的目录项 删除文件：找到目录项 + 回收磁盘块 + 删除目录项 打开文件：找到目录项（检查权限） + 目录项复制到内存中的打开文件表 打开文件表 系统有一总表 各进程也有表（记录读写指针 访问权限 系统表索引号） 关闭文件：进程的打开文件表项删除 + 回收内存 + 系统打开文件总表计数器更改 读/写文件：读/写指针指向外存（文件数据存储处） OS将用户指定的数据读入内存 写回写指针指向的外存数据 文件共享 基于索引结点的共享方式——硬链接 不同用户的目录下索引结点指针指向同一个索引结点 索引结点中设置链接计数变量 基于符号链的共享方式——软链接 创建Link类型文件 根据其记录的路径查找目录 eg.快捷方式 文件保护 口令保护：为文件设置口令（保存在FCB中） 请求访问时验证 口令存放在系统内部 加密保护：对文件原始数据进行加密 eg.异或加密 访问控制：为文件的FCB/索引结点增加访问控制列表(Access-Control List,ACL) 记录各用户可执行的操作 设备管理 I/O设备分类 输入输出\n分类：人机交互类外部设备 + 存储设备 + 网络通信设备 eg.猫 人机…：数据传输速度慢 存储设备：数据传输速度快 分类：低速设备 + 中速设备 + 高速设备 分类：块设备 + 字符设备 以块为单位进行信息交换 eg.移动硬盘 字符设备常采用中断驱动方式 I/O控制器 CPU控制I/O控制器 I/O控制器控制设备的机械部件\n功能： 接收识别CPU命令——控制寄存器存放 向CPU报告设备状态——状态寄存器 数据交换——数据寄存器 地址识别——为寄存器设置地址 组成：CPU与控制器的接口 + I/O逻辑 + 控制器与设备的接口（多个） 各寄存器也可能有多个 寄存器地址分类：内存映像I/O——与内存地址统一编址 寄存器独立编址——使用单独的地址 都储存在内存中 I/O控制方式 程序直接控制方式：数据最后要存储到内存中 CPU干预频繁 每次传送一个字 实现简单 but CPU与I/O只能串行工作 CPU长期处于忙等 中断驱动方式：CPU发出命令后将等待I/O的进程阻塞 切换执行其它进程 I/O完成后发出中断信号 CPU检测到中断信号后处理中断（读一个字） 之后恢复进程运行环境（等待I/O或其它） CPU在每个指令周期末尾检查中断 中断时需要保存进程现有状态 频繁中断效率低 DMA直接存储器存取——主要用于块设备的I/O控制 数据从设备到内存 or 从内存到设备 不经过CPU CPU通过MAR内存地址寄存器等指明存放位置等信息 可读写一个或连续的多个块 CPU只在传送的开始或结束时介入 but 只能读写连续的数据块 通道控制 = 更弱的CPU（硬件） CPU只需发出I/O命令 完成后向CPU发出中断信号 可处理一组块 I/O软件层次结构 know某处理是在哪层完成的 用户层软件：与用户交互 提供库函数进行操作 \u0026 将用户请求转为I/O请求 用系统调用请求内核服务 设备独立性软件（与硬件特性无关的功能） 如：向上层提供系统调用接口\u0026设备保护（如访问权限）\u0026差错处理\u0026设备分配回收\u0026数据缓冲区管理\u0026逻辑、物理设备名映射 不同设备内部硬件特性不同——不同的设备驱动程序 设备驱动程序：对硬件设备的具体控制 将命令转化为特定设备的操作 中断处理程序：I/O任务完成时控制器发送中断信号 系统根据中断信号类型找到中断处理程序 输入输出管理 I/O程序接口： 字符设备接口 get/put系统调用 块设备 read/write seek——在读写指针处操作 网络设备 网络套接字socket接口 eg.localhost:1313 1313即为一个套接字 可与其它ip地址的socket绑定 实现信息传输 阻塞I/O 发出I/O系统调用进程需转为阻塞态 非阻塞I/O不需阻塞等待 设备驱动程序接口——设备独立软件层 I/O核心子系统 I/O调度——类其它调度策略 设备保护——UNIX将设备视为特殊的文件 假脱机技术SPOOLing 用户层软件 模拟脱机技术\n组成：缓冲区与井都暂存数据 位置不同 共享打印机原理——输出井为每个打印请求分配一个存储区（逻辑设备） 设备的分配与回收 设备独立性软件\n设备分配考虑：设备固有属性 设备分配算法 设备分配安全性 分配方法： 静态分配 运行前分配资源 动态分配 过程中分配 分配管理的数据结构 设备控制表DCT 指向COCT的指针 控制器控制表COCT 指向CHCT的指针 通道控制表CHCT 等待队列指针 系统设备表SDT 包括DCT 分配步骤：根据物理设备名找SDT 从SDT找到DCT 到COCT找到控制器 到CHCT分配通道 设备、控制器、通道都分配成功才成功 必须使用物理设备名——难换 \u0026 若正忙进程必须阻塞等待 改进：用逻辑设备名申请 OS用LUT（逻辑设备表）实现名称映射 一张LUT中逻辑设备名不可重复 一般每个用户一张 缓冲区 作用：缓和CPU与I/O设备速度不匹配的矛盾 减少对CPU的中断频率 解决数据粒度不匹配问题（字符/块） 单缓冲：主存中分配缓冲区——非空时不能进数据 空时可以进数据但必须充满 双缓冲：分配2个缓冲区 循环缓冲区：多个大小相等的缓冲区链接为循环队列 缓冲池：系统中共用的缓冲区组成 可分为空缓冲队列 装满输入数据的缓冲队列（输入队列） 输出队列 缓冲区种类：收容输入hin 提取输入sin 收容输出sout 提取输出hout 磁盘 结构 磁盘上一圈为一个磁道 磁道被分为一个个扇区（即磁盘块） 可能有很多盘面 但所有盘面连轴转 每个磁头共进退 各扇区存放数据量相同 读写数据：移到指定磁道 磁盘转动使目标扇区从磁头下划过实现 柱面号-盘面号-扇区号定位磁盘块 柱面：所有盘面中相对位置相同的磁道（下图黄色部分） 分类：活动头磁盘（磁臂可移动） 固定头磁盘（不可动 但有很多磁臂） 也可按盘片可否更换分类 磁盘调度算法 一次读写操作时间： 寻找时间——读写数据前 磁臂移动到指定磁道 延迟时间——旋转磁盘 定位扇区 传输时间——从磁盘读出/写入数据 调度算法： 先来先服务FCFS：进程请求磁盘访问的先后顺序 最短寻找时间优先SSTF：优先处理离当前磁头最近的磁道 可能饥饿 扫描SCAN（电梯算法）：磁头移动到最外侧才能向内动 反之亦然 不会饥饿 but 不同磁道响应频率不平均 LOOK：若在移动方向上无其他请求 可以立即改变磁头移动方向 循环扫描C-SCAN：只有朝固定方向移动时才处理磁道访问请求 返回时直接到起始段 响应频率平均 but 平均寻道时间更长 C-LOOK：移动方向上若无其他请求立即返回 减少延迟时间的方法 读取一块后就需要处理——但磁盘转动不停——下一块要转圈\n交替编号——逻辑上相邻的扇区在物理上有间隔 磁盘地址结构设计： 为什么柱面号在前？ 面对连续的地址如000,00,000-000,01,111 柱面号在前时不用移动磁臂；盘面号在前需移动磁臂 错位命名——改变相邻盘面对应顺序（相邻地址读取时间问题） 磁盘管理（理解） 磁盘初始化： 低级格式化（物理格式化）——划分扇区 分为头、数据区域、尾 磁盘分区——每个分区由若干柱面组成eg.C盘 逻辑格式化——创建文件系统（创建根目录 初始化数据结构eg.位示图） 引导块（启动块/启动分区）——存放完整的自举程序 启动块位于磁盘的固定位置 拥有启动分区的磁盘 = 启动磁盘/系统磁盘eg.C盘 坏块（无法正确使用的扇区） 简单的磁盘可在逻辑格式化时检查并标明 复杂的用磁盘控制器维护坏块链 管理备用扇区 固态硬盘SSD 重点如下\n主要结构： 以页为单位读写 以块为单位进行数据擦除 方可重写每页 先把不需擦除的页复制到其它闪存芯片对应位置 在其它芯片上写后整体移入原芯片 映射的物理位置可以改变 读快写慢 SSD的一个块被多次擦除可能会损坏 磨损均衡技术：将擦除平均分布在各个块上 动态磨损均衡：写入数据时 优先选择累计擦除次数少的新闪存块 静态磨损均衡：SSD分配数据 让老旧闪存块承担以读为主任务 新的以写为主🥳🥳 来自王道408-操作系统 ↩︎ ↩︎ ↩︎ ↩︎ ↩︎ ↩︎\n","wordCount":"14913","inLanguage":"en","datePublished":"2024-10-28T19:35:56+08:00","dateModified":"2024-11-05T19:19:00+08:00","author":[{"@type":"Person","name":"Satti"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Sattiluvcat.github.io/en/posts/notes/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},"publisher":{"@type":"Organization","name":"Satti's Blog","logo":{"@type":"ImageObject","url":"https://Sattiluvcat.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Sattiluvcat.github.io/en/ accesskey=h title="Satti's Blog (Alt + H)"><img src=https://Sattiluvcat.github.io/img/label1.jpg alt aria-label=logo height=35>Satti's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Sattiluvcat.github.io/en/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://Sattiluvcat.github.io/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://Sattiluvcat.github.io/en/tags title=📑标签><span>📑标签</span></a></li><li><a href=https://Sattiluvcat.github.io/en/lulu/ title=😽Lulu><span>😽Lulu</span></a></li><li><a href=https://Sattiluvcat.github.io/en/archives/ title=📅时间轴><span>📅时间轴</span></a></li><li><a href=https://Sattiluvcat.github.io/en/about/ title=😎关于><span>😎关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Sattiluvcat.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/>文章</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/notes/>Notes📓</a></div><h1 class="post-title entry-hint-parent">操作系统OS</h1><div class=post-description>关于操作系统的学习笔记</div><div class=post-meta><span title='2024-10-28 19:35:56 +0800 +0800'>2024-10-28</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;<span title='Last updated 2024-11-05 19:19:00 +0800 +0800'>Last updated on 2024-11-05</span>&nbsp;·&nbsp;Satti</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f aria-label=操作系统>操作系统</a><ul><li><a href=#%e5%ae%9a%e4%b9%89 aria-label=定义>定义</a></li><li><a href=#%e5%9b%9b%e4%b8%aa%e7%89%b9%e5%be%81 aria-label=四个特征>四个特征</a><ul><li><a href=#%e5%b9%b6%e5%8f%91 aria-label=并发>并发</a></li><li><a href=#%e5%85%b1%e4%ba%ab aria-label=共享>共享</a></li><li><a href=#%e8%99%9a%e6%8b%9f aria-label=虚拟>虚拟</a></li><li><a href=#%e5%bc%82%e6%ad%a5%e6%80%a7 aria-label=异步性>异步性</a></li></ul></li><li><a href=#%e5%8f%91%e5%b1%95%e4%b8%8e%e5%88%86%e7%b1%bb aria-label=发展与分类>发展与分类</a></li><li><a href=#%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6 aria-label=运行机制>运行机制</a><ul><li><a href=#%e4%b8%a4%e7%a7%8d aria-label=两种>两种</a></li></ul></li><li><a href=#%e4%b8%ad%e6%96%ad%e4%b8%8e%e5%bc%82%e5%b8%b8 aria-label=中断与异常>中断与异常</a><ul><li><a href=#%e4%b8%ad%e6%96%ad%e4%bd%9c%e7%94%a8 aria-label=中断作用>中断作用</a></li><li><a href=#%e4%b8%ad%e6%96%ad%e7%b1%bb%e5%9e%8b aria-label=中断类型>中断类型</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 aria-label=基本原理>基本原理</a></li></ul></li><li><a href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-label=系统调用>系统调用</a></li><li><a href=#%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84 aria-label=体系结构>体系结构</a></li><li><a href=#%e5%bc%95%e5%af%bc aria-label=引导>引导</a><ul><li><a href=#%e8%bf%87%e7%a8%8b aria-label=过程>过程</a></li></ul></li><li><a href=#%e8%99%9a%e6%8b%9f%e6%9c%ba aria-label=虚拟机>虚拟机</a></li></ul></li><li><a href=#%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86 aria-label=进程管理>进程管理</a><ul><li><a href=#%e8%bf%9b%e7%a8%8b%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86 aria-label=进程基础知识>进程基础知识</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac aria-label=基本>基本</a><ul><li><a href=#%e5%ae%9a%e4%b9%89-1 aria-label=定义>定义</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e7%bb%84%e6%88%90 aria-label=进程组成>进程组成</a></li><li><a href=#%e7%89%b9%e5%be%81 aria-label=特征>特征</a></li></ul></li><li><a href=#%e7%8a%b6%e6%80%81%e4%b8%8e%e8%bd%ac%e6%8d%a2 aria-label=状态与转换>状态与转换</a><ul><li><a href=#%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%bb%84%e7%bb%87 aria-label=进程的组织>进程的组织</a></li></ul></li><li><a href=#%e8%bf%9b%e7%a8%8b%e6%8e%a7%e5%88%b6 aria-label=进程控制>进程控制</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e9%80%9a%e4%bf%a1ipc aria-label=进程通信IPC>进程通信IPC</a><ul><li><a href=#%e5%85%b1%e4%ba%ab%e5%ad%98%e5%82%a8 aria-label=共享存储>共享存储</a></li><li><a href=#%e6%b6%88%e6%81%af%e4%bc%a0%e9%80%92 aria-label=消息传递>消息传递</a></li><li><a href=#%e7%ae%a1%e9%81%93%e9%80%9a%e4%bf%a1 aria-label=管道通信>管道通信</a></li></ul></li><li><a href=#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=线程与多线程>线程与多线程</a><ul><li><a href=#%e7%ba%bf%e7%a8%8b%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f aria-label=线程实现方式>线程实现方式</a></li></ul></li><li><a href=#%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e4%b8%8e%e8%bd%ac%e6%8d%a2 aria-label=线程状态与转换>线程状态与转换</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e7%bb%84%e7%bb%87%e4%b8%8e%e6%8e%a7%e5%88%b6 aria-label=线程组织与控制>线程组织与控制</a></li></ul></li><li><a href=#%e8%b0%83%e5%ba%a6 aria-label=调度>调度</a><ul><li><a href=#%e5%a4%84%e7%90%86%e6%9c%ba%e8%b0%83%e5%ba%a6 aria-label=处理机调度>处理机调度</a><ul><li><a href=#%e4%b8%89%e4%b8%aa%e5%b1%82%e6%ac%a1 aria-label=三个层次>三个层次</a></li></ul></li><li><a href=#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e6%97%b6%e6%9c%ba aria-label=进程调度时机>进程调度时机</a></li><li><a href=#%e8%b0%83%e5%ba%a6%e5%99%a8%e8%b0%83%e5%ba%a6%e7%a8%8b%e5%ba%8fscheduler%e4%b8%8e%e9%97%b2%e9%80%9b%e8%bf%9b%e7%a8%8bidle aria-label=调度器（调度程序）scheduler与闲逛进程idle>调度器（调度程序）scheduler与闲逛进程idle</a></li><li><a href=#%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95%e8%af%84%e4%bb%b7%e6%8c%87%e6%a0%87 aria-label=调度算法评价指标>调度算法评价指标</a></li><li><a href=#%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label=调度算法>调度算法</a></li></ul></li><li><a href=#%e8%bf%9b%e7%a8%8b%e5%90%8c%e6%ad%a5-%e4%ba%92%e6%96%a5%e7%ad%89 aria-label="进程同步 互斥等">进程同步 互斥等</a><ul><li><a href=#%e8%bf%9b%e7%a8%8b%e5%90%8c%e6%ad%a5%e4%b8%8e%e4%ba%92%e6%96%a5 aria-label=进程同步与互斥>进程同步与互斥</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e4%ba%92%e6%96%a5%e7%9a%84%e8%bd%af%e4%bb%b6%e5%ae%9e%e7%8e%b0 aria-label=进程互斥的软件实现>进程互斥的软件实现</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e4%ba%92%e6%96%a5%e7%a1%ac%e4%bb%b6%e5%ae%9e%e7%8e%b0 aria-label=进程互斥硬件实现>进程互斥硬件实现</a></li><li><a href=#%e4%ba%92%e6%96%a5%e9%94%81 aria-label=互斥锁>互斥锁</a></li><li><a href=#%e4%bf%a1%e5%8f%b7%e9%87%8f%e6%9c%ba%e5%88%b6 aria-label=信号量机制>信号量机制</a></li><li><a href=#%e4%bf%a1%e5%8f%b7%e9%87%8f%e6%9c%ba%e5%88%b6%e5%ba%94%e7%94%a8 aria-label=信号量机制应用>信号量机制应用</a></li><li><a href=#pv%e4%be%8b%e9%a2%98 aria-label=PV例题>PV例题</a><ul><li><a href=#%e7%94%9f%e4%ba%a7%e8%80%85%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98 aria-label=生产者消费者问题>生产者消费者问题</a></li><li><a href=#%e5%a4%9a%e7%94%9f%e4%ba%a7%e5%a4%9a%e6%b6%88%e8%b4%b9%e8%80%85 aria-label=多生产多消费者>多生产多消费者</a></li><li><a href=#%e5%90%b8%e7%83%9f%e8%80%85 aria-label=吸烟者>吸烟者</a></li><li><a href=#%e8%af%bb%e8%80%85-%e5%86%99%e8%80%85 aria-label=读者-写者>读者-写者</a></li><li><a href=#%e5%93%b2%e5%ad%a6%e5%ae%b6%e8%bf%9b%e9%a4%90 aria-label=哲学家进餐>哲学家进餐</a></li></ul></li><li><a href=#%e7%ae%a1%e7%a8%8b aria-label=管程>管程</a></li></ul></li><li><a href=#%e6%ad%bb%e9%94%81 aria-label=死锁>死锁</a><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a><ul><li><a href=#%e6%a6%82%e5%bf%b5 aria-label=概念>概念</a></li><li><a href=#%e6%9d%a1%e4%bb%b6 aria-label=条件>条件</a></li><li><a href=#%e5%8f%91%e7%94%9f%e6%ad%bb%e9%94%81%e7%9a%84%e6%83%85%e5%86%b5 aria-label=发生死锁的情况>发生死锁的情况</a></li><li><a href=#%e5%a4%84%e7%90%86%e7%ad%96%e7%95%a5 aria-label=处理策略>处理策略</a></li></ul></li><li><a href=#%e9%a2%84%e9%98%b2%e6%ad%bb%e9%94%81%e9%9d%99%e6%80%81%e7%ad%96%e7%95%a5 aria-label=预防死锁（静态策略）>预防死锁（静态策略）</a></li><li><a href=#%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81%e5%8a%a8%e6%80%81%e7%ad%96%e7%95%a5 aria-label=避免死锁（动态策略）>避免死锁（动态策略）</a></li><li><a href=#%e6%a3%80%e6%b5%8b%e4%b8%8e%e8%a7%a3%e9%99%a4 aria-label=检测与解除>检测与解除</a></li></ul></li></ul></li><li><a href=#%e5%86%85%e5%ad%98 aria-label=内存>内存</a><ul><li><a href=#%e5%86%85%e5%ad%98%e5%9f%ba%e7%a1%80 aria-label=内存基础>内存基础</a></li><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 aria-label=内存管理>内存管理</a><ul><li><a href=#%e6%a6%82%e5%bf%b5-1 aria-label=概念>概念</a></li><li><a href=#%e8%a6%86%e7%9b%96%e4%b8%8e%e4%ba%a4%e6%8d%a2%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e7%9a%84%e6%89%a9%e5%b1%95 aria-label=覆盖与交换（内存空间的扩展）>覆盖与交换（内存空间的扩展）</a></li><li><a href=#%e8%bf%9e%e7%bb%ad%e5%88%86%e9%85%8d%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label=连续分配管理方式>连续分配管理方式</a><ul><li><a href=#%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d%e7%9a%84%e5%87%a0%e4%b8%aa%e9%97%ae%e9%a2%98 aria-label=动态分区分配的几个问题>动态分区分配的几个问题</a></li></ul></li><li><a href=#%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d%e7%ae%97%e6%b3%95 aria-label=动态分区分配算法>动态分区分配算法</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%88%86%e9%a1%b5%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86%e9%9d%9e%e8%bf%9e%e7%bb%ad%e5%88%86%e9%85%8d%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label=基本分页存储管理（非连续分配管理方式）>基本分页存储管理（非连续分配管理方式）</a><ul><li><a href=#%e5%88%86%e9%a1%b5%e5%ad%98%e5%82%a8 aria-label=分页存储：>分页存储：</a></li><li><a href=#%e9%a1%b5%e8%a1%a8 aria-label=页表>页表</a></li></ul></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%9c%b0%e5%9d%80%e5%8f%98%e6%8d%a2%e6%9c%ba%e6%9e%84 aria-label=基本地址变换机构>基本地址变换机构</a></li><li><a href=#%e5%85%b7%e6%9c%89%e5%bf%ab%e8%a1%a8%e5%9c%b0%e5%9c%b0%e5%9d%80%e5%8f%98%e6%8d%a2%e6%9c%ba%e6%9e%84 aria-label=具有快表地地址变换机构>具有快表地地址变换机构</a></li><li><a href=#%e4%b8%a4%e7%ba%a7%e9%a1%b5%e8%a1%a8 aria-label=两级页表>两级页表</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%88%86%e6%ae%b5%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86%e9%9d%9e%e8%bf%9e%e7%bb%ad%e5%88%86%e9%85%8d%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label=基本分段存储管理（非连续分配管理方式）>基本分段存储管理（非连续分配管理方式）</a></li><li><a href=#%e6%ae%b5%e9%a1%b5%e5%bc%8f%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f%e9%9d%9e%e8%bf%9e%e7%bb%ad%e5%88%86%e9%85%8d%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label=段页式管理方式（非连续分配管理方式）>段页式管理方式（非连续分配管理方式）</a></li><li><a href=#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e5%86%85%e5%ad%98%e7%9a%84%e6%89%a9%e5%85%85 aria-label=虚拟内存（内存的扩充）>虚拟内存（内存的扩充）</a></li><li><a href=#%e8%af%b7%e6%b1%82%e5%88%86%e9%a1%b5%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label=请求分页管理方式>请求分页管理方式</a></li><li><a href=#%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2%e7%ae%97%e6%b3%95 aria-label=页面置换算法>页面置换算法</a></li><li><a href=#%e9%a1%b5%e9%9d%a2%e5%88%86%e9%85%8d%e7%ad%96%e7%95%a5 aria-label=页面分配策略>页面分配策略</a><ul><li><a href=#%e9%a9%bb%e7%95%99%e9%9b%86 aria-label=驻留集>驻留集</a></li><li><a href=#%e9%a1%b5%e9%9d%a2%e5%88%86%e9%85%8d%e7%bd%ae%e6%8d%a2%e7%ad%96%e7%95%a5 aria-label=页面分配置换策略>页面分配置换策略</a></li><li><a href=#%e8%b0%83%e5%85%a5%e9%a1%b5%e9%9d%a2%e6%97%b6%e6%9c%ba aria-label=调入页面时机>调入页面时机</a></li><li><a href=#%e6%8a%96%e5%8a%a8%e7%8e%b0%e8%b1%a1%e9%a2%a0%e7%b0%b8 aria-label=抖动现象（颠簸）>抖动现象（颠簸）</a></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6memory-mapped-files aria-label="内存映射文件Memory-Mapped Files">内存映射文件Memory-Mapped Files</a></li></ul></li><li><a href=#%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86 aria-label=文件管理>文件管理</a><ul><li><a href=#%e6%96%87%e4%bb%b6%e7%9a%84%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84 aria-label=文件的逻辑结构>文件的逻辑结构</a><ul><li><a href=#%e6%9c%89%e7%bb%93%e6%9e%84%e6%96%87%e4%bb%b6%e7%9a%84%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84 aria-label=有结构文件的逻辑结构>有结构文件的逻辑结构</a></li></ul></li><li><a href=#%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95 aria-label=文件目录>文件目录</a></li><li><a href=#%e6%96%87%e4%bb%b6%e7%89%a9%e7%90%86%e7%bb%93%e6%9e%84 aria-label=文件物理结构>文件物理结构</a></li><li><a href=#%e6%96%87%e4%bb%b6%e5%ad%98%e5%82%a8%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86 aria-label=文件存储空间管理>文件存储空间管理</a></li><li><a href=#%e6%96%87%e4%bb%b6%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c aria-label=文件基本操作>文件基本操作</a></li><li><a href=#%e6%96%87%e4%bb%b6%e5%85%b1%e4%ba%ab aria-label=文件共享>文件共享</a></li><li><a href=#%e6%96%87%e4%bb%b6%e4%bf%9d%e6%8a%a4 aria-label=文件保护>文件保护</a></li></ul></li><li><a href=#%e8%ae%be%e5%a4%87%e7%ae%a1%e7%90%86 aria-label=设备管理>设备管理</a><ul><li><a href=#io%e8%ae%be%e5%a4%87%e5%88%86%e7%b1%bb aria-label=I/O设备分类>I/O设备分类</a></li><li><a href=#io%e6%8e%a7%e5%88%b6%e5%99%a8 aria-label=I/O控制器>I/O控制器</a></li><li><a href=#io%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f aria-label=I/O控制方式>I/O控制方式</a></li><li><a href=#io%e8%bd%af%e4%bb%b6%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84 aria-label=I/O软件层次结构>I/O软件层次结构</a></li><li><a href=#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba%e7%ae%a1%e7%90%86 aria-label=输入输出管理>输入输出管理</a></li><li><a href=#io%e6%a0%b8%e5%bf%83%e5%ad%90%e7%b3%bb%e7%bb%9f aria-label=I/O核心子系统>I/O核心子系统</a><ul><li><a href=#%e5%81%87%e8%84%b1%e6%9c%ba%e6%8a%80%e6%9c%afspooling aria-label=假脱机技术SPOOLing>假脱机技术SPOOLing</a></li><li><a href=#%e8%ae%be%e5%a4%87%e7%9a%84%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6 aria-label=设备的分配与回收>设备的分配与回收</a></li></ul></li><li><a href=#%e7%bc%93%e5%86%b2%e5%8c%ba aria-label=缓冲区>缓冲区</a></li><li><a href=#%e7%a3%81%e7%9b%98 aria-label=磁盘>磁盘</a><ul><li><a href=#%e7%bb%93%e6%9e%84 aria-label=结构>结构</a></li><li><a href=#%e7%a3%81%e7%9b%98%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95 aria-label=磁盘调度算法>磁盘调度算法</a></li><li><a href=#%e5%87%8f%e5%b0%91%e5%bb%b6%e8%bf%9f%e6%97%b6%e9%97%b4%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=减少延迟时间的方法>减少延迟时间的方法</a></li><li><a href=#%e7%a3%81%e7%9b%98%e7%ae%a1%e7%90%86%e7%90%86%e8%a7%a3 aria-label=磁盘管理（理解）>磁盘管理（理解）</a></li><li><a href=#%e5%9b%ba%e6%80%81%e7%a1%ac%e7%9b%98ssd aria-label=固态硬盘SSD>固态硬盘SSD</a></li></ul></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p> </p><p> </p><h2 id=操作系统>操作系统<a hidden class=anchor aria-hidden=true href=#操作系统>#</a></h2><h3 id=定义>定义<a hidden class=anchor aria-hidden=true href=#定义>#</a></h3><blockquote><p>系统资源的管理者&提供方便的接口与环境&最接近硬件的软件</p></blockquote><ol><li>功能：处理机(CPU)管理&存储器管理&文件管理&设备管理<ul><li>程序运行 将相关数据从磁盘放入<strong>内存</strong> = 存储器</li><li>进程被CPU管理 = 处理机</li></ul></li><li>接口&环境<pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
 接口--&gt;GUI
 接口--&gt;程序接口
 用户接口--&gt;程序接口
 用户接口--&gt;脱机命令接口
 接口--&gt;命令接口
 命令接口--&gt;脱机命令接口
 命令接口--&gt;联机命令接口
 联机命令接口---交互式命令接口
 交互式命令接口--&gt;cmd
 批处理--&gt;.bat
 脱机命令接口---批处理
</code></pre><ul><li>GUI 图形化用户接口</li></ul></li><li>硬件拓展<ul><li>无软件支持的计算机 = 裸机</li><li>覆盖了软件 = 扩充机器（虚拟机）</li></ul></li></ol><h3 id=四个特征>四个特征<a hidden class=anchor aria-hidden=true href=#四个特征>#</a></h3><blockquote><p>并发 共享 是最基本的特征 互为存在条件</p></blockquote><h4 id=并发>并发<a hidden class=anchor aria-hidden=true href=#并发>#</a></h4><p>宏观上同时发生 微观上交替（= 同时段发生）</p><ol><li>单核CPU同一时刻只能执行一个程序=并发</li></ol><ul><li>多核可以实现并行（同一时刻进行多个程序）</li></ul><h4 id=共享>共享<a hidden class=anchor aria-hidden=true href=#共享>#</a></h4><p>资源共享 系统资源可供内存中多个<strong>并发</strong>进程共同使用
两种资源共享方式：</p><ul><li>互斥共享 一时段一进程 eg.摄像头</li><li>同时共享 一时段多进程</li></ul><h4 id=虚拟>虚拟<a hidden class=anchor aria-hidden=true href=#虚拟>#</a></h4><p>物理实体变为逻辑上的对应物</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    虚拟技术--&gt;空分复用技术
    虚拟技术--&gt;时分复用技术
    空分复用技术--&gt;eg.虚拟存储器
    时分复用技术--&gt;eg.虚拟处理器
</code></pre><ul><li>没有并发性 虚拟性 = 不存在</li></ul><h4 id=异步性>异步性<a hidden class=anchor aria-hidden=true href=#异步性>#</a></h4><p>多个程序并发 资源有限时进程执行以未知速度推进</p><ul><li>没有并发性 异步性 = 不存在</li></ul><h3 id=发展与分类>发展与分类<a hidden class=anchor aria-hidden=true href=#发展与分类>#</a></h3><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TB
    subgraph 手工操作
        缺点1--&gt;独占全机
        缺点1--&gt;资源利用率低
       资源利用率低--&gt;计算机快&amp;人工慢
    end
    手工操作--&gt;批处理阶段
    subgraph 批处理阶段
        subgraph 单道批处理系统
            主要结构--&gt;磁带&amp;监督程序
            缺点2--&gt;内存中仅能运行一道程序
        end
        单道批处理系统--&gt;多道批处理系统
        subgraph 多道批处理系统
            输入计算输出错峰运行
            缺点3--&gt;运行过程时不能调试
        end
    end
    批处理阶段--&gt;分时操作系统
    subgraph 分时操作系统
        特点--&gt;以时间片为单位轮流服务用户
        优点--&gt;及时响应解决人机交互问题
        缺点4--&gt;不能优先处理紧急任务
    end
   分时操作系统--&gt;实时操作系统
   subgraph 实时操作系统
       在严格时限内处理事件---可以优先响应
       特点1--&gt;及时性&amp;可靠性
       分类--&gt;硬实时系统
      硬实时系统---严格时限
       分类--&gt;软实时系统
      软实时系统---偶尔接受迟滞
   end
   实时操作系统--&gt;网络操作系统
   实时操作系统--&gt;分布式操作系统
   实时操作系统--&gt;个人计算机操作系统
   subgraph 不重要
      网络操作系统
      分布式操作系统
      个人计算机操作系统
   end
</code></pre><h3 id=运行机制>运行机制<a hidden class=anchor aria-hidden=true href=#运行机制>#</a></h3><blockquote><p>指令 = 机器指令 非cmd</p></blockquote><h4 id=两种>两种<a hidden class=anchor aria-hidden=true href=#两种>#</a></h4><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    内核程序Kernal--&gt;特权指令
    应用程序--&gt;非特权指令
   特权指令--&gt;内核态
   非特权指令--&gt;用户态
</code></pre><ul><li>内核程序 = 最接近硬件的部分</li><li>特权指令 = 管理者操作</li><li>内核态/用户态 = <strong>CPU状态</strong>（用PSW存储状态）<ul><li>PSW 程序状态字寄存器</li><li>内核态=核心态=<strong>管态</strong></li><li>用户态=<strong>目态</strong></li></ul></li></ul><p>切换状态：</p><ul><li>内核到用户：特权指令修改PSW</li><li>用户到内核：触发中断 硬件自动完成</li></ul><h3 id=中断与异常>中断与异常<a hidden class=anchor aria-hidden=true href=#中断与异常>#</a></h3><h4 id=中断作用>中断作用<a hidden class=anchor aria-hidden=true href=#中断作用>#</a></h4><p>唯一让CPU从用户态变为内核态的途径 = 保障并发</p><h4 id=中断类型>中断类型<a hidden class=anchor aria-hidden=true href=#中断类型>#</a></h4><p>内中断（异常）：中断信号来自CPU内部 当前执行指令</p><ul><li>指令自身非法/遇到特权指令<ul><li>eg.trap程序引发/fault错误条件 Kernal可能修补/abort致命错误
外中断（中断）：与当前指令无关</li><li>eg.时钟中断</li><li>eg.I/O中断</li></ul></li></ul><h4 id=基本原理>基本原理<a hidden class=anchor aria-hidden=true href=#基本原理>#</a></h4><p>CPU检测到中断后查询中断向量表 找到中断处理程序的内存位置</p><h3 id=系统调用>系统调用<a hidden class=anchor aria-hidden=true href=#系统调用>#</a></h3><blockquote><p>一组系统调用组成程序接口</p></blockquote><ol><li>应用程序通常通过库函数进行系统调用<ul><li>有些库函数不调用</li><li>有些语言直接进行系统调用 eg.汇编语言</li></ul></li><li>向<strong>系统内核提出请求对共享资源</strong>进行操作 即系统调用<ul><li>发出trap指令提出请求（<strong>用户态</strong>）</li><li>执行trap后引发内中断进入核心态</li></ul></li></ol><h3 id=体系结构>体系结构<a hidden class=anchor aria-hidden=true href=#体系结构>#</a></h3><p>大/宏内核操作系统：所有内核功能（Linux UNIX等）</p><ul><li>eg.进程 存储 设备 + 微内核部分</li><li>性能高</li><li>内核代码庞大 结构混乱
微内核操作系统：与硬件关系最紧密的功能（Windows NT）</li><li>eg.时钟管理 中断处理 原语（设备驱动 CPU切换）</li><li>优缺点反之</li></ul><h3 id=引导>引导<a hidden class=anchor aria-hidden=true href=#引导>#</a></h3><h4 id=过程>过程<a hidden class=anchor aria-hidden=true href=#过程>#</a></h4><p><img loading=lazy src=img.png alt=img.png>
<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><ol><li>CPU从主存（ = RAM + ROM（BIOS））执行ROM引导程序</li><li>将磁盘中主引导记录（MBR）读入内存 执行磁盘引导程序 扫描分区表</li><li>从活动分区（主分区）读入分区引导记录（PBR） 执行程序<ul><li>主分区即安装了操作系统的分区</li></ul></li><li>从根目录找到启动管理器并执行 完成开机🥳</li></ol><h3 id=虚拟机>虚拟机<a hidden class=anchor aria-hidden=true href=#虚拟机>#</a></h3><blockquote><p>Virtual Machine (VMware & Virtual Box)</p></blockquote><p>虚拟机管理程序（VMM monitor）</p><ul><li>第一类VMM 运行在硬件上（CPU 磁盘 内存进行划分）<ul><li>用户空间分为虚拟用户态&虚拟内核态（但实际均为用户态）</li><li>若执行特权指令 由内核中的VMM进行虚拟执行</li></ul></li><li>第二类VMM 运行在宿主操作系统（Host OS）上（如Vmware）<ul><li>VMM大部在用户态 VM驱动部分在内核态</li></ul></li><li>对比：第一类性能更好 可容纳更多虚拟机 运行在最高特权级(Ring 0) 但可迁移性不强<ul><li>第二类反之</li></ul></li></ul><h2 id=进程管理>进程管理<a hidden class=anchor aria-hidden=true href=#进程管理>#</a></h2><h3 id=进程基础知识>进程基础知识<a hidden class=anchor aria-hidden=true href=#进程基础知识>#</a></h3><h4 id=基本>基本<a hidden class=anchor aria-hidden=true href=#基本>#</a></h4><h5 id=定义-1>定义<a hidden class=anchor aria-hidden=true href=#定义-1>#</a></h5><p>程序：静态 = 指令集合
进程：动态 = 程序的执行过程</p><h5 id=进程组成>进程组成<a hidden class=anchor aria-hidden=true href=#进程组成>#</a></h5><p>PCB（Process Control Block）进程控制块 For操作系统</p><ul><li>进程存在<strong>唯一标志</strong></li><li>保存：PID UID & 进程控制与管理信息 & 资源分配清单 & 处理机信息<ul><li>PID（进程ID 唯一不重复）</li></ul></li></ul><p>程序段：程序代码 For进程</p><ul><li>程序运行：程序->硬盘（exe）->内存PCB->CPU取出指令
数据段：运行过程中产生的数据 For进程</li><li>进程实体（进程映像）=PCB+程序段+数据段 静态</li><li>进程 进程实体的运行过程 动态</li></ul><h5 id=特征>特征<a hidden class=anchor aria-hidden=true href=#特征>#</a></h5><p>动态性：最基本的特征
并发性：内存中有多个进程实体
独立性：获得资源的基本单位
异步性
结构性：每个进程都有一个PCB</p><h4 id=状态与转换>状态与转换<a hidden class=anchor aria-hidden=true href=#状态与转换>#</a></h4><p>创建态 就绪态 运行态 阻塞态 终止态</p><ul><li>就绪态——等待处理机调度</li><li>运行态——占用整个CPU运行</li><li>阻塞态——运行态进程请求等待某事件发生 下CPU（进程主动）<ul><li>事件发生后改为就绪态（被动）</li></ul></li></ul><h5 id=进程的组织>进程的组织<a hidden class=anchor aria-hidden=true href=#进程的组织>#</a></h5><p>链式：队列指针
索引：索引表指针</p><h4 id=进程控制>进程控制<a hidden class=anchor aria-hidden=true href=#进程控制>#</a></h4><blockquote><p>实现进程状态转换</p></blockquote><p>原语实现——具<strong>原子性</strong> = 不可中断</p><ul><li>特权指令 关中断指令&开中断指令实现原子性<ul><li>关中断开启——不再检查中断信号</li></ul></li></ul><p>创建/撤销进程时使用的原语：PCB更新——资源分配——合适的队列</p><ul><li>申请空白PCB——找到对应PCB</li><li>为新进程分配资源——若运行 剥夺CPU并分配</li><li>初始化PCB——终止所有子进程</li><li>PCB插入就绪队列——资源归还并删除PCB</li></ul><p>阻塞/唤醒原语——成对使用（因何阻塞必因何唤醒）<br>切换进程的原语：将现行运行环境<strong>存入PCB</strong></p><h4 id=进程通信ipc>进程通信IPC<a hidden class=anchor aria-hidden=true href=#进程通信ipc>#</a></h4><blockquote><p>两进程间的数据交互
不同进程的内存地址不重叠 通信需要操作系统支持</p></blockquote><h5 id=共享存储>共享存储<a hidden class=anchor aria-hidden=true href=#共享存储>#</a></h5><blockquote><p>设定共享存储区 映射到进程的虚拟地址空间</p></blockquote><ol><li>互斥访问 由进程自己实现</li></ol><ul><li>基于存储区：灵活性高 高级通信</li><li>基于数据结构：低级通信</li></ul><h5 id=消息传递>消息传递<a hidden class=anchor aria-hidden=true href=#消息传递>#</a></h5><blockquote><p>消息包括消息头&消息体 操作均由<strong>原语</strong>完成</p></blockquote><ol><li>直接通信：两进程明确消息的接收方与发送方<ul><li>在内存中存储发送了的消息 形成<strong>消息队列</strong></li></ul></li><li>间接通信：发到内存中的信箱 另一进程从信箱读取<ul><li>信箱公用</li></ul></li></ol><h5 id=管道通信>管道通信<a hidden class=anchor aria-hidden=true href=#管道通信>#</a></h5><blockquote><p>某时段内单向传输（半双工通信） I/O进程不固定数量</p></blockquote><ol><li>一种共享文件pipe 内存中一个<strong>大小固定</strong>的内存缓冲区<ul><li><strong>队列</strong> 先进先出</li></ul></li></ol><h4 id=线程与多线程>线程与多线程<a hidden class=anchor aria-hidden=true href=#线程与多线程>#</a></h4><blockquote><p>同个进程中可能有多个线程 程序执行的最小单位（相当于小进程）</p></blockquote><ol><li>提升并发度 不用切换进程（同进程内线程切换）系统开销小</li><li>每个线程有自己的线程ID与TCB线程控制块</li><li>几乎不拥有系统资源（来自所属的进程）</li><li>通信方便 同进程内不需系统干预</li></ol><h5 id=线程实现方式>线程实现方式<a hidden class=anchor aria-hidden=true href=#线程实现方式>#</a></h5><ol><li>用户级线程（早期）——由线程库实现&管理<ul><li>程序实现 <strong>与操作系统无关</strong></li><li>并发程度很低（阻塞）
<img loading=lazy src=img_1.png alt=img_1.png>
<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li></ul></li><li>内核级线程（KTL）<ul><li>进程与对应的内核级线程都在内核态的操作系统</li><li>内核级线程一一管理用户级线程</li><li>线程切换管理成本更高</li></ul></li><li>多线程模型<ul><li>一对一：一内核一用户</li><li>多对一：一内核多用户（退化）</li><li>多对多：多内核多用户（内核更少）</li></ul></li></ol><h4 id=线程状态与转换>线程状态与转换<a hidden class=anchor aria-hidden=true href=#线程状态与转换>#</a></h4><ol><li>就绪——运行——阻塞</li></ol><h4 id=线程组织与控制>线程组织与控制<a hidden class=anchor aria-hidden=true href=#线程组织与控制>#</a></h4><ol><li>TCB(≈PCB)=线程标识符（TID）+程序计数器PC+其他寄存器+堆栈指针+线程运行状态+优先级</li><li>调度时保存PC+其他寄存器+堆栈指针</li></ol><h3 id=调度>调度<a hidden class=anchor aria-hidden=true href=#调度>#</a></h3><h4 id=处理机调度>处理机调度<a hidden class=anchor aria-hidden=true href=#处理机调度>#</a></h4><blockquote><p>确定处理任务的先后顺序</p></blockquote><h5 id=三个层次>三个层次<a hidden class=anchor aria-hidden=true href=#三个层次>#</a></h5><ol><li>高级调度（<strong>作业</strong>调度）——从外存调入内存开始任务</li><li>低级调度（<strong>进程</strong>调度）——最基本 快速 内存到CPU</li><li>中级调度（<strong>内存</strong>调度）——从外存调到内存 从挂起队列调回内存（内存不足）</li></ol><h4 id=进程调度时机>进程调度时机<a hidden class=anchor aria-hidden=true href=#进程调度时机>#</a></h4><ol><li>不能调度的eg.处理中断 原语 处于内核程序临界区（操作系统内）<ul><li>可调度eg包括主动与被动</li></ul></li><li>方式：<ul><li>非抢占方式——反之</li><li>抢占方式——更紧急的任务优先执行 当前任务中止 适用分时、实时操作系统</li></ul></li><li>包括：选择进程+进程切换</li></ol><h4 id=调度器调度程序scheduler与闲逛进程idle>调度器（调度程序）scheduler与闲逛进程idle<a hidden class=anchor aria-hidden=true href=#调度器调度程序scheduler与闲逛进程idle>#</a></h4><ol><li>触发调度器eg.创建新进程+进程退出+进程阻塞+I/O中断（maybe唤醒阻塞进程）<ul><li>抢占式调度：时钟中断触发</li><li>非抢占式：only阻塞/退出才触发</li></ul></li><li>闲逛进程idle——优先级最低 占一个完整的指令周期（提醒作用）</li></ol><h4 id=调度算法评价指标>调度算法评价指标<a hidden class=anchor aria-hidden=true href=#调度算法评价指标>#</a></h4><ol><li>CPU利用率=利用时间/总时间</li><li>系统吞吐量=单位时间内完成作业的<strong>数量</strong></li><li>周转时间=作业提交至系统->作业完成的时间<ul><li>平均周转时间=各作业周转时间和/作业数</li><li><strong>带权周转时间</strong>=周转时间/实际运行时间（>=1）</li><li>平均带权周转时间=带权和/作业数</li></ul></li><li>等待时间=等待处理机状态时间和<ul><li>for进程：等待被服务的时间</li><li>for作业：建立进程后的等待时间+作业在外存后备队列的等待时间</li></ul></li><li>响应时间=提交请求->首次响应的时间</li></ol><h4 id=调度算法>调度算法<a hidden class=anchor aria-hidden=true href=#调度算法>#</a></h4><ol><li>先来先服务FCFS first come first serve<ul><li>非抢占式</li><li>公平 but 长作业有利 短作业不利</li><li>不会饥饿（长期得不到服务）</li></ul></li><li>短作业优先SJF shortest job first——当前<strong>已到达</strong> 运行时间<strong>最短</strong><ul><li>=短进程优先</li><li>非抢占（抢占版为最短剩余时间优先算法SRNT<ul><li>新达到进程/进程完成时 剩余时间最短者抢占当前进程</li><li>SRNT平均等待时间、平均周转时间最少</li></ul></li><li>若所有进程几乎同时到达 SJF平均等待时间、平均周转时间最少</li><li>时间短 but 不公平 长作业不利</li><li><strong>会饥饿 maybe饿死</strong></li></ul></li><li>高响应比优先HRRN highest response ratio next——每次调度时先计算响应比 响应比同先来先服务<ul><li>响应比=(等待时间+要求服务时间)/要求服务时间</li><li>非抢占式</li><li>考虑了要求服务时间</li><li>不会饥饿<br>（适用于交互式系统的调度算法👇）</li></ul></li><li>时间片轮转RR round-robin——根据到达顺序轮流执行一个时间片<ul><li>only用于进程调度</li><li>可抢占式——时钟中断</li><li>公平 but 切换频繁&不区分紧急程度</li><li>时间片过大——增大进程响应时间 过小——进程切换过于频繁</li><li>不会饥饿</li></ul></li><li>优先级——设置优先级：系统>用户 前台>后台 更偏好I/O型（I/O可以和CPU并行工作）<ul><li>也可用于I/O</li><li>非抢占 有抢占式版本</li><li>考虑优先级 but 可能导致饥饿</li></ul></li><li>多级反馈队列——设置多级就绪队列 优先级从高到低 时间片从小到大<ul><li>规则：<ul><li>新进程先进第1级队列 FCFS分配时间片 时间片用完还未结束 则进入下级队尾（最下级的就进入本级队尾）</li><li>k级队列为空时 再为k+1级分配时间片</li><li>被抢占的进程进入此队队尾</li></ul></li><li>用于进程调度</li><li>抢占式（有非抢占式版本）</li><li>相对公平 响应快 短进程完成较快 避免用户作假 灵活调整偏好程度</li><li>maybe饥饿</li></ul></li><li>多级队列——按进程类型设置不同优先级 队列间可采取固定优先级/时间片划分 各队列可采用不同调度策略</li></ol><h3 id=进程同步-互斥等>进程同步 互斥等<a hidden class=anchor aria-hidden=true href=#进程同步-互斥等>#</a></h3><h4 id=进程同步与互斥>进程同步与互斥<a hidden class=anchor aria-hidden=true href=#进程同步与互斥>#</a></h4><ol><li>进程同步——进程的次序（对抗异步性——未知速度）</li><li>进程互斥——临界资源（一时段一程序访问）互斥<ul><li>进入区（检查可否进入 设置正在访问标志）——临界区——退出区（解除标志）——剩余区</li><li>临界区空闲则让进 忙则等待</li><li>有限等待——能在有限时间内进入临界区</li><li>让权等待</li></ul></li></ol><h4 id=进程互斥的软件实现>进程互斥的软件实现<a hidden class=anchor aria-hidden=true href=#进程互斥的软件实现>#</a></h4><ol><li>单标志法——一个flag=允许进入临界区的进程号<ul><li>空闲让进不符</li></ul></li><li>双标志先检查法——<em>进程数</em>个flag 表达本进程是否进入临界区<ul><li>忙则等待不符（检查与上锁不是同时发生）</li></ul></li><li>双标志后检查法——先上锁后检查<ul><li>空闲让进 有限等待不符</li></ul></li><li>Peterson——自己flag为true & <strong>上其它锁</strong> & 若其它flag为true且上锁则自己while空循环等待</li></ol><h4 id=进程互斥硬件实现>进程互斥硬件实现<a hidden class=anchor aria-hidden=true href=#进程互斥硬件实现>#</a></h4><ol><li>中断屏蔽——开/关中断指令实现<ul><li>简单高效 but 不适用多处理机（only单处理机）&特权指令</li></ul></li><li>TS指令 TestAndSetLock——执行过程不允许中断
<img loading=lazy src=img_2.png alt=img_2.png>
<sup id=fnref2:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup><ul><li>让权等待不符——无法进入的程序会占用CPU并循环TSL指令</li></ul></li><li>SWAP指令（即XCHG）——类TSL指令
<img loading=lazy src=img_3.png alt=img_3.png>
<sup id=fnref3:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li></ol><h4 id=互斥锁>互斥锁<a hidden class=anchor aria-hidden=true href=#互斥锁>#</a></h4><ol><li>主要缺点：忙等<ul><li>需要连续循环忙等的互斥锁 = 自旋锁</li><li>适用多处理机系统</li></ul></li></ol><h4 id=信号量机制>信号量机制<a hidden class=anchor aria-hidden=true href=#信号量机制>#</a></h4><blockquote><p>用户进程用一对原语对信号量操作</p></blockquote><ol><li>信号量：变量（整数/记录型变量）<ul><li>整型信号量——仅初始化、P、V操作<ul><li>存在忙等</li></ul></li><li>记录型信号量——灵活使用阻塞态 就绪态等<ul><li>value表示资源的剩余数量</li><li>遵循让权等待
<img loading=lazy src=img_4.png alt=img_4.png>
<sup id=fnref4:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>
<img loading=lazy src=img_5.png alt=img_5.png>
<sup id=fnref5:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li></ul></li></ul></li><li>一对原语：wait(S) signal(S) 简称为P、V操作<ul><li>必成对出现</li></ul></li></ol><h4 id=信号量机制应用>信号量机制应用<a hidden class=anchor aria-hidden=true href=#信号量机制应用>#</a></h4><ol><li>实现进程互斥——value定为互斥信号量mutex（进入临界区的名额） 初值为1</li><li>进程同步——保证操作顺序——设置同步信号量S 初值0（反互斥之道而行之）<ul><li>先V（进程一结束后）后P（进程二开始前）——V释放资源 P获取资源</li></ul></li><li>前驱关系
<img loading=lazy src=img_6.png alt=img_6.png></li></ol><h4 id=pv例题>PV例题<a hidden class=anchor aria-hidden=true href=#pv例题>#</a></h4><h5 id=生产者消费者问题>生产者消费者问题<a hidden class=anchor aria-hidden=true href=#生产者消费者问题>#</a></h5><ol><li>bg：生产者生产一个产品放入缓冲区 消费者每次取出一个产品 缓冲区有大小限制且为临界资源</li><li>PV关系：缓冲区空否——同步信号量（初值为n） 满否——同步信号量（初值为0） 访问——互斥信号量<ul><li>P操作：互斥信号always在同步信号<strong>后</strong>（不空/满才访问）</li><li>V：whatever</li></ul></li></ol><h5 id=多生产多消费者>多生产多消费者<a hidden class=anchor aria-hidden=true href=#多生产多消费者>#</a></h5><ol><li>bg：生产者A生产a 消费者C只要c BD同理 缓冲区仅能放有限数量</li><li>PV：互斥——访问 同步——几个a/b（For消费者） 同步——还可以放多少（For生产者） 共4个</li><li>若缓冲区大小为1 maybe可以不加互斥信号量</li></ol><h5 id=吸烟者>吸烟者<a hidden class=anchor aria-hidden=true href=#吸烟者>#</a></h5><ol><li>bg：3个抽烟者和1个供应者 卷烟需要3种材料 一抽烟者有1种 供应者每次供应2种 1对应抽烟者拿走</li><li>PV：互斥——访问 同步——1 2 3是否卷好<ul><li>可以省略互斥</li></ul></li></ol><h5 id=读者-写者>读者-写者<a hidden class=anchor aria-hidden=true href=#读者-写者>#</a></h5><ol><li>bg：共享一个文件 可以多个读 一个写则其它均不可 写时让已有的读与写全部退出</li><li>PV：互斥——记录读进程个数（互斥访问计数器） 互斥——写锁 读写锁等</li></ol><h5 id=哲学家进餐>哲学家进餐<a hidden class=anchor aria-hidden=true href=#哲学家进餐>#</a></h5><ol><li>bg：圆桌 每人两边各有一只筷子 哲学家要么思考要么进食（需要两只筷子）</li><li>PV：对筷子设置互斥 无限制会死锁——限制最多四人进餐/…</li></ol><h4 id=管程>管程<a hidden class=anchor aria-hidden=true href=#管程>#</a></h4><blockquote><p>信号量机制——编写程序困难易出错 => 引入管程替代PV</p></blockquote><ol><li>组成≈类（过程≈Java中的方法）</li><li>特征：管城内的数据只能被其内部的过程访问 +
只有通过管程的过程才能访问内部的共享数据 + 每次仅有一个进程在管程内执行过程</li><li>Java中的类似机制：<code>synchronized</code> 被其
修饰的函数在同一时段内只能被一个<strong>线程</strong>调用</li></ol><h3 id=死锁>死锁<a hidden class=anchor aria-hidden=true href=#死锁>#</a></h3><h4 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h4><h5 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h5><ol><li>死锁：各进程互相等待对方的资源 = 都阻塞<ul><li>管理者的问题</li></ul></li><li>饥饿：长期得不到资源 某进程无法推进<ul><li>管理者的问题</li></ul></li><li>死循环：进程执行时跳不出循环</li></ol><h5 id=条件>条件<a hidden class=anchor aria-hidden=true href=#条件>#</a></h5><ol><li>互斥——资源使用互斥</li><li>不剥夺——其他进程不能强行夺走资源</li><li>请求和保持——已经保持了至少一个资源 但还有请求</li><li>循环等待——资源的循环等待链<ul><li>循环等待时不一定会发生死锁</li></ul></li></ol><h5 id=发生死锁的情况>发生死锁的情况<a hidden class=anchor aria-hidden=true href=#发生死锁的情况>#</a></h5><p>资源竞争 进程推进顺序非法（请求与释放的顺序不当） 信号量使用不当 = 不可剥夺的资源分配不合理</p><h5 id=处理策略>处理策略<a hidden class=anchor aria-hidden=true href=#处理策略>#</a></h5><p>预防（破坏形成条件） + 避免（防止进入不安全状态） + 检测与解除</p><h4 id=预防死锁静态策略>预防死锁（静态策略）<a hidden class=anchor aria-hidden=true href=#预防死锁静态策略>#</a></h4><ol><li>互斥条件破坏——改为共享资源 eg.SPOOLing技术<ul><li>适用范围窄</li></ul></li><li>不剥夺破坏——请求无法满足时释放所有资源/操作系统将资源强行剥夺<ul><li>复杂+降低吞吐量+maybe饥饿+只适用易保存回复资源</li></ul></li><li>请求保持破坏——静态分配方法（运行前申请所有资源 不满足则不运行 运行后不请求）<ul><li>资源利用率低 maybe饥饿</li></ul></li><li>循环等待破坏——顺序资源分配法（资源编号 每个进程按编号递增请求资源 同号一次申请完）<ul><li>难新增资源+资源浪费+编程麻烦</li></ul></li></ol><h4 id=避免死锁动态策略>避免死锁（动态策略）<a hidden class=anchor aria-hidden=true href=#避免死锁动态策略>#</a></h4><ol><li>安全序列：按此序列分配资源则每个进程都能完成<ul><li>安全 = 一定不死锁</li><li>不安全 = 不一定死锁</li></ul></li><li>银行家算法：进程申请时 预判分配会否导致不安全 会则阻塞该进程<ul><li>安全性算法：根据资源分配循环找安全序列</li></ul></li></ol><ul><li>n个进程 m种资源 = n*m矩阵 =>最大需求矩阵<code>Max</code></li><li>n*m的分配矩阵<code>Allocation</code></li><li>最多还需要多少资源<code>Need</code></li><li>长m的一维数组<code>Available</code>表示还有多少可用资源</li><li>长m的一维数组<code>Request</code>表示本次申请的各种资源<br><img loading=lazy src=img_7.png alt=img_7.png></li><li>不断重复上述步骤</li></ul><h4 id=检测与解除>检测与解除<a hidden class=anchor aria-hidden=true href=#检测与解除>#</a></h4><ol><li>检测：保存资源的请求与分配信息（数据结构）+检测是否死锁（算法）<ul><li>两种边：请求与分配</li><li>最终能消除所有边 = “可完全简化” = 一定没有死锁</li><li>死锁定理：若不能消除 = 发生死锁 还连着的边 = 处于死锁[^2]: 暂时挂到外存
<img loading=lazy src=img_8.png alt=img_8.png></li></ul></li><li>解除：<ul><li>资源剥夺法：挂起[^2]某些死锁进程 并将其资源分给其它死锁进程<ul><li>注意防止饥饿</li></ul></li><li>撤销进程法：强制撤销部分/全部死锁进程 并剥夺资源<ul><li>代价大</li></ul></li><li>进程回退法：一个/多个死锁进程回退到避免死锁的地步<ul><li>需设置还原点</li></ul></li></ul></li></ol><ul><li>进程选择考虑：进程优先级 已执行时间 还要多久完成 已使用多少资源 交互式or批处理式</li></ul><h2 id=内存>内存<a hidden class=anchor aria-hidden=true href=#内存>#</a></h2><h3 id=内存基础>内存基础<a hidden class=anchor aria-hidden=true href=#内存基础>#</a></h3><ol><li>内存中存储程序的最小单位——存储单元<ul><li>按字节编址 = 每个存储单元大小为1B<ul><li>1K=2^10^ 1M=2^20^ 1G=2^30^</li></ul></li></ul></li><li>逻辑地址（编程时指定的相对地址）转换为物理地址（绝对地址）方法：<ul><li>绝对装入——编译时指定绝对地址<ul><li>不存在操作系统时应用</li></ul></li><li>静态重定位（可重定位装入）——装入模块（exe）装入时转换<ul><li>必分配要求的全部内存空间</li><li>运行期间位置不能移动</li></ul></li><li>动态重定位（……）——程序要执行时再进行转换<ul><li>需要<strong>重定位寄存器</strong>——寄存装入模块存放的起始位置</li><li>允许程序在内存中移动
<img loading=lazy src=img_9.png alt=img_9.png></li></ul></li></ul></li><li>链接方式<ul><li>静态链接——运行前链接为装入模块</li><li>装入时动态链接——装入内存时 边装入边链接</li><li>运行时动态链接——执行时需要某模块才链接</li></ul></li></ol><h3 id=内存管理>内存管理<a hidden class=anchor aria-hidden=true href=#内存管理>#</a></h3><h4 id=概念-1>概念<a hidden class=anchor aria-hidden=true href=#概念-1>#</a></h4><ol><li>功能：内存空间的分配与回收 + 内存空间的扩展 + 地址转换 + 内存保护</li><li>内存保护方法：<ul><li>CPU中设置上下限寄存器——限定进程可访问的空间</li><li>重定位寄存器（基址寄存器）+界地址寄存器（限长寄存器）=起始物理地址 + 最大逻辑地址<ul><li>最大逻辑地址判定是否越界异常</li><li>起始物理地址确定被查询数据的具体位置</li></ul></li></ul></li></ol><h4 id=覆盖与交换内存空间的扩展>覆盖与交换（内存空间的扩展）<a hidden class=anchor aria-hidden=true href=#覆盖与交换内存空间的扩展>#</a></h4><ol><li>覆盖：不能同时进行的程序段共享同一片覆盖区<ul><li>一个固定区（程序<strong>段</strong>不会被调入调出）+若干覆盖区</li><li>程序员提前声明 对用户不透明——已淘汰</li></ul></li><li>交换：<strong>内存紧张时</strong> 内存中某进程暂时换出外存 外存中某进程换入内存<ul><li>外存（磁盘）包括文件区&对换区——对换区IO速度比文件区更快（对换区主要追求效率）</li><li>可优先换出阻塞/优先级低进程/……</li><li><strong>PCB常驻内存</strong> 不会被换出（储存进程换出在外存的位置）</li></ul></li></ol><h4 id=连续分配管理方式>连续分配管理方式<a hidden class=anchor aria-hidden=true href=#连续分配管理方式>#</a></h4><blockquote><p>为进程分配连续的内存空间</p></blockquote><ol><li>单一连续分配：内存 = 系统区 + 用户区<ul><li>内存中<strong>只能有一个用户程序</strong></li><li>无外部碎片 有内部碎片（分配的内存区域有部分没有用上）
<img loading=lazy src=img_10.png alt=img_10.png></li></ul></li><li>固定分区分配——用户空间划分为固定大小的分区 <strong>每个分区运行一道作业</strong>（分区大小可相同/不相同）<ul><li>分区说明表（数组/链表表示）：记录分区大小 起始地址 状态等</li><li>无外部碎片 but 用户程序过大只能覆盖 会产生内部碎片</li></ul></li><li>动态分区分配（可变分区分配）</li></ol><h5 id=动态分区分配的几个问题>动态分区分配的几个问题<a hidden class=anchor aria-hidden=true href=#动态分区分配的几个问题>#</a></h5><ol><li><p>空闲分区表/链存储内存使用情况</p><ul><li>…链：空闲分区起始加前向指针 末尾加后向指针</li></ul></li><li><p>多个空闲分区分配——动态分区分配算法</p></li><li><p>分区的分配与回收——简单的修改表项操作</p></li><li><p>特点：没有内存碎片 but 有外部碎片</p><ul><li>外部碎片：内存中某些空闲分区因太小而难以利用</li><li>可通过紧凑（拼凑Compaction）解决——换入换出</li></ul></li><li><p><details><summary>装入方式选择？</summary>动态重定位</details><details><summary>紧凑之后？</summary>修改起始地址——PCB 也要放入CPU的基址寄存器</details></p></li></ol><h4 id=动态分区分配算法>动态分区分配算法<a hidden class=anchor aria-hidden=true href=#动态分区分配算法>#</a></h4><ol><li>首次适应算法：从低地址开始查找 找到第一个满足大小的空闲分区<ul><li>空闲分区按<strong>地址递增</strong>的次序排列</li><li>算法开销小 性能最好</li></ul></li><li>最佳适应算法：优先使用更小的空闲区<ul><li>按<strong>容量递增</strong>次序排列</li><li>会产生很多外部碎片 + <em>算法开销大</em></li></ul></li><li>最坏适应算法：优先使用最大的连续空闲区<ul><li>容量递减次序</li><li>可能大进程无处安放 + <em>算法开销大</em></li></ul></li><li>邻近适应算法：首次适应 + 每次从上次查找结束的位置开始检索<ul><li>地址递增次序&上次查找结束</li><li>高地址的大分区可能被用完</li></ul></li></ol><h4 id=基本分页存储管理非连续分配管理方式>基本分页存储管理（非连续分配管理方式）<a hidden class=anchor aria-hidden=true href=#基本分页存储管理非连续分配管理方式>#</a></h4><h5 id=分页存储>分页存储：<a hidden class=anchor aria-hidden=true href=#分页存储>#</a></h5><ol><li>内存空间分为大小相等的分区 每个分区就是一个<strong>页框</strong> 每个页框有编号 即页框号<ul><li>页框=页帧=内存块=物理块=物理页面</li><li>页框号=页帧号=内存块号=物理块号=物理页号</li><li>页框号从0开始</li></ul></li><li>进程的逻辑地址空间分为与页框大小相等的部分 每个部分即为<strong>页面</strong> 每个页面标号为页号<ul><li>页面=页</li><li>页号从0开始</li></ul></li><li>页面与页框一一对应 各页面不必连续存放</li></ol><h5 id=页表>页表<a hidden class=anchor aria-hidden=true href=#页表>#</a></h5><blockquote><p>通常保存在PCB中</p></blockquote><ol><li>一进程对应一张页表</li><li>进程的每个页面对应一个页表项（=页号+块号）</li><li>记录进程页面和实际存放的内存块间的映射关系
<img loading=lazy src=img_11.png alt=img_11.png></li><li>问题：每个页表项占多少字节？<ul><li>从内存块号范围（如0~2^20^-1）确定（二进制表示至少需要20bit 即内存块号大小）</li><li>用B（字节）表示至少3B（1B=8bit）</li><li>即至少用3B表示块号</li><li><strong>页号不占存储空间</strong>——页表项连续存放</li></ul></li><li>问题：如何实现地址转换？<ul><li>确定页号+页内偏移量</li></ul></li></ol><h4 id=基本地址变换机构>基本地址变换机构<a hidden class=anchor aria-hidden=true href=#基本地址变换机构>#</a></h4><blockquote><p>逻辑地址到物理地址的转换</p></blockquote><ol><li>注意越界检查——从系统区的PCB调出数据 放到页表寄存器（页表始址 + 页表长度）<ul><li>页表长度即页表中有多少页表项</li></ul></li><li>实际会拓展页表项大小——最好一个页框能装下整数个页表项（跟进程存储相独立）</li></ol><h4 id=具有快表地地址变换机构>具有快表地地址变换机构<a hidden class=anchor aria-hidden=true href=#具有快表地地址变换机构>#</a></h4><ol><li>快表TLB（联想寄存器translation lookaside buffer）——访问速度比内存快很多的<strong>高速缓存</strong>（Cache）<ul><li>非内存（<em>内存中的页表被称为慢表</em>）</li><li>存放最近访问的页表项的副本</li><li>普通Cache中存放其它内容的副本</li></ul></li><li>在快表中查询是否有需查找的页表项 若未命中则访问<strong>内存</strong>中慢表——内存中最近访问过的页表项存放到快表中</li></ol><h4 id=两级页表>两级页表<a hidden class=anchor aria-hidden=true href=#两级页表>#</a></h4><ol><li>将页表拆分为很多小页表——页目录表存储小页表存放位置 二级页表存放进程页面的存放位置
<img loading=lazy src=img_12.png alt=img_12.png><ul><li>二级页表可以离散存储</li><li>逻辑地址结构 = 一级页号 + 二级页号 + 页内偏移量</li><li>各级页表最多存储页表项数量 = 各页面可存放的最多页表项</li></ul></li></ol><h4 id=基本分段存储管理非连续分配管理方式>基本分段存储管理（非连续分配管理方式）<a hidden class=anchor aria-hidden=true href=#基本分段存储管理非连续分配管理方式>#</a></h4><ol><li>分段：程序自身逻辑划分为若干段 每段有段名（低级语言——汇编语言 按段名编程） 每段从0开始编址<ul><li>段号位数决定了每个进程最多分多少段</li><li>段内地址数决定了每段最大长度</li></ul></li><li>段表：保存逻辑段存放位置 = 段号 + 段长 + 基址（段号隐含 不占内存）<ul><li>各段表项长度相同</li></ul></li><li>地址变换——<strong>段表寄存器</strong>（段表始址+段表长度）&段内地址与段长 进行越界中断检查</li><li>分页&分段<ul><li>页是信息的物理单位 对用户不可见 进程地址空间为一维</li><li>段是信息的逻辑单位 对用户可见 进程地址空间为二维 更易实现信息共享与保护<ul><li>不会被修改的代码（即纯代码）才可以共享</li></ul></li></ul></li></ol><h4 id=段页式管理方式非连续分配管理方式>段页式管理方式（非连续分配管理方式）<a hidden class=anchor aria-hidden=true href=#段页式管理方式非连续分配管理方式>#</a></h4><ol><li>分页分段优缺点：分页不会产生外部碎片 但不能按逻辑实现信息共享 分段反之</li><li>段页式 = 先分段 & 每段再分页<ul><li>逻辑地址结构 = 段号 + 页号 + 页内偏移量</li><li>一个段表 + n个页表</li><li>页部分对用户不可见 只需指定段号与段内偏移量</li></ul></li><li>检查段号 页号是否越界
<img loading=lazy src=img_13.png alt=img_13.png></li></ol><h4 id=虚拟内存内存的扩充>虚拟内存（内存的扩充）<a hidden class=anchor aria-hidden=true href=#虚拟内存内存的扩充>#</a></h4><ol><li>局部性原理<ul><li>时间局部性——某指令/数据若被调用过 不久后很可能再次被调用</li><li>空间局部性——某存储单元若被访问过 不久后其附近存储单元很可能被访问<ul><li>很多数据在内存中连续存放 程序指令也是顺序存放</li></ul></li></ul></li><li>虚拟内存——很快会用到的部分装入内存 剩下的在外存 + 若执行时某信息不在内存 操作系统将其调入 + 内存不够时将暂时不用的调出</li><li>特征：<ul><li>多次性——无需一次性装入</li><li>对换性——作业运行时允许换入换出</li><li>虚拟性——逻辑上扩充内存容量</li></ul></li><li>管理：请求分页管理方式&请求分段管理方式&请求段页式管理方式</li><li>实现：操作系统提供请求调页功能 + 页面置换功能（For分页 分段类似）</li></ol><h4 id=请求分页管理方式>请求分页管理方式<a hidden class=anchor aria-hidden=true href=#请求分页管理方式>#</a></h4><ol><li>页表机制：操作系统需知页面是否已调入内存/外存存放位置<ul><li>内存空间不够时进行页面置换——修改过的页面调出覆盖外存中旧数据 未修改的不变
<img loading=lazy src=img_14.png alt=img_14.png></li></ul></li><li>缺页中断：若页面不在内存则产生 缺页的进程阻塞 调页完成后唤醒就绪<ul><li>中断处理程序需要保存CPU现场</li><li>中断信号来自CPU 为内中断</li></ul></li><li>地址变换机构：新增请求调页 & 页面置换 & 修改请求页表中的新增表项</li><li>调入的页面对应的表项会<strong>直接加入快表</strong></li></ol><h4 id=页面置换算法>页面置换算法<a hidden class=anchor aria-hidden=true href=#页面置换算法>#</a></h4><blockquote><p>选择哪个页面被换出</p></blockquote><ol><li>最佳置换算法OPT：淘汰以后永不使用/最长时间不访问的页面<ul><li>保证最低缺页率</li><li>不可能实现</li></ul></li><li>先进先出FIFO：淘汰最早进入内存的页面<ul><li>为进程分配的物理块数（内存块）增多时 缺页次数反而增加 = <strong>Belady异常</strong></li><li>只有FIFO有Belady 性能差</li></ul></li><li>最近最久未使用置换算法LRU：淘汰自上次访问至今时间最长的页面<ul><li>性能好 but 实现困难开销大</li></ul></li><li>时钟置换CLOCK/最近未用NRU：（简单版）内存中页面用指针链接为循环队列
被访问时访问位设为1 淘汰时遇1置0 遇0淘汰<ul><li>最多经过两轮扫描进行淘汰页面</li><li>未考虑是否修改</li></ul></li><li>改进版时钟置换：设置修改位 0表示未被修改 1表示被修改<ul><li>优先淘汰(0,0)（访问位，修改位） 二轮淘汰(0,1) 并把扫描过的页面访问位置0</li><li>三轮淘汰(0,0)，四轮淘汰(0,1)（访问位均为0，故总有页面被淘汰）</li><li>算法开销小 & 性能可</li></ul></li></ol><h4 id=页面分配策略>页面分配策略<a hidden class=anchor aria-hidden=true href=#页面分配策略>#</a></h4><h5 id=驻留集>驻留集<a hidden class=anchor aria-hidden=true href=#驻留集>#</a></h5><blockquote><p>请求分页存储管理中给进程分配的物理块集合</p></blockquote><ol><li>虚拟存储技术的系统中 驻留集一般小于进程总大小</li></ol><h5 id=页面分配置换策略>页面分配置换策略<a hidden class=anchor aria-hidden=true href=#页面分配置换策略>#</a></h5><ol><li>固定分配 & 可变分配<ul><li>驻留集大小在进程运行期间是否可变</li></ul></li><li>局部置换 & 全局置换<ul><li>缺页时 只能选进程自己的物理块进行置换</li><li>可选其他进程的物理块/操作系统保留的物理块</li></ul></li><li>固定分配局部置换<ul><li>难以在初期确定合理的物理块数目</li></ul></li><li>可变分配全局置换——选择未锁定页面换出外存 将其分配（只要缺页就分配新物理块）<ul><li>被选中的进程缺页率增加</li></ul></li><li>可变分配局部置换——频繁缺页 系统会多分配物理块</li></ol><h5 id=调入页面时机>调入页面时机<a hidden class=anchor aria-hidden=true href=#调入页面时机>#</a></h5><ol><li>预调页策略——相邻页面调入<ul><li>主要用于进程首次调入</li></ul></li><li>请求调页策略——缺页时调入</li></ol><h5 id=抖动现象颠簸>抖动现象（颠簸）<a hidden class=anchor aria-hidden=true href=#抖动现象颠簸>#</a></h5><blockquote><p>刚换出的页面马上需换入内存</p></blockquote><ol><li>原因：频繁访问的页面数目高于可用的物理块数（物理块不够）</li><li>工作集：某时间间隔里 进程<em>实际访问</em>页面的集合<ul><li>一般驻留集&lt;工作集 否则会频繁缺页</li></ul></li></ol><h4 id=内存映射文件memory-mapped-files>内存映射文件Memory-Mapped Files<a hidden class=anchor aria-hidden=true href=#内存映射文件memory-mapped-files>#</a></h4><ol><li>将文件映射到进程的虚拟地址空间——以访问内存的方式访问文件<ul><li>读入写出由操作系统负责</li></ul></li><li>多个进程可以映射同个文件 实现共享
<img loading=lazy src=img_15.png alt=img_15.png></li></ol><h3 id=文件管理>文件管理<a hidden class=anchor aria-hidden=true href=#文件管理>#</a></h3><blockquote><p>在磁盘（外存）中</p></blockquote><h4 id=文件的逻辑结构>文件的逻辑结构<a hidden class=anchor aria-hidden=true href=#文件的逻辑结构>#</a></h4><blockquote><p>逻辑结构 For用户（看来 内部数据如何组织） 物理结构 For操作系统（看来 文件数据如何存放在外存）</p></blockquote><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR
    逻辑结构--&gt;无结构文件
    逻辑结构--&gt;有结构文件
    有结构文件--&gt;顺序文件
   有结构文件--&gt;索引文件
   有结构文件--&gt;索引顺序文件
   顺序文件--&gt;顺序存储
   顺序文件--&gt;链式存储
</code></pre><ol><li>无结构文件（流式文件）——内部数据为一系列二进制流/字符流 eg.txt</li><li>有结构文件（记录式文件） 每条记录有一个数据项可作为关键字<ul><li>定长记录——各条记录长度相等</li><li>可变长记录——不等</li></ul></li></ol><h5 id=有结构文件的逻辑结构>有结构文件的逻辑结构<a hidden class=anchor aria-hidden=true href=#有结构文件的逻辑结构>#</a></h5><blockquote><p>各记录排列的顺序</p></blockquote><ol><li>顺序文件：记录按顺序排列（逻辑上的顺序） 定长/可变长记录<ul><li>串结构——记录的顺序与关键词无关</li><li>顺序结构——记录顺序按关键词顺序</li></ul></li><li>定长记录的顺序文件可实现随机存取 若采用顺序结构可快速找到关键字对应的记录（折半查找）<ul><li>可变长记录的顺序文件不能随机存取</li></ul></li><li>索引文件（加快文件检索速度）——可变长记录的顺序文件改进<ul><li>索引表自身为定长记录的顺序文件</li><li>可能会占用很大的内存空间</li></ul></li><li>索引顺序文件——索引表改进<ul><li>将文件数据分组 索引顺序文件储存分组信息</li><li>查找：先在索引顺序文件中顺序找分组 后在分组中顺序找记录</li></ul></li><li>多级索引顺序文件——索引顺序文件改进</li></ol><h4 id=文件目录>文件目录<a hidden class=anchor aria-hidden=true href=#文件目录>#</a></h4><ol><li>文件控制块FCB——包含文件基本信息<ul><li>FCB有序集合即为文件目录</li></ul></li><li>目录结构：<ol><li>单极目录结构 不允许文件重名</li><li>两级目录结构 = 主文件目录 + 用户文件目录<ul><li>允许不同用户的文件重名</li></ul></li><li>多级目录结构（树形结构）——用文件路径名标识文件 eg./users/local/bin<ul><li>树形结构不便于文件共享</li></ul></li><li>无环图目录结构——增加一些指向同节点的有向边（相当于共享）<ul><li>可设置共享计数器</li></ul></li></ol></li><li>索引结点：存放FCB中除文件名外的信息（用索引结点指针存放）<ul><li>加快查找效率</li></ul></li></ol><h4 id=文件物理结构>文件物理结构<a hidden class=anchor aria-hidden=true href=#文件物理结构>#</a></h4><ol><li>磁盘块：磁盘中分为many磁盘块 大小与内存块、页面大小相同<ul><li>逻辑块号 + 块内地址 = 文件的逻辑地址</li></ul></li><li>连续分配：要求每个文件在磁盘上占有一组连续的块<ul><li>文件目录需记录文件存放在磁盘中的起始块号&长度（总共占用几块）</li><li>优点：支持顺序访问与直接访问 & 顺序读写时速度最快（距离近 磁头移动更快）</li><li>缺点：存储空间利用率低 会产生磁盘碎片</li></ul></li><li>链接分配：离散分配 指针链接<ol><li>隐式链接——必须从上一个逻辑块中读到下一个块的物理地址<ul><li>只支持顺序读取 but 不会产生碎片</li></ul></li><li>显式链接——链接各物理块的指针显式存放在一张表中（文件分配表FAT File Allocation Table）<ul><li>一个磁盘仅一张FAT 开机时读入<strong>内存</strong>并常驻</li><li><em>FAT各表项</em>在物理上连续存储 且长度相同
<img loading=lazy src=img_16.png alt=img_16.png></li><li>支持顺序/随机访问 不会产生外部碎片 but FAT需要占用一定存储空间</li></ul></li></ol></li><li>索引分配：离散分配 每个文件都有一张索引表（记录文件逻辑块对应的物理块）<ul><li>索引表存放的磁盘块称为索引块（FCB中记录索引块位置） 文件数据存放的称为数据块</li><li>索引表过大 解决方案：<ol><li>链接方案——顺序读取各索引块</li><li>多层索引——需多次读磁盘</li><li>混合索引——多种索引分配方式结合 eg.有的直接地址索引 有的一级间接（单层索引表） 有的二级间接索引</li></ol></li><li>各级索引表不能超过一个块</li></ul></li></ol><h4 id=文件存储空间管理>文件存储空间管理<a hidden class=anchor aria-hidden=true href=#文件存储空间管理>#</a></h4><ol><li>存储空间划分与初始化<ul><li>将物理磁盘划分为文件卷（逻辑卷/逻辑盘） eg.C盘</li><li>文件卷包括目录区（存放FCB 存储空间管理的信息等）&文件区</li></ul></li><li>空闲表法——建立空闲表（包括空闲盘块号&空闲盘块数）<ul><li>分配回收与内存的动态分区分配类似</li></ul></li><li>空闲链表法——空闲盘块链/空闲盘区链（连续的盘块组成盘区）<ul><li>OS保存链头链尾指针</li><li>盘区链适用于离散分配&连续分配</li></ul></li><li>位示图法 每一格代表一个盘块 盘块号=ni+j（n为字长 i为字号 j为位号）<ul><li>空闲标0 不空标1
<img loading=lazy src=img_17.png alt=img_17.png></li></ul></li><li>成组链接法（UNIX采用）<ul><li>空闲表/链表法不适用于大型文件系统
<img loading=lazy src=img_18.png alt=img_18.png></li></ul></li></ol><h4 id=文件基本操作>文件基本操作<a hidden class=anchor aria-hidden=true href=#文件基本操作>#</a></h4><ol><li>创建文件：在外存中找到文件所需空间 + 创建该文件对应的目录项</li><li>删除文件：找到目录项 + 回收磁盘块 + 删除目录项</li><li>打开文件：找到目录项（检查权限） + 目录项复制到内存中的打开文件表<ul><li>打开文件表 系统有一总表 各进程也有表（记录读写指针 访问权限 系统表索引号）</li></ul></li><li>关闭文件：进程的打开文件表项删除 + 回收内存 + 系统打开文件总表计数器更改</li><li>读/写文件：读/写指针指向外存（文件数据存储处） OS将用户指定的数据读入内存<ul><li>写回写指针指向的外存数据</li></ul></li></ol><h4 id=文件共享>文件共享<a hidden class=anchor aria-hidden=true href=#文件共享>#</a></h4><ol><li>基于索引结点的共享方式——硬链接<ul><li>不同用户的目录下<strong>索引结点指针指向同一个索引结点</strong></li><li>索引结点中设置链接计数变量</li></ul></li><li>基于符号链的共享方式——软链接<ul><li>创建Link类型文件 根据其记录的路径查找目录 <em>eg.快捷方式</em></li></ul></li></ol><h4 id=文件保护>文件保护<a hidden class=anchor aria-hidden=true href=#文件保护>#</a></h4><ol><li>口令保护：为文件设置口令（保存在FCB中） 请求访问时验证<ul><li>口令存放在系统内部</li></ul></li><li>加密保护：对文件原始数据进行加密 eg.异或加密</li><li>访问控制：为文件的FCB/索引结点增加访问控制列表(Access-Control List,ACL)<ul><li>记录各用户可执行的操作</li></ul></li></ol><h3 id=设备管理>设备管理<a hidden class=anchor aria-hidden=true href=#设备管理>#</a></h3><h4 id=io设备分类>I/O设备分类<a hidden class=anchor aria-hidden=true href=#io设备分类>#</a></h4><blockquote><p>输入输出</p></blockquote><ol><li>分类：人机交互类外部设备 + 存储设备 + 网络通信设备 eg.猫<ul><li>人机…：数据传输速度慢 存储设备：数据传输速度快</li></ul></li><li>分类：低速设备 + 中速设备 + 高速设备</li><li>分类：块设备 + 字符设备<ul><li>以块为单位进行信息交换 eg.移动硬盘</li><li>字符设备常采用中断驱动方式</li></ul></li></ol><h4 id=io控制器>I/O控制器<a hidden class=anchor aria-hidden=true href=#io控制器>#</a></h4><blockquote><p>CPU控制I/O控制器 I/O控制器控制设备的机械部件</p></blockquote><ol><li>功能：<ol><li>接收识别CPU命令——控制寄存器存放</li><li>向CPU报告设备状态——状态寄存器</li><li>数据交换——数据寄存器</li><li>地址识别——为寄存器设置地址</li></ol></li><li>组成：CPU与控制器的接口 + I/O逻辑 + 控制器与设备的接口（多个）
<img loading=lazy src=img_19.png alt=img_19.png><ul><li>各寄存器也可能有多个</li></ul></li><li>寄存器地址分类：内存映像I/O——与内存地址统一编址 寄存器独立编址——使用单独的地址<ul><li>都储存在内存中</li></ul></li></ol><h4 id=io控制方式>I/O控制方式<a hidden class=anchor aria-hidden=true href=#io控制方式>#</a></h4><ol><li>程序直接控制方式：数据最后要存储到内存中
<img loading=lazy src=img_20.png alt=img_20.png><ul><li>CPU干预频繁</li><li>每次传送一个字</li><li>实现简单 but CPU与I/O只能串行工作 CPU长期处于忙等</li></ul></li><li>中断驱动方式：CPU发出命令后将等待I/O的进程阻塞
切换执行其它进程 I/O完成后发出中断信号 CPU检测到中断信号后处理中断（读一个字）
之后恢复进程运行环境（等待I/O或其它）<ul><li>CPU在每个指令周期末尾检查中断</li><li>中断时需要保存进程现有状态 频繁中断效率低</li></ul></li><li>DMA直接存储器存取——主要用于块设备的I/O控制<ul><li>数据从设备到内存 or 从内存到设备 不经过CPU<ul><li>CPU通过MAR内存地址寄存器等指明存放位置等信息</li></ul></li><li>可读写一个或连续的多个块</li><li>CPU只在传送的开始或结束时介入 but 只能读写连续的数据块</li></ul></li><li>通道控制 = 更弱的CPU（硬件）<ul><li>CPU只需发出I/O命令 完成后向CPU发出中断信号</li><li>可处理一组块</li></ul></li></ol><h4 id=io软件层次结构>I/O软件层次结构<a hidden class=anchor aria-hidden=true href=#io软件层次结构>#</a></h4><blockquote><p>know某处理是在哪层完成的
<img loading=lazy src=img_21.png alt=img_21.png></p></blockquote><ol><li>用户层软件：与用户交互 提供库函数进行操作 & 将用户请求转为I/O请求 用系统调用请求内核服务</li><li>设备独立性软件（与硬件特性无关的功能）<ul><li>如：向上层提供系统调用接口&设备保护（如访问权限）&差错处理&设备分配回收&数据缓冲区管理&逻辑、物理设备名映射</li><li>不同设备内部硬件特性不同——不同的设备驱动程序</li></ul></li><li>设备驱动程序：对硬件设备的具体控制 将命令转化为特定设备的操作</li><li>中断处理程序：I/O任务完成时控制器发送中断信号 系统根据中断信号类型找到中断处理程序</li></ol><h4 id=输入输出管理>输入输出管理<a hidden class=anchor aria-hidden=true href=#输入输出管理>#</a></h4><ol><li>I/O程序接口：<ol><li>字符设备接口 get/put系统调用</li><li>块设备 read/write seek——在读写指针处操作</li><li>网络设备 网络套接字socket接口 eg.localhost:1313 1313即为一个套接字<ul><li>可与其它ip地址的socket绑定 实现信息传输
<img loading=lazy src=img_22.png alt=img_22.png></li></ul></li><li>阻塞I/O 发出I/O系统调用进程需转为阻塞态 非阻塞I/O不需阻塞等待</li></ol></li><li>设备驱动程序接口——设备独立软件层</li></ol><h4 id=io核心子系统>I/O核心子系统<a hidden class=anchor aria-hidden=true href=#io核心子系统>#</a></h4><ol><li>I/O调度——类其它调度策略</li><li>设备保护——UNIX将设备视为特殊的文件</li></ol><h5 id=假脱机技术spooling>假脱机技术SPOOLing<a hidden class=anchor aria-hidden=true href=#假脱机技术spooling>#</a></h5><blockquote><p>用户层软件 模拟脱机技术</p></blockquote><ol><li>组成：缓冲区与井都暂存数据 位置不同
<img loading=lazy src=img_23.png alt=img_23.png></li><li>共享打印机原理——输出井为每个打印请求分配一个存储区（逻辑设备）</li></ol><h5 id=设备的分配与回收>设备的分配与回收<a hidden class=anchor aria-hidden=true href=#设备的分配与回收>#</a></h5><blockquote><p>设备独立性软件</p></blockquote><ol><li>设备分配考虑：设备固有属性 设备分配算法 设备分配安全性</li><li>分配方法：<ol><li>静态分配 运行前分配资源</li><li>动态分配 过程中分配</li></ol></li><li>分配管理的数据结构
<img loading=lazy src=img_24.png alt=img_24.png><ul><li>设备控制表DCT 指向COCT的指针</li><li>控制器控制表COCT 指向CHCT的指针</li><li>通道控制表CHCT 等待队列指针</li><li>系统设备表SDT 包括DCT</li></ul></li><li>分配步骤：根据物理设备名找SDT 从SDT找到DCT 到COCT找到控制器 到CHCT分配通道<ul><li>设备、控制器、通道都分配成功才成功</li><li>必须使用物理设备名——难换 & 若正忙进程必须阻塞等待</li></ul></li><li>改进：用逻辑设备名申请 OS用LUT（逻辑设备表）实现名称映射<ul><li>一张LUT中逻辑设备名不可重复 一般每个用户一张</li></ul></li></ol><h4 id=缓冲区>缓冲区<a hidden class=anchor aria-hidden=true href=#缓冲区>#</a></h4><ol><li>作用：缓和CPU与I/O设备速度不匹配的矛盾<ul><li>减少对CPU的中断频率</li><li>解决数据粒度不匹配问题（字符/块）</li></ul></li><li>单缓冲：主存中分配缓冲区——<strong>非空时不能进数据 空时可以进数据但必须充满</strong></li><li>双缓冲：分配2个缓冲区</li><li>循环缓冲区：多个大小相等的缓冲区链接为循环队列
<img loading=lazy src=img_25.png alt=img_25.png></li><li>缓冲池：系统中共用的缓冲区组成<ul><li>可分为空缓冲队列 装满输入数据的缓冲队列（输入队列） 输出队列</li><li>缓冲区种类：收容输入hin 提取输入sin 收容输出sout 提取输出hout</li></ul></li></ol><h4 id=磁盘>磁盘<a hidden class=anchor aria-hidden=true href=#磁盘>#</a></h4><h5 id=结构>结构<a hidden class=anchor aria-hidden=true href=#结构>#</a></h5><ol><li>磁盘上一圈为一个磁道 磁道被分为一个个扇区（即磁盘块）<ul><li>可能有很多盘面 但所有盘面<strong>连轴转</strong> 每个磁头<strong>共进退</strong></li><li>各扇区存放数据量相同
<img loading=lazy src=img_26.png alt=img_26.png></li></ul></li><li>读写数据：移到指定磁道 磁盘转动使目标扇区从磁头下划过实现</li><li>柱面号-盘面号-扇区号定位磁盘块<ul><li>柱面：所有盘面中相对位置相同的磁道（下图黄色部分）
<img loading=lazy src=img_27.png alt=img_27.png></li></ul></li><li>分类：活动头磁盘（磁臂可移动） 固定头磁盘（不可动 但有很多磁臂）<ul><li>也可按盘片可否更换分类</li></ul></li></ol><h5 id=磁盘调度算法>磁盘调度算法<a hidden class=anchor aria-hidden=true href=#磁盘调度算法>#</a></h5><ol><li>一次读写操作时间：<ol><li>寻找时间——读写数据前 磁臂移动到指定磁道</li><li>延迟时间——旋转磁盘 定位扇区</li><li>传输时间——从磁盘读出/写入数据</li></ol></li><li>调度算法：<ol><li>先来先服务FCFS：进程请求磁盘访问的先后顺序</li><li>最短寻找时间优先SSTF：优先处理离当前磁头最近的磁道<ul><li>可能饥饿</li></ul></li><li>扫描SCAN（电梯算法）：磁头移动到最外侧才能向内动 反之亦然<ul><li>不会饥饿 but 不同磁道响应频率不平均</li></ul></li><li>LOOK：若在移动方向上无其他请求 <strong>可以立即改变</strong>磁头移动方向</li><li>循环扫描C-SCAN：只有朝<strong>固定方向移动</strong>时才处理磁道访问请求 返回时直接到起始段<ul><li>响应频率平均 but 平均寻道时间更长</li></ul></li><li>C-LOOK：移动方向上若无其他请求立即返回</li></ol></li></ol><h5 id=减少延迟时间的方法>减少延迟时间的方法<a hidden class=anchor aria-hidden=true href=#减少延迟时间的方法>#</a></h5><blockquote><p>读取一块后就需要处理——但磁盘转动不停——下一块要转圈</p></blockquote><ol><li>交替编号——逻辑上相邻的扇区在物理上有间隔</li><li>磁盘地址结构设计：<details><summary>为什么柱面号在前？</summary>面对连续的地址如000,00,000-000,01,111 柱面号在前时不用移动磁臂；盘面号在前需移动磁臂</details></li><li>错位命名——改变相邻盘面对应顺序（相邻地址读取时间问题）
<img loading=lazy src=image_28.png alt="alt text"></li></ol><h5 id=磁盘管理理解>磁盘管理（理解）<a hidden class=anchor aria-hidden=true href=#磁盘管理理解>#</a></h5><ol><li>磁盘初始化：<ol><li>低级格式化（物理格式化）——划分扇区 分为头、数据区域、尾</li><li>磁盘分区——每个分区由若干柱面组成eg.C盘</li><li>逻辑格式化——创建文件系统（创建根目录 初始化数据结构eg.位示图）</li></ol></li><li>引导块（启动块/启动分区）——存放完整的自举程序<ul><li>启动块位于磁盘的固定位置</li><li>拥有启动分区的磁盘 = 启动磁盘/系统磁盘eg.C盘</li></ul></li><li>坏块（无法正确使用的扇区）<ul><li>简单的磁盘可在逻辑格式化时检查并标明</li><li>复杂的用磁盘控制器维护坏块链 管理备用扇区</li></ul></li></ol><h5 id=固态硬盘ssd>固态硬盘SSD<a hidden class=anchor aria-hidden=true href=#固态硬盘ssd>#</a></h5><blockquote><p>重点如下</p></blockquote><ol><li>主要结构：
<img loading=lazy src=image_29.png alt="alt text"></li><li>以页为单位读写 以块为单位进行数据擦除 方可重写每页<ul><li>先把不需擦除的页复制到其它闪存芯片对应位置 在其它芯片上写后整体移入原芯片</li><li>映射的物理位置可以改变</li><li>读快<strong>写慢</strong></li></ul></li><li>SSD的一个块被多次擦除可能会损坏</li><li>磨损均衡技术：将擦除平均分布在各个块上<ol><li>动态磨损均衡：写入数据时 优先选择累计擦除次数少的新闪存块</li><li>静态磨损均衡：SSD分配数据 让老旧闪存块承担以读为主任务 新的以写为主🥳🥳</li></ol></li></ol><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>来自王道408-操作系统&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref2:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref3:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref4:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref5:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></div><footer class=post-footer><ul class=post-tags><li><a href=https://Sattiluvcat.github.io/en/tags/408/>408</a></li></ul><nav class=paginav><a class=prev href=https://Sattiluvcat.github.io/en/posts/java/%E5%A4%96%E5%8D%96proj/><span class=title>« Prev</span><br><span>外卖Proj</span>
</a><a class=next href=https://Sattiluvcat.github.io/en/posts/notes/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><span class=title>Next »</span><br><span>数据结构</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统OS on x" href="https://x.com/intent/tweet/?text=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9fOS&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2f&amp;hashtags=408"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统OS on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2f&amp;title=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9fOS&amp;summary=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9fOS&amp;source=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统OS on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2f&title=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9fOS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统OS on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统OS on whatsapp" href="https://api.whatsapp.com/send?text=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9fOS%20-%20https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统OS on telegram" href="https://telegram.me/share/url?text=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9fOS&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 操作系统OS on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9fOS&u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://www-sattiluvcat-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><script id=dsq-count-scr src=//www-sattiluvcat-github-io.disqus.com/count.js async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://Sattiluvcat.github.io/en/>Satti's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")</script></body></html>