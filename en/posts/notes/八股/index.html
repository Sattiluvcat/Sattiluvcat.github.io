<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><head><script async src="https://www.googletagmanager.com/gtag/js?id=自己的G-MEASUREMENT_ID"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","自己的G-MEASUREMENT_ID")</script></head><title>八股 | Satti's Blog</title>
<meta name=keywords content="Java"><meta name=description content="梳理一些方便查看的主要知识内容"><meta name=author content="Satti"><link rel=canonical href=https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/><link crossorigin=anonymous href=/assets/css/stylesheet.c5df81d78a700d63222bf88c998222af7e6085cc41585cba2eff58e49fd49e25.css integrity="sha256-xd+B14pwDWMiK/iMmYIir35ghcxBWFy6Lv9Y5J/UniU=" rel="preload stylesheet" as=style><link rel=icon type=image/png href=/favicon-48x48.png sizes=48x48><link rel=icon type=image/svg+xml href=/favicon.svg><link rel="shortcut icon" href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta name=apple-mobile-web-app-title content="MyWebSite"><link rel=manifest href=/site.webmanifest><link rel=alternate hreflang=en href=https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script async src="https://www.googletagmanager.com/gtag/js?id=自己的G-MEASUREMENT_ID"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","自己的G-MEASUREMENT_ID")</script><meta property="og:title" content="八股"><meta property="og:description" content="梳理一些方便查看的主要知识内容"><meta property="og:type" content="article"><meta property="og:url" content="https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-08T17:00:48+08:00"><meta property="article:modified_time" content="2024-12-11T00:30:48+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="八股"><meta name=twitter:description content="梳理一些方便查看的主要知识内容"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://Sattiluvcat.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Notes📓","item":"https://Sattiluvcat.github.io/en/posts/notes/"},{"@type":"ListItem","position":3,"name":"八股","item":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"八股","name":"八股","description":"梳理一些方便查看的主要知识内容","keywords":["Java"],"articleBody":" 数据库 基本 数据库 常见名词 元组——一条记录就是一个元组（一行） 码——唯一标识实体的属性（一列） 候选码——候选的可以唯一标识元组的码（且不包括多余属性——否则为超键） 主码——主键 外码——另外关系中的主码 主属性（可以当候选码的） 非主属性（不包含在任何候选码的属性） ER图——实体联系图 包括：实体 属性 联系（实体与实体间的关系） 形状：矩形 椭圆 菱形（一一对应） 范式：1NF（第一范式） 2NF 3NF 1NF:字段有原子性 数据不可再分（每格数据不可再分） 2NF：消除非主属性对码的部分函数依赖（= 完全依赖） 一张表中 X确定 Y必确定 = X–\u003eY（Y函数依赖于X） X 的真子集 Xo–\u003eY（Y 部分函数依赖于 X）——数据冗余 CUD 异常 CRUD create read update delete 完全依赖：(X,Y)–\u003eZ 但X Y单个都不可依赖 3NF:所有非主键属性间不能依赖 必相互独立 外键与级联： 级联更新\u0026删除：更新/删除某主键 若其被其他表引用 则需更新/删除所有引用记录 delete vs drop vs truncate 用法：drop丢弃（table） truncate清空数据 id回到1 delete删除数据（行）id无影响 delete可以回滚 事务提交后生效（会产生日志） drop释放表空间 truncate不产生日志（不能回滚 NoSQL 与SQL的区别： 非结构化存储 vs 结构化存储（固定行和列） 通常不支持ACID vs ACID MongoDB支持 但有所区别 atom consistency isolation durability balabal vs 性能取决于磁盘子系统 优化查询 索引 表结构等获得最佳性能 横向拓展（基于分片机制——水平分割 以行为单位分割并分开存储） vs 垂直（读写分离 分库分表 ···） 特点：灵活 可拓展 高性能 类型：文档 键值 图形 宽列 字符集 utf8 utf8mb4\n字符集合 eg.ASCII UTF(Unicode) UTF-8 = 8比特UTF（一个字最多占3字节） UTF8mb4 = 一个字最多占据4字节的utf8 Mysql指定字符集优先级 server-数据库-表-字段column渐增 连接字符集：客户端与服务器沟通时相互翻译选择的字符集 JDBC（Java操控数据库的api）驱动会影响连接字符集 SQL database–\u003etable–\u003eschema(ok for table/db)–\u003ecolumn–\u003erow–\u003eprimary key\n注意：所有空格都被忽略 连接JOIN关键字 ON指定连接条件（最终生成临时表） left right关键词–\u003e即使右/左表没有满足条件的行也返回左/右表中的所有行 select something from table1 join table2 on table1.id=table2.id; 索引 事务 例题（窗口函数balabal略） MySql 基础 名词： 关系型数据库：基于关系模型的数据库 关系模型表明db中存储数据间的联系 SQL：结构化查询语言 字段 字段类型 数值 字符串 日期 DECIMAL vs FLOAT/DOUBLE –\u003e 避免精度损失 why：TEXT BLOB不建议？ 不常用：text ≈ 长文本的char varchar \u0026 bolb = 二进制大对象 缺点：不能有默认值 \u0026 智能在磁盘上创建临时表 \u0026 检索效率低 diff：NULL vs '' NULL代表一个不确定的值–\u003e不能用= != \u003e \u003c等运算符 \u0026 NULL=NULL ==\u003e False 只能用is NULL / is not NULL查询 ''长度为0 不占用空间 vs NULL要占用空间 how：boolean类型？ tinyint类型–\u003e只能存储0 or 1 架构 what：执行sql语句的流程？ 连接器——身份认证\u0026权限 查询缓存（mysql8.0后移除） 未命中后执行下述流程 分析器——检查语法··· 优化器——选择最优执行方案 执行器——执行前先判断有否权限 无权限则报错 有则从存储引擎返回数据 插件式存储引擎——数据的存储与读取 支持InnoDB MyIsam ··· 执行器与存储引擎交互 索引下推：MySql5.6 在联合索引遍历过程中，对联合索引中包含的字段先做判断 索引⭐⭐ 分类 数据结构 B+树——主键索引和二级索引默认 Hash Full-Text B+：每个节点存放按主键顺序的数据 叶子节点形成双向链表（下图来自(小林coding)[https://www.xiaolincoding.com/]） 索引与数据存储在磁盘 读取一个节点 = 进行一次磁盘I/O B树 = 没有双向链表的B+树 主键索引的树的叶子存放实际数据 二级索引的叶子存放主键值（虽然是按主键顺序 但表示还是按二级索引选用的物理量eg.学号 来表示） 二级索引查数据 = 二级索引树–\u003e主键树（此过程即为回表） B+优势： B+ vs B：B树非叶子节点也要存储数据（相同磁盘IO b+能查更多节点） 且没有双向链表（不能顺序查找） vs 二叉树：b+搜索复杂度$log_dN$ N个节点 每个节点最大子节点d个（一般大于100）——千万级对应3-4层 vs Hash：hash只适合等值查询 物理存储 聚簇索引（主键索引） 二级索引（辅助/非聚簇） 聚簇 = 主键：找到索引就找到了数据 有主键就是主键 无主键选第一个不含NULL的唯一列 也没有则InnoDB自创隐式自增ID列 非聚簇：用此索引不能找到数据（只找到主键） 需要回表查询 字段特性 主键索引 唯一索引（建立在UNIQUE字段上） 普通索引 前缀索引 前缀索引：针对字符类型字段的前几个字符建立 字段个数 单列索引 联合索引 联合索引：多个字段组合 eg.(product_no,name) 有先后顺序 联合索引的最左匹配：按最左优先的方式进行匹配 先找product_no 后找name 若某select只有name则该索引失效 联合索引的最左匹配遇到范围查询后失效 范围查询自身还有效 但若范围查询中有= 则还可以向后查询（准确来说用联合索引向后查的就只有=的情况） 联合索引最好把区分度大的放前面（distinct多的 如UUID） 在CS186中实现的是单列索引 键DataBox key 值（叶子节点）RecordId（唯一标识符） 也没有提前排序\n应用 缺点：占用物理空间（磁盘）+创建与维护耗时+降低增删改效率 适用索引的情况：UNIQUE字段 / 经常用于where/order by/group by的字段 不适用：大量重复/不怎么使用上述三种/表数据太少/经常更新的 优化方法：前缀索引优化 覆盖索引优化 主键索引最好是自增的 防止索引失效 前缀索引局限性：order by不能用（前缀后面的顺序不一定对） \u0026 不能用作覆盖索引 覆盖索引：查询的所有字段，在B+的叶子节点上都能找到（不用回表） 主键索引最好自增——插入方便（主键字段不要太长 二级索引叶子节点可以更小） 可能索引失效的情况：（in后条件导致sql大小超过范围索引内存限制–\u003e全表/田间个数接近或等于表数量–\u003e全表扫描） like %·· 类似最左前缀（所以是左模糊/左右模糊时失效） 对索引列做了计算 函数 类型转换操作 联合索引的最左前缀 where中 若or前条件为索引列 or后不是 则失效：优化器在处理OR操作符时，通常会选择一种能够处理所有条件的执行计划 事务⭐⭐ 特性：ACID 特性：原子性（要么全部完成 要么全部不完成） 一致性（事务操作前后，数据满足完整性约束） 隔离性（允许多个并发事务同时对其数据进行读写和修改） 持久性（事务处理结束后，对数据的修改就是永久的） 实现：A——undo log I——MVCC/锁 D——redo log C——前者共同保证 CS186中并发采用锁机制 恢复采用ARIES模型（各种日志）\n隔离性 并行事务可能引发的问题： 脏读——事务B读到事务A修改了但未提交的数据（A可能回滚 B读到的就是过期数据） 不可重复读——事务A多次读同个数据 前后两次读到的数据不一样（对应修改行） 幻读——在一个事务内多次查询某个符合查询条件的「记录数量」 查询到的数量不同（对应增删行） 严重性：从上到下递减 隔离级别：从上至下递增（效率递减） 读未提交——可读到未提交的事务 读提交——只能读已提交的事务 可重复读——一个事务执行过程看到的数据保持不变（InnoDB默认级别） 串行化——加读写锁 读写冲突时 后访问的事务等前一个完成后才能执行 InnoDB可以很大程度上避免幻读 其（InnoDB）实现： 快照读通过MVCC实现 MVCC中包括Read View Read Voew能实现读提交与可重复读\n快照读（普通select语句）——MVCC 可重复读条件下 插入的数据无法查询 当前读（其它语句 如select ··· for update update时要获得最新的数据）——通过记录锁+间隙锁(next-key lock)解决 在二锁的范围内插入的数据被阻塞 无法成功插入 Read View in MVCC,how to work?通过版本链控制并发事务访问同个记录 = MVCC（多版本并发控制） ReadView四个字段： m_ids：当前数据库「活跃事务」（启动了未提交）的事务 id 列表 min_trx_id：「活跃事务」中事务 id 最小的事务 max_trx_id：创建RV时全局事务中最大的事务 id 值 + 1（RV没照到的事务） creator_trx_id：创建该 Read View 的事务的 id 聚簇索引的两个隐藏列： trx_id：当一个事务对某条聚簇索引记录进行改动时，把该事务的 id 记录在此处 roll_pointer：对聚簇索引记录改动时 把旧版本的记录写入undo log 此隐藏列作为指针指向该旧版本记录（so可以找到后恢复） 一个事务访问记录时：（自己的记录总是可见） trxId可见 trxId\u003emax：创建RV后的启动的事务–\u003e不可见 在min与max之间：属于m_ids = 未提交的事务–\u003e不可见 / 不属于 = 已提交的事务–\u003e可见 读提交\u0026可重复读的实现：Read View（类似快照）「读提交」在「每个语句执行前」都生成 「可重复读」在「启动事务时」生成 explain：读提交在事务中也是每句都重新生成快照 B线程在期间更改数据也会被A线程快照到–\u003e事务中间数据会发生变化 CS186中实现的大概是串行化级别 一个线程（事务）添加X锁（排他锁）后 其它线程被加入阻塞队列 直到表上的X锁被释放\nMySql可重复读与幻读 记录锁+间隙锁可以防删除——主键索引被记录锁锁定 无法删除 间隙锁可以防插入\n不能防止幻读的例子： A事务先普通select（快照读） B事务插入数据并提交 A事务update插入的数据（当前读） A再次select–\u003e成功 A第一次select时并没有加锁 此时若A不update 直接select for update效果相同 解决：先做for update 事务提交时行级锁才会解除 锁⭐⭐⭐ 锁的分类 for all：SS兼容 SX不兼容 XX不兼容\n全局锁 + 表级锁 + 行级锁 全局锁：flush tables with read lock 主要用于全局逻辑备份 怎么又备份又不影响业务？在可重复读的级别下开启事务（MVCC支持） 表级锁 = 表锁 + 元数据锁（MDL） + 意向锁 + AUTO-INC锁 表锁：lock tables student read 其它线程不可写 该线程只可读此表（不能写 也不能操作其他表） MDL：对表进行CRUD = 加MDL读锁 对表做结构更改 = 写锁 事务提交时释放锁 why申请不到写锁 转而申请读锁也被阻塞？ 申请锁的请求形成队列 写锁优先级高于读锁（写锁等待时 该表的CRUD操作全部阻塞） 普通select不会加锁 用MVCC实现 但CS186中普通select是加了读锁的\n意向锁：IS IX 意向锁之间不会冲突 只与表锁冲突 用于判断表里是否有记录被加锁 AUTO-INC：掌管主键自增 插入完释放（避免其他事务同时插入 主键不连续自增） 轻量级锁（MySql5.1.22 ）为字段赋自增值后释放 不需等整个插入语句执行完 轻量级锁在主从复制时会出错（线程AB分别向表中插入记录 binlog记录原始语句 先记完A或B才能记别的 写入从库时重新insert 序号会变化） 设置binlog_format=row 解决（保留主库中序号） 行级锁： 记录锁：锁一条记录S or X 间隙锁范围：如update记录25 只有10 20 30 –\u003e锁住20~30\n间隙锁：只存在于可重复读（解决该级别幻读） + 锁不互斥（可以包含共同间隙范围） + 不包含边界 临键锁（二者结合）：包含边界 有互斥 插入意向锁：不是意向锁 插入的位置遇到间隙锁时生成 状态为等待 间隙锁释放后此锁开始作用 是一种特殊的间隙锁 类似于锁住一个点 MySql怎么加锁 串行化级别select语句会加锁\n加行级锁：索引加锁 基本单位next-key lock 事务提交后才释放 在使用记录锁或者间隙锁就能避免幻读现象的场景下会退化 分析加锁命令：select * from performance_schema.data_locks\\G;\n非唯一索引（主键+二级 非unique字段） 等值查询：两索引都加锁 但主键索引只对满足条件的索引加锁（查询结果存在 主键索引加记录锁 不存在则主键索引不加锁） 范围查询：二级索引不退化 若不加索引进行查询 = 全表扫描 = 每条记录的索引都加next-key lock = 全部锁住 死锁 由next-key lock造成\n两个线程select for update 都要插入–\u003e等对方间隙锁释放才可获取插入意向锁 避免死锁： 必要条件：互斥 占有且等待 不可强占用 循环等待 方法：设置等待锁的超时时间 / 开启主动死锁检测 日志⭐ why undo log？ 事务提交前有用\n保证原子性 可以回滚——记录每步操作 实现MVCC的关键因素——undo log的版本链为每条记录保存多份历史数据 why buffer pool? 作用：缓存数据 客户端可以直接读取 + 修改数据可以直接修改pool中的 并标记为脏页（与磁盘记录不一致） 缓存什么？以页为单位（16KB） CS186中 GHJ用作join两个大表 外部归并排序用作将一个大表（可能是join的结果）进行排序后存放到页上\n缓存数据页 索引页 undo页（记录undolog） 锁信息 自适应哈希索引插入缓存页 查询一条记录会把整页数据加载到pool why redo log? 过程：先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录–\u003e后台线程适时将脏页刷盘 先写日志后刷盘 == WAL 事务提交时 先持久化redolog undolog修改也要记录到redolog 作用：实现事务持久化 crash-safe + 写操作从随机写变为顺序写（redolog在磁盘中为追加操作 顺序写） redo自身是循环写 redo undo的区别：redo记录事务修改后状态 用于崩溃恢复；undo记录事务修改前状态 用于回滚 redolog与binlog的区别：（binlog原来是MyISAM中的 没有crash-safe能力 InnoDB实现了这个功能） binlog不记录查询语句 在每条更新语句后生成 事务提交时会把binlog统一写入binlog文件\nbin是server层实现的 redo是引擎实现的 redo是物理日志（记录做了什么修改如在·处做了·更新）bin有statement模式（只记录操作如update 逻辑日志）、row模式（记录数据如一行）、mixed（自动切换） bin是追加写 redo循环写 bin用于主从复制 备份恢复 redo用于故障恢复 主从复制实现？ 依赖binlog 记录mysql所有变化并以二进制形式保存在磁盘上 将其传到从库以实现复制（一般异步 主库不等复制） 二者建立联系 此后一直保持联系 binlog什么时候刷盘？ 事务执行过程中 先把日志写到binlog cache 提交时将其写入binlog 慢查询日志——记录执行时长超过阈值的查询语句 用途：需要优化的查询 监控应用程序的数据库交互性能 容量规划 两阶段提交 why need？binlog与redo不同时进行 若有一个没成功刷盘 都会主从不一致 过程： prepare阶段：将内部XA事务的ID（XID）写入redo 将其事务状态设置为prepare redo持久化 commit阶段：XID写入binlog binlog持久化 redo状态设置为commit 此状态write到page cache 若遇prepare态redolog 找binlog中是否有XID–\u003e有则提交事务 无则回滚事务 binlog组提交——多个事务提交时 多个binlog刷盘操作合并为一个 MySQL磁盘I/O很高的优化方法——延迟binlog redolog的刷盘时机 性能与架构 explain：查看sql执行计划 如是否走索引 有无外部排序 有无索引覆盖 explain的索引不对–\u003e使用force index强制索引\n查询速度慢 怎么解决？ 用explain分析查询语句 创建或优化索引 避免索引失效 查询优化（select *） 优化数据库表（拆分为小表） 缓存技术 主从延迟解决：强制走主库（针对大事务/资源密集型操作） 分库分表是什么\u0026区别： 分库：水平扩展数据库 数据按一定规则划分到多个独立数据库 每个数据库只存储部分数据（分布式存储）–\u003e解决并发连接过多问题 分表：单个数据库中的表拆分为多个表–\u003e提高查询效率 减轻单表压力–\u003e解决单表数据量过大 查询性能下降问题 分库分表操作： 垂直分库（竖着切）：根据业务与功能的维度 将不同业务数据放到不同数据库——专库专用 没有解决单表数据量过大的问题 垂直分表：字段比较多的大表 将较为独立或不常用的字段拆分到单独的数据表中 核心表字段长度较短 可以加载更多数据到内存中 减少磁盘IO 水平分库（横着切）：同个表按一定规则拆分到不同数据库中（表结构不变） 效率高 但数据访问需要额外的路由工作 系统复杂度高 水平分表：拆分到同个数据库内（表结构不变） 只解决了单表过大的问题 还要竞争同个物理机的CPU 内存等 存储引擎 架构？ 插件式架构 基于表（非数据库） MyISAM vs InnoDB 行级锁 \u0026 MVCC ==\u003e 不支持 vs 支持 事务 \u0026 崩溃后的恢复 （同上）InnoDB使用redo log（同CS186） 外键 （同上） 非聚簇索引 vs 聚簇索引 缓存 键缓存（仅缓存数据页） vs buffer pool缓存数据页\u0026索引页 查询缓存 nothing\nRedis 杂七杂八⭐⭐ 进程与线程的区别？ 进程是OS层面 是程序的一次执行过程 一个进程内可能有多个线程 线程是CPU调度的基本单位 共享进程的地址空间与内存资源 Java中 不同线程拥有独立的JVM栈（java虚拟机） 本地方法栈 程序计数器 进程通信需要管道、信号量等 线程通信通过共享资源的读写操作实现 Map底层实现： HashMap：JDK1.8之前 数组+链表（解决哈希冲突问题——拉链法） vs JDK1.8后 链表长度大于阈值（一般为8）时 数组长度小于64就进行数组扩容 大于时将链表转换为红黑树 LinkedHashMap：继承HashMap 加入双向链表 使键值对可以保持插入顺序 HashTable：由数组和链表组成 类似HashMap的初始形式 TreeMap：红黑树 解释型与编译型： 编译型语言，通过编译器将源代码一次性翻译成可被执行的机器码。执行快 开发慢 解释型语言。通过解释器一句一句的解释，边解释边执行。开发快，执行慢 Java：编译与解释并存。Java程序要先编译生成字节码（.class文件） 后字节码通过Java解释器来解释执行 JIT vs AOT(ahead of time compilation)JDK9引入新的编译模式 AOT：程序执行前将其编译为机器码，属于静态编译 避免JIT预热等开销 可以提高启动速度 + 减少内存占用 + 增强Java程序安全性 but：无法支持Java动态特性，如反射 动态代理 动态加载 JNI等 JIT：具有更高的极限处理能力，能够降低请求的最大延迟 ","wordCount":"7520","inLanguage":"en","datePublished":"2024-12-08T17:00:48+08:00","dateModified":"2024-12-11T00:30:48+08:00","author":[{"@type":"Person","name":"Satti"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/"},"publisher":{"@type":"Organization","name":"Satti's Blog","logo":{"@type":"ImageObject","url":"https://Sattiluvcat.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Sattiluvcat.github.io/en/ accesskey=h title="Satti's Blog (Alt + H)"><img src=https://Sattiluvcat.github.io/img/label1.jpg alt aria-label=logo height=35>Satti's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Sattiluvcat.github.io/en/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://Sattiluvcat.github.io/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://Sattiluvcat.github.io/en/tags title=📑标签><span>📑标签</span></a></li><li><a href=https://Sattiluvcat.github.io/en/lulu/ title=😽Lulu><span>😽Lulu</span></a></li><li><a href=https://Sattiluvcat.github.io/en/archives/ title=📅时间轴><span>📅时间轴</span></a></li><li><a href=https://Sattiluvcat.github.io/en/about/ title=😎关于><span>😎关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Sattiluvcat.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/>文章</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/notes/>Notes📓</a></div><h1 class="post-title entry-hint-parent">八股</h1><div class=post-description>梳理一些方便查看的主要知识内容</div><div class=post-meta><span title='2024-12-08 17:00:48 +0800 +0800'>2024-12-08</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;<span title='Last updated 2024-12-11 00:30:48 +0800 +0800'>Last updated on 2024-12-11</span>&nbsp;·&nbsp;Satti</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93 aria-label=数据库>数据库</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac aria-label=基本>基本</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93-1 aria-label=数据库>数据库</a></li><li><a href=#nosql aria-label=NoSQL>NoSQL</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e9%9b%86 aria-label=字符集>字符集</a></li></ul></li><li><a href=#sql aria-label=SQL>SQL</a></li><li><a href=#mysql aria-label=MySql>MySql</a><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a></li><li><a href=#%e5%ad%97%e6%ae%b5 aria-label=字段>字段</a></li><li><a href=#%e6%9e%b6%e6%9e%84 aria-label=架构>架构</a></li><li><a href=#%e7%b4%a2%e5%bc%95 aria-label=索引⭐⭐>索引⭐⭐</a><ul><li><a href=#%e5%88%86%e7%b1%bb aria-label=分类>分类</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a></li><li><a href=#%e7%89%a9%e7%90%86%e5%ad%98%e5%82%a8 aria-label=物理存储>物理存储</a></li><li><a href=#%e5%ad%97%e6%ae%b5%e7%89%b9%e6%80%a7 aria-label=字段特性>字段特性</a></li><li><a href=#%e5%ad%97%e6%ae%b5%e4%b8%aa%e6%95%b0 aria-label=字段个数>字段个数</a></li></ul></li><li><a href=#%e5%ba%94%e7%94%a8 aria-label=应用>应用</a></li></ul></li><li><a href=#%e4%ba%8b%e5%8a%a1 aria-label=事务⭐⭐>事务⭐⭐</a><ul><li><a href=#%e9%9a%94%e7%a6%bb%e6%80%a7 aria-label=隔离性>隔离性</a></li><li><a href=#mysql%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e4%b8%8e%e5%b9%bb%e8%af%bb aria-label=MySql可重复读与幻读>MySql可重复读与幻读</a></li></ul></li><li><a href=#%e9%94%81 aria-label=锁⭐⭐⭐>锁⭐⭐⭐</a><ul><li><a href=#%e9%94%81%e7%9a%84%e5%88%86%e7%b1%bb aria-label=锁的分类>锁的分类</a></li><li><a href=#mysql%e6%80%8e%e4%b9%88%e5%8a%a0%e9%94%81 aria-label=MySql怎么加锁>MySql怎么加锁</a></li><li><a href=#%e6%ad%bb%e9%94%81 aria-label=死锁>死锁</a></li></ul></li><li><a href=#%e6%97%a5%e5%bf%97 aria-label=日志⭐>日志⭐</a><ul><li><a href=#%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4 aria-label=两阶段提交>两阶段提交</a></li></ul></li><li><a href=#%e6%80%a7%e8%83%bd%e4%b8%8e%e6%9e%b6%e6%9e%84 aria-label=性能与架构>性能与架构</a></li><li><a href=#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e aria-label=存储引擎>存储引擎</a></li><li><a href=#%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98 aria-label=查询缓存>查询缓存</a></li></ul></li><li><a href=#redis aria-label=Redis>Redis</a></li></ul></li><li><a href=#%e6%9d%82%e4%b8%83%e6%9d%82%e5%85%ab aria-label=杂七杂八⭐⭐>杂七杂八⭐⭐</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p> </p><p> </p><h2 id=数据库>数据库<a hidden class=anchor aria-hidden=true href=#数据库>#</a></h2><h3 id=基本>基本<a hidden class=anchor aria-hidden=true href=#基本>#</a></h3><h4 id=数据库-1>数据库<a hidden class=anchor aria-hidden=true href=#数据库-1>#</a></h4><ol><li>常见名词<ol><li>元组——一条记录就是一个元组（一行）</li><li>码——唯一标识实体的属性（一列）<ol><li>候选码——候选的可以唯一标识元组的码（且不包括多余属性——否则为<strong>超键</strong>）</li><li>主码——主键</li><li><strong>外码</strong>——另外关系中的主码</li><li>主属性（可以当候选码的） 非主属性（不包含在任何候选码的属性）</li></ol></li></ol></li><li>ER图——实体联系图<ol><li>包括：实体 属性 联系（实体与实体间的关系）</li><li>形状：矩形 椭圆 菱形（一一对应）</li></ol></li><li><strong>范式</strong>：1NF（第一范式） 2NF 3NF<ol><li>1NF:字段有原子性 数据不可再分（每格数据不可再分）</li><li>2NF：消除非主属性对码的部分函数依赖（= 完全依赖）<ol><li>一张表中 X确定 Y必确定 = X&ndash;>Y（Y函数依赖于X）</li><li>X 的真子集 Xo&ndash;>Y（Y 部分函数依赖于 X）——数据冗余 CUD 异常</li></ol><ul><li>CRUD create read update delete</li></ul><ol start=3><li>完全依赖：(X,Y)&ndash;>Z 但X Y单个都不可依赖</li></ol></li><li>3NF:所有非主键属性间不能依赖 必相互独立</li></ol></li><li>外键与级联：<ol><li>级联更新&删除：更新/删除某主键 若其被其他表引用 则需更新/删除所有引用记录</li></ol></li><li>delete vs drop vs truncate<ol><li>用法：drop丢弃（table） truncate清空数据 id回到1 delete删除数据（行）id无影响</li><li>delete可以回滚 事务提交后生效（会产生日志）</li><li>drop释放表空间 truncate不产生日志（不能回滚</li></ol></li></ol><h4 id=nosql>NoSQL<a hidden class=anchor aria-hidden=true href=#nosql>#</a></h4><ol><li>与SQL的区别：<ol><li>非结构化存储 vs 结构化存储（固定行和列）</li><li>通常不支持ACID vs ACID<ol><li>MongoDB支持 但有所区别</li><li>atom consistency isolation durability</li></ol></li><li>balabal vs 性能取决于磁盘子系统 优化查询 索引 表结构等获得最佳性能</li><li>横向拓展（基于分片机制——水平分割 以行为单位分割并分开存储） vs 垂直（读写分离 分库分表 ···）</li></ol></li><li>特点：灵活 可拓展 高性能</li><li>类型：文档 键值 图形 宽列</li></ol><h4 id=字符集>字符集<a hidden class=anchor aria-hidden=true href=#字符集>#</a></h4><blockquote><p>utf8 utf8mb4</p></blockquote><ol><li>字符集合 eg.ASCII UTF(Unicode)</li><li>UTF-8 = 8比特UTF（一个字最多占3字节） UTF8mb4 = 一个字最多占据4字节的utf8<ol><li>Mysql指定字符集优先级 server-数据库-表-字段column渐增</li></ol></li><li>连接字符集：客户端与服务器沟通时相互翻译选择的字符集<ol><li>JDBC（Java操控数据库的api）驱动会影响连接字符集</li></ol></li></ol><h3 id=sql>SQL<a hidden class=anchor aria-hidden=true href=#sql>#</a></h3><blockquote><p>database&ndash;>table&ndash;>schema(ok for table/db)&ndash;>column&ndash;>row&ndash;>primary key</p></blockquote><ol><li>注意：所有空格都被忽略</li><li>连接JOIN关键字 ON指定连接条件（最终生成临时表）<ol><li>left right关键词&ndash;>即使右/左表<strong>没有满足条件的行</strong>也返回左/右表中的<strong>所有行</strong></li></ol></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>something</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>table1</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>table2</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=n>table1</span><span class=p>.</span><span class=n>id</span><span class=o>=</span><span class=n>table2</span><span class=p>.</span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ol start=3><li>索引 事务</li><li>例题（窗口函数balabal略）</li></ol><h3 id=mysql>MySql<a hidden class=anchor aria-hidden=true href=#mysql>#</a></h3><h4 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h4><ol><li>名词：<ol><li>关系型数据库：基于关系模型的数据库 关系模型表明db中存储数据间的联系</li><li>SQL：结构化查询语言</li></ol></li></ol><h4 id=字段>字段<a hidden class=anchor aria-hidden=true href=#字段>#</a></h4><ol><li><a href=https://Sattiluvcat.github.io/en/posts/java/mysql_base/#创建>字段类型</a><ul><li>数值 字符串 日期</li></ul></li><li>DECIMAL vs FLOAT/DOUBLE &ndash;> 避免精度损失</li><li>why：TEXT BLOB不建议？<ol><li>不常用：text ≈ 长文本的char varchar & bolb = 二进制大对象</li><li>缺点：不能有默认值 & 智能在磁盘上创建临时表 & 检索效率低</li></ol></li><li>diff：NULL vs ''<ol><li>NULL代表一个<strong>不确定</strong>的值&ndash;>不能用<code>= != > &lt;</code>等运算符 & <code>NULL=NULL</code> ==> False<ul><li>只能用<code>is NULL / is not NULL</code>查询</li></ul></li><li><code>''</code>长度为0 不占用空间 vs NULL要占用空间</li></ol></li><li>how：boolean类型？<ol><li><code>tinyint</code>类型&ndash;>只能存储0 or 1</li></ol></li></ol><h4 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>#</a></h4><ol><li>what：执行sql语句的流程？<ul><li>连接器——身份认证&权限</li><li>查询缓存（mysql8.0后移除） 未命中后执行下述流程</li><li>分析器——检查语法···</li><li>优化器——选择最优执行方案</li><li>执行器——执行前先判断有否权限 无权限则报错 有则从存储引擎返回数据</li><li>插件式<strong>存储</strong>引擎——数据的<strong>存储与读取</strong> 支持InnoDB MyIsam ···</li></ul></li><li>执行器与存储引擎交互<ul><li>索引下推：<em>MySql5.6</em> 在联合索引遍历过程中，对联合索引中包含的字段先做判断</li></ul></li></ol><h4 id=索引>索引⭐⭐<a hidden class=anchor aria-hidden=true href=#索引>#</a></h4><h5 id=分类>分类<a hidden class=anchor aria-hidden=true href=#分类>#</a></h5><h6 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h6><ol><li>B+树——主键索引和二级索引默认</li><li>Hash</li><li>Full-Text</li><li>B+：每个节点存放<strong>按主键顺序</strong>的数据 叶子节点形成<strong>双向链表</strong>（下图来自(小林coding)[https://www.xiaolincoding.com/]）
<img loading=lazy src=image.png alt="alt text"><ul><li>索引与数据存储在<strong>磁盘</strong> 读取一个节点 = 进行一次磁盘I/O<ul><li>B树 = 没有双向链表的B+树</li></ul></li><li>主键索引的树的叶子存放实际数据 <strong>二级索引的叶子存放主键值</strong>（虽然是按主键顺序 但表示还是按二级索引选用的物理量eg.学号 来表示）</li><li>二级索引查数据 = 二级索引树&ndash;>主键树（此过程即为回表）</li></ul></li><li>B+优势：<ul><li>B+ vs B：B树非叶子节点也要存储数据（相同磁盘IO b+能查更多节点） 且没有双向链表（不能顺序查找）</li><li>vs 二叉树：b+搜索复杂度$log_dN$ N个节点 每个节点最大子节点d个（一般大于100）——千万级对应3-4层</li><li>vs Hash：hash只适合等值查询</li></ul></li></ol><h6 id=物理存储>物理存储<a hidden class=anchor aria-hidden=true href=#物理存储>#</a></h6><ol><li>聚簇索引（主键索引） 二级索引（辅助/非聚簇）<ul><li>聚簇 = 主键：找到索引就找到了数据<ul><li>有主键就是主键 无主键选第一个不含NULL的唯一列 也没有则InnoDB自创隐式自增ID列</li></ul></li><li>非聚簇：用此索引不能找到数据（只找到主键） 需要回表查询</li></ul></li></ol><h6 id=字段特性>字段特性<a hidden class=anchor aria-hidden=true href=#字段特性>#</a></h6><ol><li>主键索引 唯一索引（建立在UNIQUE字段上） 普通索引 前缀索引<ol><li>前缀索引：针对字符类型字段的前几个字符建立</li></ol></li></ol><h6 id=字段个数>字段个数<a hidden class=anchor aria-hidden=true href=#字段个数>#</a></h6><ol><li>单列索引 联合索引<ul><li>联合索引：多个字段组合 eg.(product_no,name) 有先后顺序
<img loading=lazy src=image-1.png alt="alt text"></li></ul></li><li>联合索引的最左匹配：按<strong>最左优先</strong>的方式进行匹配<ul><li>先找product_no 后找name 若某select只有name则该索引失效</li></ul></li><li>联合索引的最左匹配遇到<strong>范围查询后</strong>失效<ul><li>范围查询<strong>自身还有效</strong></li><li>但若范围查询中有<code>=</code> 则还可以向后查询（准确来说用联合索引向后查的就只有<code>=</code>的情况）</li></ul></li><li>联合索引最好把区分度大的放前面（distinct多的 如UUID）</li></ol><blockquote><p>在CS186中实现的是单列索引 键DataBox key 值（叶子节点）RecordId（唯一标识符）<br>也没有提前排序</p></blockquote><h5 id=应用>应用<a hidden class=anchor aria-hidden=true href=#应用>#</a></h5><ol><li>缺点：占用物理空间（磁盘）+创建与维护耗时+降低增删改效率</li><li>适用索引的情况：UNIQUE字段 / 经常用于<code>where</code>/<code>order by</code>/<code>group by</code>的字段</li><li>不适用：大量重复/不怎么使用上述三种/表数据太少/经常更新的</li><li>优化方法：前缀索引优化 覆盖索引优化 主键索引最好是自增的 防止索引失效<ul><li>前缀索引局限性：order by不能用（前缀后面的顺序不一定对） & 不能用作覆盖索引</li><li>覆盖索引：查询的所有字段，在B+的叶子节点上都能找到（不用回表）</li><li>主键索引最好自增——插入方便（主键字段不要太长 二级索引叶子节点可以更小）</li></ul></li><li>可能索引失效的情况：（in后条件导致sql大小超过范围索引内存限制&ndash;>全表/田间个数接近或等于表数量&ndash;>全表扫描）<ul><li><code>like %··</code> 类似最左前缀（所以是左模糊/左右模糊时失效）</li><li>对索引列做了计算 函数 类型转换操作</li><li>联合索引的最左前缀</li><li>where中 若or前条件为索引列 or后不是 则失效：<strong>优化器</strong>在处理OR操作符时，通常会选择一种<strong>能够处理所有条件</strong>的执行计划</li></ul></li></ol><h4 id=事务>事务⭐⭐<a hidden class=anchor aria-hidden=true href=#事务>#</a></h4><ol><li>特性：ACID<ul><li>特性：<strong>原子性</strong>（要么全部完成 要么全部不完成） <strong>一致性</strong>（事务操作前后，数据满足完整性约束） <strong>隔离性</strong>（允许多个并发事务同时对其数据进行读写和修改） <strong>持久性</strong>（事务处理结束后，对数据的修改就是永久的）</li></ul></li><li>实现：A——undo log I——MVCC/锁 D——redo log C——前者共同保证</li></ol><blockquote><p>CS186中并发采用锁机制 恢复采用ARIES模型（各种日志）</p></blockquote><h5 id=隔离性>隔离性<a hidden class=anchor aria-hidden=true href=#隔离性>#</a></h5><ol><li>并行事务可能引发的问题：<ul><li><strong>脏读</strong>——事务B读到事务A修改了但未提交的数据（A可能回滚 B读到的就是过期数据）</li><li><strong>不可重复读</strong>——事务A多次读同个数据 前后两次读到的数据不一样（对应<strong>修改</strong>行）</li><li><strong>幻读</strong>——在一个事务内多次查询某个符合查询条件的「记录数量」 查询到的数量不同（对应<strong>增删</strong>行）</li><li>严重性：从上到下递减</li></ul></li><li>隔离级别：从上至下递增（效率递减）<ol><li>读未提交——可读到未提交的事务</li><li>读提交——只能读已提交的事务</li><li>可重复读——一个事务执行过程看到的数据保持不变（<strong>InnoDB默认级别</strong>）</li><li>串行化——加<strong>读写锁</strong> 读写冲突时 后访问的事务等前一个完成后才能执行</li></ol></li><li>InnoDB可以<strong>很大程度</strong>上避免幻读 其（InnoDB）实现：<blockquote><p>快照读通过MVCC实现 MVCC中包括Read View Read Voew能实现读提交与可重复读</p></blockquote><ul><li>快照读（普通select语句）——MVCC 可重复读条件下 插入的数据无法查询</li><li>当前读（其它语句 如select ··· for update update时要获得最新的数据）——通过记录锁+间隙锁(next-key lock)解决 在二锁的范围内插入的数据被阻塞 无法成功插入</li></ul></li><li>Read View in MVCC,how to work?通过版本链控制并发事务访问同个记录 = MVCC（多版本并发控制）<ul><li>ReadView四个字段：<ul><li>m_ids：当前数据库「活跃事务」（启动了未提交）的事务 id 列表</li><li>min_trx_id：「活跃事务」中事务 id 最小的事务</li><li>max_trx_id：创建RV时全局事务中最大的事务 id 值 + 1（RV没照到的事务）</li><li>creator_trx_id：创建该 Read View 的事务的 id</li></ul></li><li>聚簇索引的两个隐藏列：<ul><li>trx_id：当一个事务对某条聚簇索引记录进行改动时，把该事务的 id 记录在此处</li><li>roll_pointer：对聚簇索引记录改动时 把旧版本的记录写入undo log 此隐藏列作为指针指向该旧版本记录（so可以找到后恢复）</li></ul></li><li>一个事务访问记录时：（自己的记录总是可见）<ul><li>trxId&lt;min：该记录是（创建RV前）已提交事务生成的&ndash;>可见</li><li>trxId>max：创建RV后的启动的事务&ndash;>不可见</li><li>在min与max之间：属于m_ids = 未提交的事务&ndash;>不可见 / 不属于 = 已提交的事务&ndash;>可见</li></ul></li></ul></li><li>读提交&可重复读的实现：<strong>Read View</strong>（类似快照）「读提交」在「<strong>每个语句执行前</strong>」都生成 「可重复读」在「<strong>启动事务时</strong>」生成<ul><li>explain：读提交在事务中也是每句都重新生成快照 B线程在期间更改数据也会被A线程快照到&ndash;>事务中间数据会发生变化</li></ul></li></ol><blockquote><p>CS186中实现的大概是串行化级别 一个线程（事务）添加X锁（排他锁）后 其它线程被加入阻塞队列 直到表上的X锁被释放</p></blockquote><h5 id=mysql可重复读与幻读>MySql可重复读与幻读<a hidden class=anchor aria-hidden=true href=#mysql可重复读与幻读>#</a></h5><blockquote><p>记录锁+间隙锁可以防删除——主键索引被记录锁锁定 无法删除 间隙锁可以防插入</p></blockquote><ol><li>不能防止幻读的例子：<ol><li>A事务先普通select（快照读） B事务插入数据并提交 A事务update插入的数据（当前读） A再次select&ndash;>成功<ul><li>A第一次select时并没有加锁</li><li>此时若A不update 直接select for update效果相同</li></ul></li></ol></li><li>解决：先做for update <strong>事务提交时行级锁才会解除</strong></li></ol><h4 id=锁>锁⭐⭐⭐<a hidden class=anchor aria-hidden=true href=#锁>#</a></h4><h5 id=锁的分类>锁的分类<a hidden class=anchor aria-hidden=true href=#锁的分类>#</a></h5><blockquote><p>for all：SS兼容 SX不兼容 XX不兼容</p></blockquote><ol><li>全局锁 + 表级锁 + 行级锁</li><li>全局锁：<code>flush tables with read lock</code> 主要用于全局逻辑备份<ol><li>怎么又备份又不影响业务？在可重复读的级别下开启事务（MVCC支持）</li></ol></li><li>表级锁 = 表锁 + 元数据锁（MDL） + 意向锁 + AUTO-INC锁<ol><li>表锁：<code>lock tables student read</code> 其它线程不可写 该线程只可读此表（不能写 也不能操作其他表）</li><li>MDL：对表进行CRUD = 加MDL读锁 对表做结构更改 = 写锁<ul><li><strong>事务提交时释放锁</strong></li><li>why申请不到写锁 转而申请读锁也被阻塞？<ul><li>申请锁的请求形成队列 写锁优先级高于读锁（写锁等待时 该表的CRUD操作全部阻塞）</li></ul></li></ul></li></ol><blockquote><p>普通select不会加锁 用MVCC实现 但CS186中普通select是加了读锁的</p></blockquote><ol start=3><li>意向锁：IS IX 意向锁之间不会冲突 只与表锁冲突<ol><li>用于判断表里是否有记录被加锁</li></ol></li><li>AUTO-INC：掌管主键自增 <strong>插入完释放</strong>（避免其他事务同时插入 主键不连续自增）<ol><li>轻量级锁（<em>MySql5.1.22</em> ）为字段赋自增值后释放 不需等整个插入语句执行完</li><li>轻量级锁在主从复制时会出错（线程AB分别向表中插入记录 binlog记录原始语句 先记完A或B才能记别的 写入从库时重新insert 序号会变化）</li><li>设置<code>binlog_format=row</code> 解决（保留主库中序号）</li></ol></li></ol></li><li>行级锁：<ol><li>记录锁：锁一条记录S or X</li></ol><blockquote><p>间隙锁范围：如update记录25 只有10 20 30 &ndash;>锁住20~30</p></blockquote><ol start=2><li>间隙锁：只存在于可重复读（解决该级别幻读） + 锁不互斥（可以包含共同间隙范围） + 不包含边界</li><li>临键锁（二者结合）：包含边界 有互斥</li><li>插入意向锁：不是意向锁 插入的位置遇到间隙锁时生成 状态为等待 间隙锁释放后此锁开始作用<ul><li>是一种特殊的间隙锁 类似于锁住一个点</li></ul></li></ol></li></ol><h5 id=mysql怎么加锁>MySql怎么加锁<a hidden class=anchor aria-hidden=true href=#mysql怎么加锁>#</a></h5><blockquote><p>串行化级别select语句会加锁</p></blockquote><ol><li>加行级锁：索引加锁 基本单位next-key lock <strong>事务提交后才释放</strong><ol><li>在使用记录锁或者间隙锁就能避免<strong>幻读</strong>现象的场景下会<strong>退化</strong></li></ol><blockquote><p>分析加锁命令：<code>select * from performance_schema.data_locks\G;</code></p></blockquote><ol start=2><li>非唯一索引（主键+二级 非unique字段）<ol><li>等值查询：两索引都加锁 但主键索引只对满足条件的索引加锁（查询结果存在 主键索引加<strong>记录锁</strong> 不存在则主键索引<strong>不加锁</strong>）</li><li>范围查询：二级索引不退化</li></ol></li></ol></li><li>若不加索引进行查询 = 全表扫描 = 每条记录的索引都加next-key lock = 全部锁住</li></ol><h5 id=死锁>死锁<a hidden class=anchor aria-hidden=true href=#死锁>#</a></h5><blockquote><p>由next-key lock造成</p></blockquote><ol><li>两个线程select for update 都要插入&ndash;>等对方间隙锁释放才可获取插入意向锁</li><li>避免死锁：<ol><li>必要条件：互斥 占有且等待 不可强占用 循环等待</li><li>方法：设置等待锁的超时时间 / 开启主动死锁检测</li></ol></li></ol><h4 id=日志>日志⭐<a hidden class=anchor aria-hidden=true href=#日志>#</a></h4><ol><li>why undo log？<blockquote><p>事务提交前有用</p></blockquote><ol><li>保证原子性 可以回滚——记录每步操作</li><li>实现MVCC的关键因素——<strong>undo log的版本链</strong>为每条记录保存多份历史数据</li></ol></li><li>why buffer pool?<ol><li>作用：缓存数据 客户端可以直接读取 + 修改数据可以直接修改pool中的 并标记为<strong>脏页</strong>（与磁盘记录不一致）</li><li>缓存什么？<strong>以页为单位</strong>（16KB）</li></ol><blockquote><p>CS186中 GHJ用作join两个大表 外部归并排序用作将一个大表（可能是join的结果）进行排序后存放到页上</p></blockquote><ul><li>缓存数据页 索引页 undo页（记录undolog） 锁信息 自适应哈希索引插入缓存页</li><li>查询一条记录会把<strong>整页数据</strong>加载到pool</li></ul></li><li>why redo log?<ol><li>过程：先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录&ndash;>后台线程适时将脏页刷盘 <strong>先写日志后刷盘 == WAL</strong><ol><li>事务提交时 先持久化redolog</li><li>undolog修改也要记录到redolog</li></ol></li><li>作用：实现事务持久化 crash-safe + 写操作从随机写变为<strong>顺序写</strong>（redolog在磁盘中为追加操作 顺序写）</li><li>redo自身是循环写
<img loading=lazy src=image-3.png alt="alt text"></li></ol></li><li>redo undo的区别：redo记录事务<strong>修改后</strong>状态 用于崩溃恢复；undo记录事务<strong>修改前</strong>状态 用于回滚
<img loading=lazy src=image-2.png alt="alt text"></li><li>redolog与binlog的区别：（binlog原来是MyISAM中的 没有crash-safe能力 InnoDB实现了这个功能）<blockquote><p>binlog不记录查询语句 在每条更新语句后生成 事务提交时会把binlog统一写入binlog文件</p></blockquote><ol><li>bin是server层实现的 redo是引擎实现的</li><li>redo是物理日志（记录做了什么修改如在·处做了·更新）bin有statement模式（只记录操作如update 逻辑日志）、row模式（记录数据如一行）、mixed（自动切换）</li><li>bin是追加写 redo循环写</li><li>bin用于主从复制 备份恢复 redo用于故障恢复</li></ol></li><li>主从复制实现？<ol><li>依赖binlog 记录mysql所有变化并以二进制形式保存在磁盘上 将其传到从库以实现复制（一般异步 主库不等复制）<ol><li>二者建立联系 此后一直保持联系</li></ol></li></ol></li><li>binlog什么时候刷盘？<ol><li>事务执行过程中 先把日志写到binlog cache <strong>提交时</strong>将其写入binlog</li></ol></li><li>慢查询日志——记录执行时长超过阈值的查询语句<ul><li>用途：需要优化的查询 监控应用程序的数据库交互性能 容量规划</li></ul></li></ol><h5 id=两阶段提交>两阶段提交<a hidden class=anchor aria-hidden=true href=#两阶段提交>#</a></h5><ol><li>why need？binlog与redo不同时进行 若有一个没成功刷盘 都会<strong>主从不一致</strong></li><li>过程：<ul><li>prepare阶段：将内部XA事务的ID（XID）写入redo 将其事务状态设置为prepare redo持久化</li><li>commit阶段：XID写入binlog binlog持久化 redo状态设置为commit 此状态write到page cache</li></ul></li><li>若遇prepare态redolog 找binlog中是否有XID&ndash;>有则提交事务 无则回滚事务</li><li>binlog组提交——多个事务提交时 多个binlog刷盘操作合并为一个</li><li>MySQL磁盘I/O很高的优化方法——延迟binlog redolog的刷盘时机</li></ol><h4 id=性能与架构>性能与架构<a hidden class=anchor aria-hidden=true href=#性能与架构>#</a></h4><ol><li>explain：查看sql执行计划 如是否走索引 有无外部排序 有无索引覆盖<blockquote><p>explain的索引不对&ndash;>使用<code>force index</code>强制索引</p></blockquote></li><li>查询速度慢 怎么解决？<ol><li>用explain分析查询语句</li><li>创建或优化索引 避免索引失效</li><li>查询优化（select *）</li><li>优化数据库表（拆分为小表）</li><li>缓存技术</li></ol></li><li>主从延迟解决：强制走主库（针对大事务/资源密集型操作）</li><li>分库分表是什么&区别：<ol><li>分库：水平扩展数据库 数据按一定规则划分到多个独立数据库 每个数据库只存储部分数据（分布式存储）&ndash;>解决并发连接过多问题</li><li>分表：单个数据库中的表拆分为多个表&ndash;>提高查询效率 减轻单表压力&ndash;>解决单表数据量过大 查询性能下降问题</li></ol></li><li>分库分表操作：<ol><li>垂直分库（竖着切）：根据业务与功能的维度 将不同业务数据放到不同数据库——专库专用<ul><li>没有解决单表数据量过大的问题</li></ul></li><li>垂直分表：字段比较多的大表 将较为独立或不常用的字段拆分到单独的数据表中<ul><li>核心表字段长度较短 可以加载更多数据到内存中 减少磁盘IO</li></ul></li><li>水平分库（横着切）：同个表按一定规则拆分到<strong>不同数据库</strong>中（表结构不变）<ul><li>效率高 但数据访问需要额外的路由工作 系统复杂度高</li></ul></li><li>水平分表：拆分到<strong>同个数据库</strong>内（表结构不变）<ul><li>只解决了单表过大的问题 还要竞争同个物理机的CPU 内存等</li></ul></li></ol></li></ol><h4 id=存储引擎>存储引擎<a hidden class=anchor aria-hidden=true href=#存储引擎>#</a></h4><ol><li>架构？<ol><li>插件式架构 基于<strong>表</strong>（非数据库）</li></ol></li><li>MyISAM vs InnoDB<ol><li>行级锁 & MVCC ==> 不支持 vs 支持</li><li>事务 & 崩溃后的恢复 （同上）InnoDB使用redo log（同CS186）</li><li>外键 （同上）</li><li>非聚簇索引 vs 聚簇索引</li><li>缓存 键缓存（仅缓存数据页） vs buffer pool缓存数据页&索引页</li></ol></li></ol><h4 id=查询缓存>查询缓存<a hidden class=anchor aria-hidden=true href=#查询缓存>#</a></h4><blockquote><p>nothing</p></blockquote><h3 id=redis>Redis<a hidden class=anchor aria-hidden=true href=#redis>#</a></h3><h2 id=杂七杂八>杂七杂八⭐⭐<a hidden class=anchor aria-hidden=true href=#杂七杂八>#</a></h2><ol><li>进程与线程的区别？<ul><li>进程是OS层面 是程序的一次执行过程 一个进程内可能有多个线程</li><li>线程是CPU调度的基本单位 共享进程的地址空间与内存资源</li><li>Java中 不同线程拥有独立的JVM栈（java虚拟机） 本地方法栈 程序计数器</li><li>进程通信需要管道、信号量等 线程通信通过共享资源的读写操作实现</li></ul></li><li>Map底层实现：<ul><li>HashMap：JDK1.8之前 数组+链表（解决哈希冲突问题——拉链法） vs JDK1.8后 链表长度大于阈值（一般为8）时 数组长度小于64就进行数组扩容 大于时将链表转换为红黑树</li><li>LinkedHashMap：继承HashMap 加入双向链表 使键值对可以保持插入顺序</li><li>HashTable：由数组和链表组成 类似HashMap的初始形式</li><li>TreeMap：红黑树</li></ul></li><li>解释型与编译型：<ul><li>编译型语言，通过<strong>编译器</strong>将源代码<strong>一次性</strong>翻译成可被执行的机器码。执行快 开发慢</li><li>解释型语言。通过<strong>解释器</strong>一句一句的解释，边解释边执行。开发快，执行慢</li><li>Java：编译与解释并存。Java程序要先编译生成<strong>字节码</strong>（.class文件） 后字节码通过Java解释器来解释执行</li></ul></li><li>JIT vs AOT(ahead of time compilation)JDK9引入新的编译模式<ul><li>AOT：<strong>程序执行</strong>前将其编译为机器码，属于静态编译<ul><li>避免JIT预热等开销 可以提高启动速度 + 减少内存占用 + 增强Java程序安全性</li><li>but：无法支持Java动态特性，如反射 动态代理 动态加载 JNI等</li></ul></li><li>JIT：具有更高的极限处理能力，能够降低请求的最大延迟</li></ul></li></ol><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></div><footer class=post-footer><ul class=post-tags><li><a href=https://Sattiluvcat.github.io/en/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://Sattiluvcat.github.io/en/posts/else/vf-rrt/><span class=title>« Prev</span><br><span>VF-RRT</span>
</a><a class=next href=https://Sattiluvcat.github.io/en/posts/java/cs186/><span class=title>Next »</span><br><span>CS186</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on x" href="https://x.com/intent/tweet/?text=%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f&amp;title=%e5%85%ab%e8%82%a1&amp;summary=%e5%85%ab%e8%82%a1&amp;source=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f&title=%e5%85%ab%e8%82%a1"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%85%ab%e8%82%a1%20-%20https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on telegram" href="https://telegram.me/share/url?text=%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%85%ab%e8%82%a1&u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://www-sattiluvcat-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><script id=dsq-count-scr src=//www-sattiluvcat-github-io.disqus.com/count.js async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://Sattiluvcat.github.io/en/>Satti's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")</script></body></html>