<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><head><script async src="https://www.googletagmanager.com/gtag/js?id=自己的G-MEASUREMENT_ID"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","自己的G-MEASUREMENT_ID")</script></head><title>八股 | Satti's Blog</title>
<meta name=keywords content="Java"><meta name=description content="梳理一些方便查看的主要知识内容"><meta name=author content="Satti"><link rel=canonical href=https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/><link crossorigin=anonymous href=/assets/css/stylesheet.c5df81d78a700d63222bf88c998222af7e6085cc41585cba2eff58e49fd49e25.css integrity="sha256-xd+B14pwDWMiK/iMmYIir35ghcxBWFy6Lv9Y5J/UniU=" rel="preload stylesheet" as=style><link rel=icon type=image/png href=/favicon-48x48.png sizes=48x48><link rel=icon type=image/svg+xml href=/favicon.svg><link rel="shortcut icon" href=/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><meta name=apple-mobile-web-app-title content="MyWebSite"><link rel=manifest href=/site.webmanifest><link rel=alternate hreflang=en href=https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script async src="https://www.googletagmanager.com/gtag/js?id=自己的G-MEASUREMENT_ID"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","自己的G-MEASUREMENT_ID")</script><meta property="og:title" content="八股"><meta property="og:description" content="梳理一些方便查看的主要知识内容"><meta property="og:type" content="article"><meta property="og:url" content="https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-08T17:00:48+08:00"><meta property="article:modified_time" content="2024-12-30T00:04:48+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="八股"><meta name=twitter:description content="梳理一些方便查看的主要知识内容"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章","item":"https://Sattiluvcat.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"Notes📓","item":"https://Sattiluvcat.github.io/en/posts/notes/"},{"@type":"ListItem","position":3,"name":"八股","item":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"八股","name":"八股","description":"梳理一些方便查看的主要知识内容","keywords":["Java"],"articleBody":" 数据库 基本 数据库 常见名词 元组——一条记录就是一个元组（一行） 码——唯一标识实体的属性（一列） 候选码——候选的可以唯一标识元组的码（且不包括多余属性——否则为超键） 主码——主键 外码——另外关系中的主码 主属性（可以当候选码的） 非主属性（不包含在任何候选码的属性） ER图——实体联系图 包括：实体 属性 联系（实体与实体间的关系） 形状：矩形 椭圆 菱形（一一对应） 范式：1NF（第一范式） 2NF 3NF 1NF:字段有原子性 数据不可再分（每格数据不可再分） 2NF：消除非主属性对码的部分函数依赖（= 完全依赖） 一张表中 X确定 Y必确定 = X–\u003eY（Y函数依赖于X） X 的真子集 Xo–\u003eY（Y 部分函数依赖于 X）——数据冗余 CUD 异常 CRUD create read update delete 完全依赖：(X,Y)–\u003eZ 但X Y单个都不可依赖 3NF:所有非主键属性间不能依赖 必相互独立 外键与级联： 级联更新\u0026删除：更新/删除某主键 若其被其他表引用 则需更新/删除所有引用记录 delete vs drop vs truncate 用法：drop丢弃（table） truncate清空数据 id回到1 delete删除数据（行）id无影响 delete可以回滚 事务提交后生效（会产生日志） drop释放表空间 truncate不产生日志（不能回滚 NoSQL 与SQL的区别： 非结构化存储 vs 结构化存储（固定行和列） 通常不支持ACID vs ACID MongoDB支持 但有所区别 atom consistency isolation durability balabal vs 性能取决于磁盘子系统 优化查询 索引 表结构等获得最佳性能 横向拓展（基于分片机制——水平分割 以行为单位分割并分开存储） vs 垂直（读写分离 分库分表 ···） 特点：灵活 可拓展 高性能 类型：文档 键值 图形 宽列 字符集 utf8 utf8mb4\n字符集合 eg.ASCII UTF(Unicode) UTF-8 = 8比特UTF（一个字最多占3字节） UTF8mb4 = 一个字最多占据4字节的utf8 Mysql指定字符集优先级 server-数据库-表-字段column渐增 连接字符集：客户端与服务器沟通时相互翻译选择的字符集 JDBC（Java操控数据库的api）驱动会影响连接字符集 SQL database–\u003etable–\u003eschema(ok for table/db)–\u003ecolumn–\u003erow–\u003eprimary key\n注意：所有空格都被忽略 连接JOIN关键字 ON指定连接条件（最终生成临时表） left right关键词–\u003e即使右/左表没有满足条件的行也返回左/右表中的所有行 select something from table1 join table2 on table1.id=table2.id; 索引 事务 例题（窗口函数balabal略） MySql 基础 名词： 关系型数据库：基于关系模型的数据库 关系模型表明db中存储数据间的联系 SQL：结构化查询语言 字段 字段类型 数值 字符串 日期 DECIMAL vs FLOAT/DOUBLE –\u003e 避免精度损失 why：TEXT BLOB不建议？ 不常用：text ≈ 长文本的char varchar \u0026 bolb = 二进制大对象 缺点：不能有默认值 \u0026 智能在磁盘上创建临时表 \u0026 检索效率低 diff：NULL vs '' NULL代表一个不确定的值–\u003e不能用= != \u003e \u003c等运算符 \u0026 NULL=NULL ==\u003e False 只能用is NULL / is not NULL查询 ''长度为0 不占用空间 vs NULL要占用空间 how：boolean类型？ tinyint类型–\u003e只能存储0 or 1 架构 what：执行sql语句的流程？ 连接器——身份认证\u0026权限 查询缓存（mysql8.0后移除） 未命中后执行下述流程 分析器——检查语法··· 优化器——选择最优执行方案 执行器——执行前先判断有否权限 无权限则报错 有则从存储引擎返回数据 插件式存储引擎——数据的存储与读取 支持InnoDB MyIsam ··· 执行器与存储引擎交互 索引下推：MySql5.6 在联合索引遍历过程中，对联合索引中包含的字段先做判断 索引⭐⭐ 分类 数据结构 B+树——主键索引和二级索引默认 Hash Full-Text B+：每个节点存放按主键顺序的数据 叶子节点形成双向链表（下图来自(小林coding)[https://www.xiaolincoding.com/]） 索引与数据存储在磁盘 读取一个节点 = 进行一次磁盘I/O B树 = 没有双向链表的B+树 主键索引的树的叶子存放实际数据 二级索引的叶子存放主键值（虽然是按主键顺序 但表示还是按二级索引选用的物理量eg.学号 来表示） 二级索引查数据 = 二级索引树–\u003e主键树（此过程即为回表） B+优势： B+ vs B：B树非叶子节点也要存储数据（相同磁盘IO b+能查更多节点） 且没有双向链表（不能顺序查找） vs 二叉树：b+搜索复杂度$log_dN$ N个节点 每个节点最大子节点d个（一般大于100）——千万级对应3-4层 vs Hash：hash只适合等值查询 物理存储 聚簇索引（主键索引） 二级索引（辅助/非聚簇） 聚簇 = 主键：找到索引就找到了数据 有主键就是主键 无主键选第一个不含NULL的唯一列 也没有则InnoDB自创隐式自增ID列 非聚簇：用此索引不能找到数据（只找到主键） 需要回表查询 字段特性 主键索引 唯一索引（建立在UNIQUE字段上） 普通索引 前缀索引 前缀索引：针对字符类型字段的前几个字符建立 字段个数 单列索引 联合索引 联合索引：多个字段组合 eg.(product_no,name) 有先后顺序 联合索引的最左匹配：按最左优先的方式进行匹配 先找product_no 后找name 若某select只有name则该索引失效 联合索引的最左匹配遇到范围查询后失效 范围查询自身还有效 但若范围查询中有= 则还可以向后查询（准确来说用联合索引向后查的就只有=的情况） 联合索引最好把区分度大的放前面（distinct多的 如UUID） 在CS186中实现的是单列索引 键DataBox key 值（叶子节点）RecordId（唯一标识符） 也没有提前排序\n应用 缺点：占用物理空间（磁盘）+创建与维护耗时+降低增删改效率 适用索引的情况：UNIQUE字段 / 经常用于where/order by/group by的字段 不适用：大量重复/不怎么使用上述三种/表数据太少/经常更新的 优化方法：前缀索引优化 覆盖索引优化 主键索引最好是自增的 防止索引失效 前缀索引局限性：order by不能用（前缀后面的顺序不一定对） \u0026 不能用作覆盖索引 覆盖索引：查询的所有字段，在B+的叶子节点上都能找到（不用回表） 主键索引最好自增——插入方便（主键字段不要太长 二级索引叶子节点可以更小） 可能索引失效的情况：（in后条件过多，导致优化器进行查询优化时需要的内存超过内存限制–\u003e全表扫描 可设置rangeoptimizermaxmemsize） like %·· 类似最左前缀（所以是左模糊/左右模糊时失效） 对索引列做了计算 函数 类型转换操作 联合索引的最左前缀 where中 若or前条件为索引列 or后不是 则失效：优化器在处理OR操作符时，通常会选择一种能够处理所有条件的执行计划 事务⭐⭐ 特性：ACID 特性：原子性（要么全部完成 要么全部不完成） 一致性（事务操作前后，数据满足完整性约束） 隔离性（允许多个并发事务同时对其数据进行读写和修改） 持久性（事务处理结束后，对数据的修改就是永久的） 实现：A——undo log I——MVCC/锁 D——redo log C——前者共同保证 CS186中并发采用锁机制 恢复采用ARIES模型（各种日志）\n隔离性 并行事务可能引发的问题： 不可重复读RR是针对普通查询而言的，对其它情况都用当前读。所以InnoDB中的RR只保证普通查询时前后两个数据一致，不保证select···for update与select一致\n脏读——事务B读到事务A修改了但未提交的数据（A可能回滚 B读到的就是过期数据） 不可重复读——事务A多次读同个数据 前后两次读到的数据不一样（对应修改行） 幻读——在一个事务内多次查询某个符合查询条件的「记录数量」 查询到的数量不同（对应增删行） 严重性：从上到下递减 隔离级别：从上至下递增（效率递减） 读未提交——可读到未提交的事务 读提交——只能读已提交的事务 可重复读——一个事务执行过程看到的数据保持不变（InnoDB默认级别） 串行化——加读写锁 读写冲突时 后访问的事务等前一个完成后才能执行 InnoDB可以很大程度上避免幻读 其（InnoDB）实现： 快照读通过MVCC实现 MVCC中包括Read View Read Voew能实现读提交与可重复读\n快照读（普通select语句）——MVCC 可重复读条件下 插入的数据无法查询 当前读（其它语句 如select ··· for update update时要获得最新的数据）——通过记录锁+间隙锁(next-key lock)解决 在二锁的范围内插入的数据被阻塞 无法成功插入 Read View in MVCC,how to work?通过版本链控制并发事务访问同个记录 = MVCC（多版本并发控制） ReadView四个字段： m_ids：当前数据库「活跃事务」（启动了未提交）的事务 id 列表 min_trx_id：「活跃事务」中事务 id 最小的事务 max_trx_id：创建RV时全局事务中最大的事务 id 值 + 1（RV没照到的事务） creator_trx_id：创建该 Read View 的事务的 id 聚簇索引的两个隐藏列： trx_id：当一个事务对某条聚簇索引记录进行改动时，把该事务的 id 记录在此处 roll_pointer：对聚簇索引记录改动时 把旧版本的记录写入undo log 此隐藏列作为指针指向该旧版本记录（so可以找到后恢复） 一个事务访问记录时：（自己的记录总是可见） trxId可见 trxId\u003emax：创建RV后的启动的事务–\u003e不可见 在min与max之间：属于m_ids = 未提交的事务–\u003e不可见 / 不属于 = 已提交的事务–\u003e可见 读提交\u0026可重复读的实现：Read View（类似快照）「读提交」在「每个语句执行前」都生成 「可重复读」在「启动事务时」生成 explain：读提交在事务中也是每句都重新生成快照 B线程在期间更改数据也会被A线程快照到–\u003e事务中间数据会发生变化 CS186中实现的大概是串行化级别 一个线程（事务）添加X锁（排他锁）后 其它线程被加入阻塞队列 直到表上的X锁被释放\nMySql可重复读与幻读 记录锁+间隙锁可以防删除——主键索引被记录锁锁定 无法删除 间隙锁可以防插入\n不能防止幻读的例子： A事务先普通select（快照读） B事务插入数据并提交 A事务update插入的数据（当前读） A再次select–\u003e成功 A第一次select时并没有加锁 此时若A不update 直接select for update效果相同 解决：先做for update 事务提交时行级锁才会解除 锁⭐⭐⭐ 锁的分类 for all：SS兼容 SX不兼容 XX不兼容\n全局锁 + 表级锁 + 行级锁 全局锁：flush tables with read lock 主要用于全局逻辑备份 怎么又备份又不影响业务？在可重复读的级别下开启事务（MVCC支持） 表级锁 = 表锁 + 元数据锁（MDL） + 意向锁 + AUTO-INC锁 表锁：lock tables student read 其它线程不可写 该线程只可读此表（不能写 也不能操作其他表） MDL：对表进行CRUD = 加MDL读锁 对表做结构更改 = 写锁 事务提交时释放锁 why申请不到写锁 转而申请读锁也被阻塞？ 申请锁的请求形成队列 写锁优先级高于读锁（写锁等待时 该表的CRUD操作全部阻塞） 普通select不会加锁 用MVCC实现 但CS186中普通select是加了读锁的\n意向锁：IS IX 意向锁之间不会冲突 只与表锁冲突 用于判断表里是否有记录被加锁 AUTO-INC：掌管主键自增 插入完释放（避免其他事务同时插入 主键不连续自增） 轻量级锁（MySql5.1.22 ）为字段赋自增值后释放 不需等整个插入语句执行完 轻量级锁在主从复制时会出错（线程AB分别向表中插入记录 binlog记录原始语句 先记完A或B才能记别的 写入从库时重新insert 序号会变化） 设置binlog_format=row 解决（保留主库中序号） 行级锁： 记录锁：锁一条记录S or X 间隙锁范围：如update记录25 只有10 20 30 –\u003e锁住20~30\n间隙锁：只存在于可重复读（解决该级别幻读） + 锁不互斥（可以包含共同间隙范围） + 不包含边界 临键锁（二者结合）：包含边界 有互斥 插入意向锁：不是意向锁 插入的位置遇到间隙锁时生成 状态为等待 间隙锁释放后此锁开始作用 是一种特殊的间隙锁 类似于锁住一个点 MySql怎么加锁 串行化级别select语句会加锁\n加行级锁：索引加锁 基本单位next-key lock 事务提交后才释放 在使用记录锁或者间隙锁就能避免幻读现象的场景下会退化 分析加锁命令：select * from performance_schema.data_locks\\G;\n非唯一索引（主键+二级 非unique字段） 等值查询：两索引都加锁 但主键索引只对满足条件的索引加锁（查询结果存在 主键索引加记录锁 不存在则主键索引不加锁） 范围查询：二级索引不退化 若不加索引进行查询 = 全表扫描 = 每条记录的索引都加next-key lock = 全部锁住 死锁 由next-key lock造成\n两个线程select for update 都要插入–\u003e等对方间隙锁释放才可获取插入意向锁 避免死锁： 必要条件：互斥 占有且等待 不可强占用 循环等待 方法：设置等待锁的超时时间 / 开启主动死锁检测 日志⭐ why undo log？ 事务提交前有用\n保证原子性 可以回滚——记录每步操作 实现MVCC的关键因素——undo log的版本链为每条记录保存多份历史数据 why buffer pool? 作用：缓存数据 客户端可以直接读取 + 修改数据可以直接修改pool中的 并标记为脏页（与磁盘记录不一致） 缓存什么？以页为单位（16KB） CS186中 GHJ用作join两个大表 外部归并排序用作将一个大表（可能是join的结果）进行排序后存放到页上\n缓存数据页 索引页 undo页（记录undolog） 锁信息 自适应哈希索引插入缓存页 查询一条记录会把整页数据加载到pool why redo log? 过程：先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录–\u003e后台线程适时将脏页刷盘 先写日志后刷盘 == WAL 事务提交时 先持久化redolog undolog修改也要记录到redolog 作用：实现事务持久化 crash-safe + 写操作从随机写变为顺序写（redolog在磁盘中为追加操作 顺序写） redo自身是循环写 redo undo的区别：redo记录事务修改后状态 用于崩溃恢复；undo记录事务修改前状态 用于回滚 redolog与binlog的区别：（binlog原来是MyISAM中的 没有crash-safe能力 InnoDB实现了这个功能） binlog不记录查询语句 在每条更新语句后生成 事务提交时会把binlog统一写入binlog文件\nbin是server层实现的 redo是引擎实现的 redo是物理日志（记录做了什么修改如在·处做了·更新）bin有statement模式（只记录操作如update 逻辑日志）、row模式（记录数据如一行）、mixed（自动切换） bin是追加写 redo循环写 bin用于主从复制 备份恢复 redo用于故障恢复 主从复制实现？ 依赖binlog 记录mysql所有变化并以二进制形式保存在磁盘上 将其传到从库以实现复制（一般异步 主库不等复制） 二者建立联系 此后一直保持联系 binlog什么时候刷盘？ 事务执行过程中 先把日志写到binlog cache 提交时将其写入binlog 慢查询日志——记录执行时长超过阈值的查询语句 用途：需要优化的查询 监控应用程序的数据库交互性能 容量规划 两阶段提交 why need？binlog与redo不同时进行 若有一个没成功刷盘 都会主从不一致 过程： prepare阶段：将内部XA事务的ID（XID）写入redo 将其事务状态设置为prepare redo持久化 commit阶段：XID写入binlog binlog持久化 redo状态设置为commit 此状态write到page cache 若遇prepare态redolog 找binlog中是否有XID–\u003e有则提交事务 无则回滚事务 binlog组提交——多个事务提交时 多个binlog刷盘操作合并为一个 MySQL磁盘I/O很高的优化方法——延迟binlog redolog的刷盘时机 性能与架构 explain：查看sql执行计划 如是否走索引 有无外部排序 有无索引覆盖 explain的索引不对–\u003e使用force index强制索引\n查询速度慢 怎么解决？ 用explain分析查询语句 创建或优化索引 避免索引失效 查询优化（select *） 优化数据库表（拆分为小表） 缓存技术 主从延迟解决：强制走主库（针对大事务/资源密集型操作） 分库分表是什么\u0026区别： 分库：水平扩展数据库 数据按一定规则划分到多个独立数据库 每个数据库只存储部分数据（分布式存储）–\u003e解决并发连接过多问题 分表：单个数据库中的表拆分为多个表–\u003e提高查询效率 减轻单表压力–\u003e解决单表数据量过大 查询性能下降问题 分库分表操作： 垂直分库（竖着切）：根据业务与功能的维度 将不同业务数据放到不同数据库——专库专用 没有解决单表数据量过大的问题 垂直分表：字段比较多的大表 将较为独立或不常用的字段拆分到单独的数据表中 核心表字段长度较短 可以加载更多数据到内存中 减少磁盘IO 水平分库（横着切）：同个表按一定规则拆分到不同数据库中（表结构不变） 效率高 但数据访问需要额外的路由工作 系统复杂度高 水平分表：拆分到同个数据库内（表结构不变） 只解决了单表过大的问题 还要竞争同个物理机的CPU 内存等 存储引擎 架构？ 插件式架构 基于表（非数据库） MyISAM vs InnoDB 行级锁 \u0026 MVCC ==\u003e 不支持 vs 支持 事务 \u0026 崩溃后的恢复 （同上）InnoDB使用redo log（同CS186） 外键 （同上） 非聚簇索引 vs 聚簇索引 缓存 键缓存（仅缓存数据页） vs buffer pool缓存数据页\u0026索引页 查询缓存 nothing\nRedis⭐⭐ 性能 Redis为什么快\n高性能 高并发\n数据结构 数据类型与使用场景 常见5种：String（字符串/整数/浮点） Hash（散列） List（链表 两端push pop） Set（无序集合 不可重复） Zset（有序集合 不可重复） 后加：BitMap（2.2 版新增） HyperLogLog（2.8 版新增） GEO（3.2 版新增） Stream（5.0 版新增） String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等 List：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等 Hash 类型：缓存对象 可以用作购物车 Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注 Zset 类型：排序场景，比如排行榜、电话和姓名排序 BitMap：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等 HyperLogLog：海量数据基数统计的场景，比如百万级网页 UV 计数等 GEO：存储地理位置信息的场景，比如滴滴叫车 Stream（5.0 版新增）：消息队列，克服了List做消息队列的两个问题 数据类型实现： String内部：SDS（简单动态字符串） 可以保存二进制数据——使用 len 属性的值而非空字符串判断字符串是否结束–\u003e获取字符串的时间复杂度为O(1) Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。SDS拼接字符串之前会检查SDS 空间是否满足要求 List：压缩列表（元素个数少于512个 每个元素的值小于64字节 都可用list-max-ziplist-bal调+双向链表–\u003equickList（3.2后） Hash：压缩列表+哈希表–\u003elistpack（7.0后） Set：整数集合（均为整数且个数小于512）+哈希表 ZSet：压缩列表+跳表–\u003elistpack（7.0） 线程模型 是单线程？ Redis 单线程指的是「接收客户端请求-\u003e解析请求 -\u003e进行数据读写等操作-\u003e发送数据给客户端」这个过程是由一个线程（主线程）完成 但是Redis程序非单线程，启动时会启动后台线程（BIO） Redis2.6后–\u003e关闭文件 + AOF刷盘（x2后台线程） Redis4.0后–\u003e新增异步释放Redis内存（即lazyfree线程） 例如unlink key / flushdb async / flushall async，会把这些删除操作交给后台线程执行 好处：这些操作都很耗时，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞 单线程模式： 初始化–\u003e事件循环函数 事件循环函数： 调用处理发送队列函数，看是发送队列里是否有任务 有发送任务，则通过 write 函数，将客户端发送缓存区里的数据发送出去 如果这一轮数据没有发送完，就会注册写事件处理函数 调用 epoll_wait函数等待事件，若为连接事件–\u003e连接事件处理函数 / 读事件–\u003e读取客户端发送的内容并处理，将执行结果写到客户端发送缓冲区 / 写事件–\u003e通过write向客户端发送客户端发送缓冲区中的数据 单线程为什么还快？——吞吐量10万/s 大部分操作内存完成 避免多线程竞争 I/O多路复用：一个线程处理多个I/O流–\u003eselect/epoll机制（允许内核中，同时存在多个监听Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求，有请求则交给Redis处理） 早期为什么是单线程（Redis6.0之前）？ 单线程程序无法用多核CPU\nCPU并不是制约Redis性能的瓶颈 更多受内内存大小\u0026网络I/O限制 多线程复杂度高，可能存在线程切换、加锁解锁与死锁等性能损耗 为什么之后引入了多线程？ Redis主要工作是网络I/O与执行命令\n实际上是采用多个 I/O 线程来处理网络请求，随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上 但命令的处理还是使用单线程 6.0之后，默认情况下I/O 多线程只针对发送响应数据（write client socket）。可以设置io-threads-do-reads多线程处理读请求 6.0之后默认情况下额外创建6个线程（除主线程，主线程主要负责执行命令，也可以处理I/O）：后台线程x3，额外的I/O线程x3（设置io-threads 默认 4，除去主线程即为3个） 持久化 内存中执行，怎么保证持久化？\n方式：AOF日志 RDB快照 混合持久化 AOF：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里——先写后记 RDB：将某一时刻的内存数据，以二进制的方式写入磁盘 混合：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点 AOF日志：写入的文件在磁盘中，重启时读取该文件记录的操作命令，然后逐一执行（实现数据恢复） 好处： 避免额外的检查开销（如果命令语法有问题，又写入了日志 恢复数据时有问题） 不会阻塞当前写操作命令的执行（写成功后才会记录） 坏处： 数据可能丢失（执行完没来得及写入日志） 可能阻塞其他操作（AOF日志也在主线程中执行） 具体过程： Redis 执行完写操作命令后，将命令追加到 server.aof_buf 缓冲区 通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件。并未写入硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入 内核决定何时写入——Redis.conf文件可配置appendfsync（always每次写操作执行完写回 everysec每秒写回 no由OS决定写回时机） AOF日志过大，会？ 会AOF重写来压缩AOF文件——读取当前数据库中的所有键值对，然后将每个键值对用一条命令记录到新的AOF文件，全部记录完后替换现有AOF 如重复记录set name balabl，只保留最新数据即可 重写AOF日志的过程？ 由后台子进程 bgrewriteaof 完成 好处：避免阻塞主进程 \u0026 若使用线程，多线程间会共享内存，修改共享数据时需要加锁，亲子进程间以只读方式共享数据，若修改会发生写时复制，即亲子间有独立的数据副本（不用加锁） 重写时主进程依然正常处理命令，会将写命令写入到 「AOF 缓冲区」和「AOF 重写缓冲区」（创建子进程后启用） 子进程完成重写时向主进程发送（异步）信号（进程间通讯的一种方式） 主进程收到信号，将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，新的 AOF 的文件改名，覆盖现有的 AOF 文件 RDB快照：记录实际数据 快照时是否阻塞线程？ 执行save，在主线程生成RDB文件——会阻塞 执行bgsave，子进程生成RDB文件——避免阻塞 配置文件中设置save即为bgsave 全量快照——内存中所有数据都记录 执行快照时 数据能修改吗？——专指bgsave 可以，采用写时复制（Copy-On-Write, COW）——执行 bgsave 命令的时候，会通过 fork() 创建子进程 共享内存数据 主线程执行写操作，将被修改的数据复制副本，子进程将副本数据写入RDB文件，主进程可直接修改数据 混合持久化？ AOF丢失数据少但恢复速度不快，RDB快照频率不好确定，过低丢失数据多，过高影响性能\n如何实现？ 工作在AOF重写过程：重写子进程将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，主线程处理的操作命令被记录在重写缓冲区，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件。重写完成后替换。 AOF中前半是RDB格式全量数据，后半是AOF格式增量数据 优点：开头为 RDB 的格式，使得 Redis 可以更快的启动 + 结合 AOF 优点，减低了大量数据丢失的风险 缺点：添加了RDB格式内容，AOF 文件的可读性很差 + 兼容性差，Redis4.0前版本不能识别 集群 less⭐ 主从复制：一主多从 读写分离 主服务器读写，发生写时同步到从；从一般只读，接受主服务器的写命令并执行 异步：主服务器在本地执行完命令，就向客户端返回结果–\u003e无法实现强一致性（时刻一致） 哨兵模式sentinel：监控主从服务器 \u0026 主从节点故障转移功能（不懂）–\u003e选一个新leader 切片集群cluster：（一个）切片集群有 16384 个哈希槽，类似于数据分区，每个键值对根据它的 key，被映射到一个哈希槽–\u003e哈希槽被映射到具体的Redis节点（IP不同的就是不同节点） 哈希槽的映射：平均分配 / 手动分配（cluster meet 节点建立连接后，cluster addslots 指定各节点上哈希槽数） 集群脑裂问题与解决 集群脑裂是啥？ 由于网络问题，集群节点之间失去联系（主从间）–\u003e哨兵重选主节点，产生两个主服务–\u003e网络恢复，旧主节点降级为从节点，需要与新主进行同步复制–\u003e从节点清空自己缓冲区（之前未同步的数据）–\u003e客户端当时写入的数据丢失 解决： 当主节点发现从节点下线或者通信超时的总数量小于阈值时，就禁止主节点写数据，把错误返回给客户端–\u003e等待新主机上线后写 可以设置参数 min-slaves-to-write x、min-slaves-max-lag x若从节点连接数小于第一个/延迟超过第二个，主节点禁止写 过期删除与内存淘汰 Redis的过期删除策略？–\u003e 惰性删除 + 定时删除 设置了过期时间的key被带上过期时间存储到过期字典 （不主动删除键）查询key时先检查是否在过期字典中，在则比对系统时间，判断是否过期——惰性删除 优缺点：占用很少的系统资源 对CPU时间友好 but 过期key一直不被访问，对内存不友好（内存不释放） 定期删除：每隔一段时间随机抽取一定量的key，检查并删除，若过期key超过一定比例则继续随机抽取···–\u003e限制时间上限 优缺点：balabal（限制时长频率减少cpu占用 减少过期键对空间的占用） but 难以确定删除的时长与频率 持久化时怎么处理过期键？ RDB——生成RDB时不保存过期了的键；加载时主服务器不载入，从服务器载入（但数据同步时，从服务器数据会被清空） AOF——写入时若过期键未被删除，AOF会保留，被删除时向AOF追加DEL命令；重写时不重写过期键 主从模式下怎么处理过期键？ 从库不进行过期扫描，主库删除键，在AOF文件中增加DEL指令，指令同步到从库 Redis内存满了之后？ 内存淘汰机制 内存淘汰策略有？ 不进行数据淘汰——noeviction 超过最大内存时停止提供服务，直接返回错误（Redis3.0后默认） 进行数据淘汰： 在设置了TTL的数据中淘汰： volatile-random 随机淘汰设置了TTL的任意键值 volatile-ttl 优先淘汰更早过期的键值 volatile-lru 淘汰所有设置了TTL的最久未使用的键值（Redis3.0前默认） volatile-lfu 淘汰所有设置了TTL的最少使用的键值 所有数据范围： allkeys-random/allkeys-lru/allkeys-lfu LRU vs LFU Least Recently Used 与 Least Frequently Used\nLRU是？ 链表，被使用的移到链表头，要删除时删除链表尾元素即可 问题：需要链表，带来额外空间开销；需要移动数据，大量数据要操作时会耗时 Redis的LRU实现 在 Redis 的对象结构体redisObject（管理某数据类型的数据对象）中添加额外的字段记录此数据的最后一次访问时间 –\u003e 随机采样，淘汰最久没用的 缺点：缓存污染不能解决（一次性缓存删不了） LFU？ Redis4.0后引入，记录访问次数 Redis的LFU？ 也记录在redisObject的lru字段中\n多记录「数据的访问频次」的信息 –\u003e 24 bits 的 lru 字段中高16bit记录访问时间戳，低8位记录访问频次 缓存设计 待施工···\n杂七杂八⭐⭐ 进程与线程的区别？ 进程是OS层面 是程序的一次执行过程 一个进程内可能有多个线程 线程是CPU调度的基本单位 共享进程的地址空间与内存资源 Java中 不同线程拥有独立的JVM栈（java虚拟机） 本地方法栈 程序计数器 进程通信需要管道、信号量等 线程通信通过共享资源的读写操作实现 Map底层实现： HashMap：JDK1.8之前 数组+链表（解决哈希冲突问题——拉链法） vs JDK1.8后 链表长度大于阈值（一般为8）时 数组长度小于64就进行数组扩容 大于时将链表转换为红黑树 LinkedHashMap：继承HashMap 加入双向链表 使键值对可以保持插入顺序 HashTable：由数组和链表组成 类似HashMap的初始形式 TreeMap：红黑树 解释型与编译型： 编译型语言，通过编译器将源代码一次性翻译成可被执行的机器码。执行快 开发慢 解释型语言。通过解释器一句一句的解释，边解释边执行。开发快，执行慢 Java：编译与解释并存。Java程序要先编译生成字节码（.class文件） 后字节码通过Java解释器来解释执行 JIT vs AOT(ahead of time compilation)JDK9引入新的编译模式 AOT：程序执行前将其编译为机器码，属于静态编译 避免JIT预热等开销 可以提高启动速度 + 减少内存占用 + 增强Java程序安全性 but：无法支持Java动态特性，如反射 动态代理 动态加载 JNI等 JIT：具有更高的极限处理能力，能够降低请求的最大延迟 ","wordCount":"12188","inLanguage":"en","datePublished":"2024-12-08T17:00:48+08:00","dateModified":"2024-12-30T00:04:48+08:00","author":[{"@type":"Person","name":"Satti"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Sattiluvcat.github.io/en/posts/notes/%E5%85%AB%E8%82%A1/"},"publisher":{"@type":"Organization","name":"Satti's Blog","logo":{"@type":"ImageObject","url":"https://Sattiluvcat.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Sattiluvcat.github.io/en/ accesskey=h title="Satti's Blog (Alt + H)"><img src=https://Sattiluvcat.github.io/img/label1.jpg alt aria-label=logo height=35>Satti's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Sattiluvcat.github.io/en/search/ title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://Sattiluvcat.github.io/en/ title=🏠主页><span>🏠主页</span></a></li><li><a href=https://Sattiluvcat.github.io/en/tags title=📑标签><span>📑标签</span></a></li><li><a href=https://Sattiluvcat.github.io/en/lulu/ title=😽Lulu><span>😽Lulu</span></a></li><li><a href=https://Sattiluvcat.github.io/en/archives/ title=📅时间轴><span>📅时间轴</span></a></li><li><a href=https://Sattiluvcat.github.io/en/about/ title=😎关于><span>😎关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Sattiluvcat.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/>文章</a>&nbsp;»&nbsp;<a href=https://Sattiluvcat.github.io/en/posts/notes/>Notes📓</a></div><h1 class="post-title entry-hint-parent">八股</h1><div class=post-description>梳理一些方便查看的主要知识内容</div><div class=post-meta><span title='2024-12-08 17:00:48 +0800 +0800'>2024-12-08</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;<span title='Last updated 2024-12-30 00:04:48 +0800 +0800'>Last updated on 2024-12-30</span>&nbsp;·&nbsp;Satti</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93 aria-label=数据库>数据库</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac aria-label=基本>基本</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93-1 aria-label=数据库>数据库</a></li><li><a href=#nosql aria-label=NoSQL>NoSQL</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e9%9b%86 aria-label=字符集>字符集</a></li></ul></li><li><a href=#sql aria-label=SQL>SQL</a></li><li><a href=#mysql aria-label=MySql>MySql</a><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a></li><li><a href=#%e5%ad%97%e6%ae%b5 aria-label=字段>字段</a></li><li><a href=#%e6%9e%b6%e6%9e%84 aria-label=架构>架构</a></li><li><a href=#%e7%b4%a2%e5%bc%95 aria-label=索引⭐⭐>索引⭐⭐</a><ul><li><a href=#%e5%88%86%e7%b1%bb aria-label=分类>分类</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a></li><li><a href=#%e7%89%a9%e7%90%86%e5%ad%98%e5%82%a8 aria-label=物理存储>物理存储</a></li><li><a href=#%e5%ad%97%e6%ae%b5%e7%89%b9%e6%80%a7 aria-label=字段特性>字段特性</a></li><li><a href=#%e5%ad%97%e6%ae%b5%e4%b8%aa%e6%95%b0 aria-label=字段个数>字段个数</a></li></ul></li><li><a href=#%e5%ba%94%e7%94%a8 aria-label=应用>应用</a></li></ul></li><li><a href=#%e4%ba%8b%e5%8a%a1 aria-label=事务⭐⭐>事务⭐⭐</a><ul><li><a href=#%e9%9a%94%e7%a6%bb%e6%80%a7 aria-label=隔离性>隔离性</a></li><li><a href=#mysql%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e4%b8%8e%e5%b9%bb%e8%af%bb aria-label=MySql可重复读与幻读>MySql可重复读与幻读</a></li></ul></li><li><a href=#%e9%94%81 aria-label=锁⭐⭐⭐>锁⭐⭐⭐</a><ul><li><a href=#%e9%94%81%e7%9a%84%e5%88%86%e7%b1%bb aria-label=锁的分类>锁的分类</a></li><li><a href=#mysql%e6%80%8e%e4%b9%88%e5%8a%a0%e9%94%81 aria-label=MySql怎么加锁>MySql怎么加锁</a></li><li><a href=#%e6%ad%bb%e9%94%81 aria-label=死锁>死锁</a></li></ul></li><li><a href=#%e6%97%a5%e5%bf%97 aria-label=日志⭐>日志⭐</a><ul><li><a href=#%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4 aria-label=两阶段提交>两阶段提交</a></li></ul></li><li><a href=#%e6%80%a7%e8%83%bd%e4%b8%8e%e6%9e%b6%e6%9e%84 aria-label=性能与架构>性能与架构</a></li><li><a href=#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e aria-label=存储引擎>存储引擎</a></li><li><a href=#%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98 aria-label=查询缓存>查询缓存</a></li></ul></li><li><a href=#redis aria-label=Redis⭐⭐>Redis⭐⭐</a><ul><li><a href=#%e6%80%a7%e8%83%bd aria-label=性能>性能</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-1 aria-label=数据结构>数据结构</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b aria-label=线程模型>线程模型</a></li><li><a href=#%e6%8c%81%e4%b9%85%e5%8c%96 aria-label=持久化>持久化</a></li><li><a href=#%e9%9b%86%e7%be%a4-less aria-label="集群 less⭐">集群 less⭐</a></li><li><a href=#%e8%bf%87%e6%9c%9f%e5%88%a0%e9%99%a4%e4%b8%8e%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0 aria-label=过期删除与内存淘汰>过期删除与内存淘汰</a></li><li><a href=#%e7%bc%93%e5%ad%98%e8%ae%be%e8%ae%a1 aria-label=缓存设计>缓存设计</a></li></ul></li></ul></li><li><a href=#%e6%9d%82%e4%b8%83%e6%9d%82%e5%85%ab aria-label=杂七杂八⭐⭐>杂七杂八⭐⭐</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p> </p><p> </p><h2 id=数据库>数据库<a hidden class=anchor aria-hidden=true href=#数据库>#</a></h2><h3 id=基本>基本<a hidden class=anchor aria-hidden=true href=#基本>#</a></h3><h4 id=数据库-1>数据库<a hidden class=anchor aria-hidden=true href=#数据库-1>#</a></h4><ol><li>常见名词<ol><li>元组——一条记录就是一个元组（一行）</li><li>码——唯一标识实体的属性（一列）<ol><li>候选码——候选的可以唯一标识元组的码（且不包括多余属性——否则为<strong>超键</strong>）</li><li>主码——主键</li><li><strong>外码</strong>——另外关系中的主码</li><li>主属性（可以当候选码的） 非主属性（不包含在任何候选码的属性）</li></ol></li></ol></li><li>ER图——实体联系图<ol><li>包括：实体 属性 联系（实体与实体间的关系）</li><li>形状：矩形 椭圆 菱形（一一对应）</li></ol></li><li><strong>范式</strong>：1NF（第一范式） 2NF 3NF<ol><li>1NF:字段有原子性 数据不可再分（每格数据不可再分）</li><li>2NF：消除非主属性对码的部分函数依赖（= 完全依赖）<ol><li>一张表中 X确定 Y必确定 = X&ndash;>Y（Y函数依赖于X）</li><li>X 的真子集 Xo&ndash;>Y（Y 部分函数依赖于 X）——数据冗余 CUD 异常</li></ol><ul><li>CRUD create read update delete</li></ul><ol start=3><li>完全依赖：(X,Y)&ndash;>Z 但X Y单个都不可依赖</li></ol></li><li>3NF:所有非主键属性间不能依赖 必相互独立</li></ol></li><li>外键与级联：<ol><li>级联更新&删除：更新/删除某主键 若其被其他表引用 则需更新/删除所有引用记录</li></ol></li><li>delete vs drop vs truncate<ol><li>用法：drop丢弃（table） truncate清空数据 id回到1 delete删除数据（行）id无影响</li><li>delete可以回滚 事务提交后生效（会产生日志）</li><li>drop释放表空间 truncate不产生日志（不能回滚</li></ol></li></ol><h4 id=nosql>NoSQL<a hidden class=anchor aria-hidden=true href=#nosql>#</a></h4><ol><li>与SQL的区别：<ol><li>非结构化存储 vs 结构化存储（固定行和列）</li><li>通常不支持ACID vs ACID<ol><li>MongoDB支持 但有所区别</li><li>atom consistency isolation durability</li></ol></li><li>balabal vs 性能取决于磁盘子系统 优化查询 索引 表结构等获得最佳性能</li><li>横向拓展（基于分片机制——水平分割 以行为单位分割并分开存储） vs 垂直（读写分离 分库分表 ···）</li></ol></li><li>特点：灵活 可拓展 高性能</li><li>类型：文档 键值 图形 宽列</li></ol><h4 id=字符集>字符集<a hidden class=anchor aria-hidden=true href=#字符集>#</a></h4><blockquote><p>utf8 utf8mb4</p></blockquote><ol><li>字符集合 eg.ASCII UTF(Unicode)</li><li>UTF-8 = 8比特UTF（一个字最多占3字节） UTF8mb4 = 一个字最多占据4字节的utf8<ol><li>Mysql指定字符集优先级 server-数据库-表-字段column渐增</li></ol></li><li>连接字符集：客户端与服务器沟通时相互翻译选择的字符集<ol><li>JDBC（Java操控数据库的api）驱动会影响连接字符集</li></ol></li></ol><h3 id=sql>SQL<a hidden class=anchor aria-hidden=true href=#sql>#</a></h3><blockquote><p>database&ndash;>table&ndash;>schema(ok for table/db)&ndash;>column&ndash;>row&ndash;>primary key</p></blockquote><ol><li>注意：所有空格都被忽略</li><li>连接JOIN关键字 ON指定连接条件（最终生成临时表）<ol><li>left right关键词&ndash;>即使右/左表<strong>没有满足条件的行</strong>也返回左/右表中的<strong>所有行</strong></li></ol></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-SQL data-lang=SQL><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>something</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>table1</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>table2</span><span class=w> </span><span class=k>on</span><span class=w> </span><span class=n>table1</span><span class=p>.</span><span class=n>id</span><span class=o>=</span><span class=n>table2</span><span class=p>.</span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ol start=3><li>索引 事务</li><li>例题（窗口函数balabal略）</li></ol><h3 id=mysql>MySql<a hidden class=anchor aria-hidden=true href=#mysql>#</a></h3><h4 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h4><ol><li>名词：<ol><li>关系型数据库：基于关系模型的数据库 关系模型表明db中存储数据间的联系</li><li>SQL：结构化查询语言</li></ol></li></ol><h4 id=字段>字段<a hidden class=anchor aria-hidden=true href=#字段>#</a></h4><ol><li><a href=https://Sattiluvcat.github.io/en/posts/java/mysql_base/#创建>字段类型</a><ul><li>数值 字符串 日期</li></ul></li><li>DECIMAL vs FLOAT/DOUBLE &ndash;> 避免精度损失</li><li>why：TEXT BLOB不建议？<ol><li>不常用：text ≈ 长文本的char varchar & bolb = 二进制大对象</li><li>缺点：不能有默认值 & 智能在磁盘上创建临时表 & 检索效率低</li></ol></li><li>diff：NULL vs ''<ol><li>NULL代表一个<strong>不确定</strong>的值&ndash;>不能用<code>= != > &lt;</code>等运算符 & <code>NULL=NULL</code> ==> False<ul><li>只能用<code>is NULL / is not NULL</code>查询</li></ul></li><li><code>''</code>长度为0 不占用空间 vs NULL要占用空间</li></ol></li><li>how：boolean类型？<ol><li><code>tinyint</code>类型&ndash;>只能存储0 or 1</li></ol></li></ol><h4 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>#</a></h4><ol><li>what：执行sql语句的流程？<ul><li>连接器——身份认证&权限</li><li>查询缓存（mysql8.0后移除） 未命中后执行下述流程</li><li>分析器——检查语法···</li><li>优化器——选择最优执行方案</li><li>执行器——执行前先判断有否权限 无权限则报错 有则从存储引擎返回数据</li><li>插件式<strong>存储</strong>引擎——数据的<strong>存储与读取</strong> 支持InnoDB MyIsam ···</li></ul></li><li>执行器与存储引擎交互<ul><li>索引下推：<em>MySql5.6</em> 在联合索引遍历过程中，对联合索引中包含的字段先做判断</li></ul></li></ol><h4 id=索引>索引⭐⭐<a hidden class=anchor aria-hidden=true href=#索引>#</a></h4><h5 id=分类>分类<a hidden class=anchor aria-hidden=true href=#分类>#</a></h5><h6 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h6><ol><li>B+树——主键索引和二级索引默认</li><li>Hash</li><li>Full-Text</li><li>B+：每个节点存放<strong>按主键顺序</strong>的数据 叶子节点形成<strong>双向链表</strong>（下图来自(小林coding)[https://www.xiaolincoding.com/]）
<img loading=lazy src=image.png alt="alt text"><ul><li>索引与数据存储在<strong>磁盘</strong> 读取一个节点 = 进行一次磁盘I/O<ul><li>B树 = 没有双向链表的B+树</li></ul></li><li>主键索引的树的叶子存放实际数据 <strong>二级索引的叶子存放主键值</strong>（虽然是按主键顺序 但表示还是按二级索引选用的物理量eg.学号 来表示）</li><li>二级索引查数据 = 二级索引树&ndash;>主键树（此过程即为回表）</li></ul></li><li>B+优势：<ul><li>B+ vs B：B树非叶子节点也要存储数据（相同磁盘IO b+能查更多节点） 且没有双向链表（不能顺序查找）</li><li>vs 二叉树：b+搜索复杂度$log_dN$ N个节点 每个节点最大子节点d个（一般大于100）——千万级对应3-4层</li><li>vs Hash：hash只适合等值查询</li></ul></li></ol><h6 id=物理存储>物理存储<a hidden class=anchor aria-hidden=true href=#物理存储>#</a></h6><ol><li>聚簇索引（主键索引） 二级索引（辅助/非聚簇）<ul><li>聚簇 = 主键：找到索引就找到了数据<ul><li>有主键就是主键 无主键选第一个不含NULL的唯一列 也没有则InnoDB自创隐式自增ID列</li></ul></li><li>非聚簇：用此索引不能找到数据（只找到主键） 需要回表查询</li></ul></li></ol><h6 id=字段特性>字段特性<a hidden class=anchor aria-hidden=true href=#字段特性>#</a></h6><ol><li>主键索引 唯一索引（建立在UNIQUE字段上） 普通索引 前缀索引<ol><li>前缀索引：针对字符类型字段的前几个字符建立</li></ol></li></ol><h6 id=字段个数>字段个数<a hidden class=anchor aria-hidden=true href=#字段个数>#</a></h6><ol><li>单列索引 联合索引<ul><li>联合索引：多个字段组合 eg.(product_no,name) 有先后顺序
<img loading=lazy src=image-1.png alt="alt text"></li></ul></li><li>联合索引的最左匹配：按<strong>最左优先</strong>的方式进行匹配<ul><li>先找product_no 后找name 若某select只有name则该索引失效</li></ul></li><li>联合索引的最左匹配遇到<strong>范围查询后</strong>失效<ul><li>范围查询<strong>自身还有效</strong></li><li>但若范围查询中有<code>=</code> 则还可以向后查询（准确来说用联合索引向后查的就只有<code>=</code>的情况）</li></ul></li><li>联合索引最好把区分度大的放前面（distinct多的 如UUID）</li></ol><blockquote><p>在CS186中实现的是单列索引 键DataBox key 值（叶子节点）RecordId（唯一标识符）<br>也没有提前排序</p></blockquote><h5 id=应用>应用<a hidden class=anchor aria-hidden=true href=#应用>#</a></h5><ol><li>缺点：占用物理空间（磁盘）+创建与维护耗时+降低增删改效率</li><li>适用索引的情况：UNIQUE字段 / 经常用于<code>where</code>/<code>order by</code>/<code>group by</code>的字段</li><li>不适用：大量重复/不怎么使用上述三种/表数据太少/经常更新的</li><li>优化方法：前缀索引优化 覆盖索引优化 主键索引最好是自增的 防止索引失效<ul><li>前缀索引局限性：order by不能用（前缀后面的顺序不一定对） & 不能用作覆盖索引</li><li>覆盖索引：查询的所有字段，在B+的叶子节点上都能找到（不用回表）</li><li>主键索引最好自增——插入方便（主键字段不要太长 二级索引叶子节点可以更小）</li></ul></li><li>可能索引失效的情况：（in后条件过多，导致<strong>优化器</strong>进行查询优化时需要的内存超过内存限制&ndash;>全表扫描 可设置<code>rangeoptimizermaxmemsize</code>）<ul><li><code>like %··</code> 类似最左前缀（所以是左模糊/左右模糊时失效）</li><li>对索引列做了计算 函数 类型转换操作</li><li>联合索引的最左前缀</li><li>where中 若or前条件为索引列 or后不是 则失效：<strong>优化器</strong>在处理OR操作符时，通常会选择一种<strong>能够处理所有条件</strong>的执行计划</li></ul></li></ol><h4 id=事务>事务⭐⭐<a hidden class=anchor aria-hidden=true href=#事务>#</a></h4><ol><li>特性：ACID<ul><li>特性：<strong>原子性</strong>（要么全部完成 要么全部不完成） <strong>一致性</strong>（事务操作前后，数据满足完整性约束） <strong>隔离性</strong>（允许多个并发事务同时对其数据进行读写和修改） <strong>持久性</strong>（事务处理结束后，对数据的修改就是永久的）</li></ul></li><li>实现：A——undo log I——MVCC/锁 D——redo log C——前者共同保证</li></ol><blockquote><p>CS186中并发采用锁机制 恢复采用ARIES模型（各种日志）</p></blockquote><h5 id=隔离性>隔离性<a hidden class=anchor aria-hidden=true href=#隔离性>#</a></h5><ol><li>并行事务可能引发的问题：<blockquote><p>不可重复读RR是针对普通查询而言的，对其它情况都用当前读。所以InnoDB中的RR只保证普通查询时前后两个数据一致，不保证<code>select···for update</code>与<code>select</code>一致</p></blockquote><ul><li><strong>脏读</strong>——事务B读到事务A修改了但未提交的数据（A可能回滚 B读到的就是过期数据）</li><li><strong>不可重复读</strong>——事务A多次读同个数据 前后两次读到的数据不一样（对应<strong>修改</strong>行）</li><li><strong>幻读</strong>——在一个事务内多次查询某个符合查询条件的「记录数量」 查询到的数量不同（对应<strong>增删</strong>行）</li><li>严重性：从上到下递减</li></ul></li><li>隔离级别：从上至下递增（效率递减）<ol><li>读未提交——可读到未提交的事务</li><li>读提交——只能读已提交的事务</li><li>可重复读——一个事务执行过程看到的数据保持不变（<strong>InnoDB默认级别</strong>）</li><li>串行化——加<strong>读写锁</strong> 读写冲突时 后访问的事务等前一个完成后才能执行</li></ol></li><li>InnoDB可以<strong>很大程度</strong>上避免幻读 其（InnoDB）实现：<blockquote><p>快照读通过MVCC实现 MVCC中包括Read View Read Voew能实现读提交与可重复读</p></blockquote><ul><li>快照读（普通select语句）——MVCC 可重复读条件下 插入的数据无法查询</li><li>当前读（其它语句 如select ··· for update update时要获得最新的数据）——通过记录锁+间隙锁(next-key lock)解决 在二锁的范围内插入的数据被阻塞 无法成功插入</li></ul></li><li>Read View in MVCC,how to work?通过版本链控制并发事务访问同个记录 = MVCC（多版本并发控制）<ul><li>ReadView四个字段：<ul><li>m_ids：当前数据库「活跃事务」（启动了未提交）的事务 id 列表</li><li>min_trx_id：「活跃事务」中事务 id 最小的事务</li><li>max_trx_id：创建RV时全局事务中最大的事务 id 值 + 1（RV没照到的事务）</li><li>creator_trx_id：创建该 Read View 的事务的 id</li></ul></li><li>聚簇索引的两个隐藏列：<ul><li>trx_id：当一个事务对某条聚簇索引记录进行改动时，把该事务的 id 记录在此处</li><li>roll_pointer：对聚簇索引记录改动时 把旧版本的记录写入undo log 此隐藏列作为指针指向该旧版本记录（so可以找到后恢复）</li></ul></li><li>一个事务访问记录时：（自己的记录总是可见）<ul><li>trxId&lt;min：该记录是（创建RV前）已提交事务生成的&ndash;>可见</li><li>trxId>max：创建RV后的启动的事务&ndash;>不可见</li><li>在min与max之间：属于m_ids = 未提交的事务&ndash;>不可见 / 不属于 = 已提交的事务&ndash;>可见</li></ul></li></ul></li><li>读提交&可重复读的实现：<strong>Read View</strong>（类似快照）「读提交」在「<strong>每个语句执行前</strong>」都生成 「可重复读」在「<strong>启动事务时</strong>」生成<ul><li>explain：读提交在事务中也是每句都重新生成快照 B线程在期间更改数据也会被A线程快照到&ndash;>事务中间数据会发生变化</li></ul></li></ol><blockquote><p>CS186中实现的大概是串行化级别 一个线程（事务）添加X锁（排他锁）后 其它线程被加入阻塞队列 直到表上的X锁被释放</p></blockquote><h5 id=mysql可重复读与幻读>MySql可重复读与幻读<a hidden class=anchor aria-hidden=true href=#mysql可重复读与幻读>#</a></h5><blockquote><p>记录锁+间隙锁可以防删除——主键索引被记录锁锁定 无法删除 间隙锁可以防插入</p></blockquote><ol><li>不能防止幻读的例子：<ol><li>A事务先普通select（快照读） B事务插入数据并提交 A事务update插入的数据（当前读） A再次select&ndash;>成功<ul><li>A第一次select时并没有加锁</li><li>此时若A不update 直接select for update效果相同</li></ul></li></ol></li><li>解决：先做for update <strong>事务提交时行级锁才会解除</strong></li></ol><h4 id=锁>锁⭐⭐⭐<a hidden class=anchor aria-hidden=true href=#锁>#</a></h4><h5 id=锁的分类>锁的分类<a hidden class=anchor aria-hidden=true href=#锁的分类>#</a></h5><blockquote><p>for all：SS兼容 SX不兼容 XX不兼容</p></blockquote><ol><li>全局锁 + 表级锁 + 行级锁</li><li>全局锁：<code>flush tables with read lock</code> 主要用于全局逻辑备份<ol><li>怎么又备份又不影响业务？在可重复读的级别下开启事务（MVCC支持）</li></ol></li><li>表级锁 = 表锁 + 元数据锁（MDL） + 意向锁 + AUTO-INC锁<ol><li>表锁：<code>lock tables student read</code> 其它线程不可写 该线程只可读此表（不能写 也不能操作其他表）</li><li>MDL：对表进行CRUD = 加MDL读锁 对表做结构更改 = 写锁<ul><li><strong>事务提交时释放锁</strong></li><li>why申请不到写锁 转而申请读锁也被阻塞？<ul><li>申请锁的请求形成队列 写锁优先级高于读锁（写锁等待时 该表的CRUD操作全部阻塞）</li></ul></li></ul></li></ol><blockquote><p>普通select不会加锁 用MVCC实现 但CS186中普通select是加了读锁的</p></blockquote><ol start=3><li>意向锁：IS IX 意向锁之间不会冲突 只与表锁冲突<ol><li>用于判断表里是否有记录被加锁</li></ol></li><li>AUTO-INC：掌管主键自增 <strong>插入完释放</strong>（避免其他事务同时插入 主键不连续自增）<ol><li>轻量级锁（<em>MySql5.1.22</em> ）为字段赋自增值后释放 不需等整个插入语句执行完</li><li>轻量级锁在主从复制时会出错（线程AB分别向表中插入记录 binlog记录原始语句 先记完A或B才能记别的 写入从库时重新insert 序号会变化）</li><li>设置<code>binlog_format=row</code> 解决（保留主库中序号）</li></ol></li></ol></li><li>行级锁：<ol><li>记录锁：锁一条记录S or X</li></ol><blockquote><p>间隙锁范围：如update记录25 只有10 20 30 &ndash;>锁住20~30</p></blockquote><ol start=2><li>间隙锁：只存在于可重复读（解决该级别幻读） + 锁不互斥（可以包含共同间隙范围） + 不包含边界</li><li>临键锁（二者结合）：包含边界 有互斥</li><li>插入意向锁：不是意向锁 插入的位置遇到间隙锁时生成 状态为等待 间隙锁释放后此锁开始作用<ul><li>是一种特殊的间隙锁 类似于锁住一个点</li></ul></li></ol></li></ol><h5 id=mysql怎么加锁>MySql怎么加锁<a hidden class=anchor aria-hidden=true href=#mysql怎么加锁>#</a></h5><blockquote><p>串行化级别select语句会加锁</p></blockquote><ol><li>加行级锁：索引加锁 基本单位next-key lock <strong>事务提交后才释放</strong><ol><li>在使用记录锁或者间隙锁就能避免<strong>幻读</strong>现象的场景下会<strong>退化</strong></li></ol><blockquote><p>分析加锁命令：<code>select * from performance_schema.data_locks\G;</code></p></blockquote><ol start=2><li>非唯一索引（主键+二级 非unique字段）<ol><li>等值查询：两索引都加锁 但主键索引只对满足条件的索引加锁（查询结果存在 主键索引加<strong>记录锁</strong> 不存在则主键索引<strong>不加锁</strong>）</li><li>范围查询：二级索引不退化</li></ol></li></ol></li><li>若不加索引进行查询 = 全表扫描 = 每条记录的索引都加next-key lock = 全部锁住</li></ol><h5 id=死锁>死锁<a hidden class=anchor aria-hidden=true href=#死锁>#</a></h5><blockquote><p>由next-key lock造成</p></blockquote><ol><li>两个线程select for update 都要插入&ndash;>等对方间隙锁释放才可获取插入意向锁</li><li>避免死锁：<ol><li>必要条件：互斥 占有且等待 不可强占用 循环等待</li><li>方法：设置等待锁的超时时间 / 开启主动死锁检测</li></ol></li></ol><h4 id=日志>日志⭐<a hidden class=anchor aria-hidden=true href=#日志>#</a></h4><ol><li>why undo log？<blockquote><p>事务提交前有用</p></blockquote><ol><li>保证原子性 可以回滚——记录每步操作</li><li>实现MVCC的关键因素——<strong>undo log的版本链</strong>为每条记录保存多份历史数据</li></ol></li><li>why buffer pool?<ol><li>作用：缓存数据 客户端可以直接读取 + 修改数据可以直接修改pool中的 并标记为<strong>脏页</strong>（与磁盘记录不一致）</li><li>缓存什么？<strong>以页为单位</strong>（16KB）</li></ol><blockquote><p>CS186中 GHJ用作join两个大表 外部归并排序用作将一个大表（可能是join的结果）进行排序后存放到页上</p></blockquote><ul><li>缓存数据页 索引页 undo页（记录undolog） 锁信息 自适应哈希索引插入缓存页</li><li>查询一条记录会把<strong>整页数据</strong>加载到pool</li></ul></li><li>why redo log?<ol><li>过程：先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录&ndash;>后台线程适时将脏页刷盘 <strong>先写日志后刷盘 == WAL</strong><ol><li>事务提交时 先持久化redolog</li><li>undolog修改也要记录到redolog</li></ol></li><li>作用：实现事务持久化 crash-safe + 写操作从随机写变为<strong>顺序写</strong>（redolog在磁盘中为追加操作 顺序写）</li><li>redo自身是循环写
<img loading=lazy src=image-3.png alt="alt text"></li></ol></li><li>redo undo的区别：redo记录事务<strong>修改后</strong>状态 用于崩溃恢复；undo记录事务<strong>修改前</strong>状态 用于回滚
<img loading=lazy src=image-2.png alt="alt text"></li><li>redolog与binlog的区别：（binlog原来是MyISAM中的 没有crash-safe能力 InnoDB实现了这个功能）<blockquote><p>binlog不记录查询语句 在每条更新语句后生成 事务提交时会把binlog统一写入binlog文件</p></blockquote><ol><li>bin是server层实现的 redo是引擎实现的</li><li>redo是物理日志（记录做了什么修改如在·处做了·更新）bin有statement模式（只记录操作如update 逻辑日志）、row模式（记录数据如一行）、mixed（自动切换）</li><li>bin是追加写 redo循环写</li><li>bin用于主从复制 备份恢复 redo用于故障恢复</li></ol></li><li>主从复制实现？<ol><li>依赖binlog 记录mysql所有变化并以二进制形式保存在磁盘上 将其传到从库以实现复制（一般异步 主库不等复制）<ol><li>二者建立联系 此后一直保持联系</li></ol></li></ol></li><li>binlog什么时候刷盘？<ol><li>事务执行过程中 先把日志写到binlog cache <strong>提交时</strong>将其写入binlog</li></ol></li><li>慢查询日志——记录执行时长超过阈值的查询语句<ul><li>用途：需要优化的查询 监控应用程序的数据库交互性能 容量规划</li></ul></li></ol><h5 id=两阶段提交>两阶段提交<a hidden class=anchor aria-hidden=true href=#两阶段提交>#</a></h5><ol><li>why need？binlog与redo不同时进行 若有一个没成功刷盘 都会<strong>主从不一致</strong></li><li>过程：<ul><li>prepare阶段：将内部XA事务的ID（XID）写入redo 将其事务状态设置为prepare redo持久化</li><li>commit阶段：XID写入binlog binlog持久化 redo状态设置为commit 此状态write到page cache</li></ul></li><li>若遇prepare态redolog 找binlog中是否有XID&ndash;>有则提交事务 无则回滚事务</li><li>binlog组提交——多个事务提交时 多个binlog刷盘操作合并为一个</li><li>MySQL磁盘I/O很高的优化方法——延迟binlog redolog的刷盘时机</li></ol><h4 id=性能与架构>性能与架构<a hidden class=anchor aria-hidden=true href=#性能与架构>#</a></h4><ol><li>explain：查看sql执行计划 如是否走索引 有无外部排序 有无索引覆盖<blockquote><p>explain的索引不对&ndash;>使用<code>force index</code>强制索引</p></blockquote></li><li>查询速度慢 怎么解决？<ol><li>用explain分析查询语句</li><li>创建或优化索引 避免索引失效</li><li>查询优化（select *）</li><li>优化数据库表（拆分为小表）</li><li>缓存技术</li></ol></li><li>主从延迟解决：强制走主库（针对大事务/资源密集型操作）</li><li>分库分表是什么&区别：<ol><li>分库：水平扩展数据库 数据按一定规则划分到多个独立数据库 每个数据库只存储部分数据（分布式存储）&ndash;>解决并发连接过多问题</li><li>分表：单个数据库中的表拆分为多个表&ndash;>提高查询效率 减轻单表压力&ndash;>解决单表数据量过大 查询性能下降问题</li></ol></li><li>分库分表操作：<ol><li>垂直分库（竖着切）：根据业务与功能的维度 将不同业务数据放到不同数据库——专库专用<ul><li>没有解决单表数据量过大的问题</li></ul></li><li>垂直分表：字段比较多的大表 将较为独立或不常用的字段拆分到单独的数据表中<ul><li>核心表字段长度较短 可以加载更多数据到内存中 减少磁盘IO</li></ul></li><li>水平分库（横着切）：同个表按一定规则拆分到<strong>不同数据库</strong>中（表结构不变）<ul><li>效率高 但数据访问需要额外的路由工作 系统复杂度高</li></ul></li><li>水平分表：拆分到<strong>同个数据库</strong>内（表结构不变）<ul><li>只解决了单表过大的问题 还要竞争同个物理机的CPU 内存等</li></ul></li></ol></li></ol><h4 id=存储引擎>存储引擎<a hidden class=anchor aria-hidden=true href=#存储引擎>#</a></h4><ol><li>架构？<ol><li>插件式架构 基于<strong>表</strong>（非数据库）</li></ol></li><li>MyISAM vs InnoDB<ol><li>行级锁 & MVCC ==> 不支持 vs 支持</li><li>事务 & 崩溃后的恢复 （同上）InnoDB使用redo log（同CS186）</li><li>外键 （同上）</li><li>非聚簇索引 vs 聚簇索引</li><li>缓存 键缓存（仅缓存数据页） vs buffer pool缓存数据页&索引页</li></ol></li></ol><h4 id=查询缓存>查询缓存<a hidden class=anchor aria-hidden=true href=#查询缓存>#</a></h4><blockquote><p>nothing</p></blockquote><h3 id=redis>Redis⭐⭐<a hidden class=anchor aria-hidden=true href=#redis>#</a></h3><h4 id=性能>性能<a hidden class=anchor aria-hidden=true href=#性能>#</a></h4><ol><li><p>Redis为什么快</p></li><li><p>高性能 高并发</p></li></ol><h4 id=数据结构-1>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构-1>#</a></h4><ol><li>数据类型与使用场景<ul><li>常见5种：String（字符串/整数/浮点） Hash（散列） List（链表 两端push pop） Set（无序集合 不可重复） Zset（有序集合 不可重复）</li><li>后加：BitMap（2.2 版新增） HyperLogLog（2.8 版新增） GEO（3.2 版新增） Stream（5.0 版新增）</li></ul><ol><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等</li><li>List：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等</li><li>Hash 类型：缓存对象 可以用作购物车</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序</li><li>BitMap：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等</li><li>HyperLogLog：海量数据基数统计的场景，比如百万级网页 UV 计数等</li><li>GEO：存储地理位置信息的场景，比如滴滴叫车</li><li>Stream（5.0 版新增）：消息队列，克服了List做消息队列的两个问题</li></ol></li><li>数据类型实现：<ol><li>String内部：SDS（简单动态字符串）<ul><li>可以保存二进制数据——使用 len 属性的值而非空字符串判断字符串是否结束&ndash;>获取字符串的时间复杂度为O(1)</li><li>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。SDS拼接字符串之前会检查SDS 空间是否满足要求</li></ul></li><li>List：压缩列表（元素个数少于512个 每个元素的值小于64字节 都可用<code>list-max-ziplist-bal</code>调+双向链表&ndash;>quickList（3.2后）</li><li>Hash：压缩列表+哈希表&ndash;>listpack（7.0后）</li><li>Set：整数集合（均为整数且个数小于512）+哈希表</li><li>ZSet：压缩列表+跳表&ndash;>listpack（7.0）</li></ol></li></ol><h4 id=线程模型>线程模型<a hidden class=anchor aria-hidden=true href=#线程模型>#</a></h4><ol><li>是单线程？<ul><li>Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个<strong>过程</strong>是由一个线程（主线程）完成</li><li>但是Redis程序非单线程，启动时会启动后台线程（BIO）</li><li>Redis2.6后&ndash;>关闭文件 + AOF刷盘（x2后台线程）</li><li>Redis4.0后&ndash;>新增异步释放Redis内存（即lazyfree线程）<ul><li>例如unlink key / flushdb async / flushall async，会把这些删除操作交给后台线程执行</li></ul></li></ul><ol><li>好处：这些操作都很耗时，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞</li></ol></li><li>单线程模式：<ol><li>初始化&ndash;>事件循环函数</li><li>事件循环函数：<ol><li>调用处理发送队列函数，看是发送队列里是否有任务</li><li>有发送任务，则通过 <strong>write</strong> 函数，将客户端发送缓存区里的数据发送出去</li><li>如果这一轮数据没有发送完，就会注册写事件处理函数</li><li>调用 epoll_wait函数等待事件，若为连接事件&ndash;>连接事件处理函数 / 读事件&ndash;>读取客户端发送的内容并处理，将执行结果写到客户端发送缓冲区 / 写事件&ndash;>通过write向客户端发送客户端发送缓冲区中的数据</li></ol></li></ol></li><li>单线程为什么还快？——吞吐量10万/s<ol><li>大部分操作内存完成</li><li>避免多线程竞争</li><li>I/O多路复用：一个线程处理多个I/O流&ndash;>select/epoll机制（允许内核中，同时存在多个监听Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求，有请求则交给Redis处理）</li></ol></li><li>早期为什么是单线程（Redis6.0之前）？<blockquote><p>单线程程序无法用多核CPU</p></blockquote><ol><li>CPU并不是制约Redis性能的瓶颈 更多受内内存大小&网络I/O限制</li><li>多线程复杂度高，可能存在线程切换、加锁解锁与死锁等性能损耗</li></ol></li><li>为什么之后引入了多线程？<blockquote><p>Redis主要工作是网络I/O与执行命令</p></blockquote><ol><li>实际上是采用多个 I/O 线程来<strong>处理网络请求</strong>，随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上</li><li><strong>但</strong>命令的处理还是使用单线程</li></ol><ul><li>6.0之后，默认情况下I/O 多线程<strong>只</strong>针对发送响应数据（write client socket）。可以设置<code>io-threads-do-reads</code>多线程处理读请求</li><li>6.0之后默认情况下额外创建6个线程（除主线程，主线程主要负责执行命令，也可以处理I/O）：后台线程x3，额外的I/O线程x3（设置io-threads 默认 4，除去主线程即为3个）</li></ul></li></ol><h4 id=持久化>持久化<a hidden class=anchor aria-hidden=true href=#持久化>#</a></h4><blockquote><p>内存中执行，怎么保证持久化？</p></blockquote><ol><li>方式：AOF日志 RDB快照 混合持久化<ol><li>AOF：<strong>每</strong>执行一条<strong>写</strong>操作命令，就把该命令以追加的方式写入到一个文件里——先写后记</li><li>RDB：将<strong>某一时刻</strong>的内存数据，以<strong>二进制</strong>的方式写入磁盘</li><li>混合：<strong>Redis 4.0</strong> 新增的方式，集成了 AOF 和 RBD 的优点</li></ol></li><li>AOF日志：写入的文件在磁盘中，重启时读取该文件记录的<strong>操作命令</strong>，然后逐一执行（实现数据恢复）<ul><li>好处：<ol><li>避免额外的检查开销（如果命令语法有问题，又写入了日志 恢复数据时有问题）</li><li>不会阻塞当前写操作命令的执行（写成功后才会记录）</li></ol></li><li>坏处：<ol><li>数据可能丢失（执行完没来得及写入日志）</li><li>可能阻塞其他操作（AOF日志也在<strong>主线程</strong>中执行）</li></ol></li><li>具体过程：<ol><li>Redis 执行完写操作命令后，将命令追加到 server.aof_buf 缓冲区</li><li>通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件。<strong>并未写入硬盘</strong>，而是拷贝到了<strong>内核</strong>缓冲区 page cache，等待内核将数据写入</li><li>内核决定何时写入——Redis.conf文件可配置<code>appendfsync</code>（always每次写操作执行完写回 everysec每秒写回 no由OS决定写回时机）</li></ol></li><li>AOF日志过大，会？<ol><li>会AOF重写来压缩AOF文件——读取当前数据库中的所有键值对，然后将每个键值对用一条命令记录到新的AOF文件，全部记录完后替换现有AOF<ol><li>如重复记录<code>set name balabl</code>，只保留最新数据即可</li></ol></li></ol></li><li>重写AOF日志的过程？<ol><li>由后台<strong>子进程</strong> <code>bgrewriteaof</code> 完成<ol><li>好处：避免阻塞主进程 & 若使用线程，多线程间会共享内存，修改共享数据时需要加锁，亲子进程间以只读方式共享数据，若修改会发生写时复制，即亲子间有独立的数据副本（不用加锁）</li></ol></li><li>重写时主进程依然正常处理命令，会将写命令写入到 「AOF 缓冲区」和「AOF 重写缓冲区」（创建子进程后启用）</li><li>子进程完成重写时向主进程发送（异步）<strong>信号</strong>（进程间通讯的一种方式）</li><li>主进程收到信号，将 <strong>AOF 重写缓冲区</strong>中的所有内容追加到新的 AOF 的文件中，新的 AOF 的文件改名，覆盖现有的 AOF 文件</li></ol></li></ul></li><li>RDB快照：记录<strong>实际数据</strong><ul><li>快照时是否阻塞线程？<ol><li>执行<code>save</code>，在主线程生成RDB文件——会阻塞</li><li>执行<code>bgsave</code>，子进程生成RDB文件——避免阻塞</li></ol><ul><li>配置文件中设置<code>save</code>即为<code>bgsave</code></li><li>全量快照——内存中所有数据都记录</li></ul></li><li>执行快照时 数据能修改吗？——专指bgsave<ul><li>可以，采用写时复制（Copy-On-Write, COW）——执行 bgsave 命令的时候，会通过 fork() 创建<strong>子进程</strong></li><li>共享内存数据
<img loading=lazy src=image-4.png alt="alt text"></li><li>主线程执行写操作，将被修改的数据复制副本，子进程将副本数据写入RDB文件，主进程可直接修改数据
<img loading=lazy src=image-5.png alt="alt text"></li></ul></li></ul></li><li>混合持久化？</li></ol><blockquote><p>AOF丢失数据少但恢复速度不快，RDB快照频率不好确定，过低丢失数据多，过高影响性能</p></blockquote><ol><li>如何实现？<ul><li>工作在AOF重写过程：重写子进程将与主线程共享的内存数据以 <strong>RDB</strong> 方式写入到 AOF 文件，主线程处理的操作命令被记录在重写缓冲区，<strong>重写缓冲区里的增量命令</strong>会以 <strong>AOF</strong> 方式写入到 AOF 文件。重写完成后替换。</li><li>AOF中前半是RDB格式全量数据，后半是AOF格式增量数据</li></ul></li><li>优点：开头为 RDB 的格式，使得 Redis 可以更快的启动 + 结合 AOF 优点，减低了大量数据丢失的风险</li><li>缺点：添加了RDB格式内容，AOF 文件的可读性很差 + 兼容性差，Redis4.0前版本不能识别</li></ol><h4 id=集群-less>集群 less⭐<a hidden class=anchor aria-hidden=true href=#集群-less>#</a></h4><ol><li>主从复制：一主多从 读写分离<ol><li>主服务器读写，发生写时同步到从；从一般只读，接受主服务器的写命令并执行</li><li><strong>异步</strong>：主服务器在本地执行完命令，就向客户端返回结果&ndash;>无法实现强一致性（时刻一致）</li></ol></li><li>哨兵模式sentinel：监控主从服务器 & 主从节点故障转移功能（不懂）&ndash;>选一个新leader</li><li>切片集群cluster：（一个）切片集群有 16384 个哈希槽，类似于数据分区，每个键值对根据它的 key，被映射到一个哈希槽&ndash;>哈希槽被映射到具体的Redis节点（IP不同的就是不同节点）<ol><li>哈希槽的映射：平均分配 / 手动分配（<code>cluster meet</code> 节点建立连接后，<code>cluster addslots</code> 指定各节点上哈希槽数）</li></ol></li><li>集群脑裂问题与解决<ol><li>集群脑裂是啥？<ul><li>由于网络问题，集群节点之间失去联系（主从间）&ndash;>哨兵重选主节点，产生两个主服务&ndash;>网络恢复，旧主节点降级为从节点，需要与新主进行同步复制&ndash;>从节点清空自己缓冲区（之前未同步的数据）&ndash;>客户端当时写入的数据丢失</li></ul></li><li>解决：<ul><li>当主节点发现从节点下线或者通信超时的总数量小于阈值时，就禁止主节点<strong>写</strong>数据，把错误返回给客户端&ndash;>等待新主机上线后写</li><li>可以设置参数 <code>min-slaves-to-write x</code>、<code>min-slaves-max-lag x</code>若从节点连接数小于第一个/延迟超过第二个，主节点禁止写</li></ul></li></ol></li></ol><h4 id=过期删除与内存淘汰>过期删除与内存淘汰<a hidden class=anchor aria-hidden=true href=#过期删除与内存淘汰>#</a></h4><ol><li>Redis的过期删除策略？&ndash;> 惰性删除 + 定时删除<ol><li>设置了过期时间的key被带上过期时间存储到过期字典</li><li>（不主动删除键）查询key时先检查是否在过期字典中，在则比对系统时间，判断是否过期——<strong>惰性删除</strong><ol><li>优缺点：占用很少的系统资源 对CPU时间友好 but 过期key一直不被访问，对内存不友好（内存不释放）</li></ol></li><li><strong>定期删除</strong>：每隔一段时间随机抽取一定量的key，检查并删除，若过期key超过一定比例则继续随机抽取···&ndash;>限制时间上限<ol><li>优缺点：balabal（限制时长频率减少cpu占用 减少过期键对空间的占用） but 难以确定删除的时长与频率</li></ol></li></ol></li><li>持久化时怎么处理过期键？<ol><li>RDB——生成RDB时<strong>不保存</strong>过期了的键；加载时主服务器不载入，<strong>从服务器载入</strong>（但数据同步时，从服务器数据会被清空）</li><li>AOF——写入时若过期键未被删除，AOF会保留，被删除时向AOF追加DEL命令；重写时不重写过期键</li></ol></li><li>主从模式下怎么处理过期键？<ol><li>从库不进行过期扫描，主库删除键，在AOF文件中增加DEL指令，指令同步到从库</li></ol></li><li>Redis内存满了之后？<ol><li>内存淘汰机制</li></ol></li><li>内存淘汰策略有？<ol><li>不进行数据淘汰——<code>noeviction</code> 超过最大内存时停止提供服务，直接返回错误（Redis3.0后默认）</li><li>进行数据淘汰：<ol><li>在设置了TTL的数据中淘汰：<ol><li><code>volatile-random</code> 随机淘汰设置了TTL的任意键值</li><li><code>volatile-ttl</code> 优先淘汰更早过期的键值</li><li><code>volatile-lru</code> 淘汰所有设置了TTL的<strong>最久未使用</strong>的键值（Redis3.0前默认）</li><li><code>volatile-lfu</code> 淘汰所有设置了TTL的<strong>最少使用</strong>的键值</li></ol></li><li>所有数据范围：<ul><li><code>allkeys-random</code>/<code>allkeys-lru</code>/<code>allkeys-lfu</code></li></ul></li></ol></li></ol></li><li>LRU vs LFU<blockquote><p>Least Recently Used 与 Least Frequently Used</p></blockquote><ol><li>LRU是？<ul><li>链表，被使用的移到链表头，要删除时删除链表尾元素即可</li><li>问题：需要链表，带来额外空间开销；需要移动数据，大量数据要操作时会耗时</li></ul></li><li>Redis的LRU实现<ul><li>在 Redis 的对象结构体<code>redisObject</code>（管理某数据类型的数据对象）中添加额外的字段记录此数据的最后一次访问时间 &ndash;> 随机采样，淘汰最久没用的</li><li>缺点：缓存污染不能解决（一次性缓存删不了）</li></ul></li><li>LFU？<ul><li>Redis4.0后引入，记录访问次数</li></ul></li><li>Redis的LFU？</li></ol><blockquote><p>也记录在<code>redisObject</code>的lru字段中</p></blockquote><ul><li>多记录「数据的访问频次」的信息 &ndash;> 24 bits 的 lru 字段中高16bit记录访问时间戳，低8位记录访问频次</li></ul></li></ol><h4 id=缓存设计>缓存设计<a hidden class=anchor aria-hidden=true href=#缓存设计>#</a></h4><p>待施工···</p><h2 id=杂七杂八>杂七杂八⭐⭐<a hidden class=anchor aria-hidden=true href=#杂七杂八>#</a></h2><ol><li>进程与线程的区别？<ul><li>进程是OS层面 是程序的一次执行过程 一个进程内可能有多个线程</li><li>线程是CPU调度的基本单位 共享进程的地址空间与内存资源</li><li>Java中 不同线程拥有独立的JVM栈（java虚拟机） 本地方法栈 程序计数器</li><li>进程通信需要管道、信号量等 线程通信通过共享资源的读写操作实现</li></ul></li><li>Map底层实现：<ul><li>HashMap：JDK1.8之前 数组+链表（解决哈希冲突问题——拉链法） vs JDK1.8后 链表长度大于阈值（一般为8）时 数组长度小于64就进行数组扩容 大于时将链表转换为红黑树</li><li>LinkedHashMap：继承HashMap 加入双向链表 使键值对可以保持插入顺序</li><li>HashTable：由数组和链表组成 类似HashMap的初始形式</li><li>TreeMap：红黑树</li></ul></li><li>解释型与编译型：<ul><li>编译型语言，通过<strong>编译器</strong>将源代码<strong>一次性</strong>翻译成可被执行的机器码。执行快 开发慢</li><li>解释型语言。通过<strong>解释器</strong>一句一句的解释，边解释边执行。开发快，执行慢</li><li>Java：编译与解释并存。Java程序要先编译生成<strong>字节码</strong>（.class文件） 后字节码通过Java解释器来解释执行</li></ul></li><li>JIT vs AOT(ahead of time compilation)JDK9引入新的编译模式<ul><li>AOT：<strong>程序执行</strong>前将其编译为机器码，属于静态编译<ul><li>避免JIT预热等开销 可以提高启动速度 + 减少内存占用 + 增强Java程序安全性</li><li>but：无法支持Java动态特性，如反射 动态代理 动态加载 JNI等</li></ul></li><li>JIT：具有更高的极限处理能力，能够降低请求的最大延迟</li></ul></li></ol><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style></div><footer class=post-footer><ul class=post-tags><li><a href=https://Sattiluvcat.github.io/en/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://Sattiluvcat.github.io/en/posts/else/vf-rrt/><span class=title>« Prev</span><br><span>VF-RRT</span>
</a><a class=next href=https://Sattiluvcat.github.io/en/posts/java/cs186/><span class=title>Next »</span><br><span>CS186</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on x" href="https://x.com/intent/tweet/?text=%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f&amp;hashtags=Java"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f&amp;title=%e5%85%ab%e8%82%a1&amp;summary=%e5%85%ab%e8%82%a1&amp;source=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f&title=%e5%85%ab%e8%82%a1"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%85%ab%e8%82%a1%20-%20https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on telegram" href="https://telegram.me/share/url?text=%e5%85%ab%e8%82%a1&amp;url=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 八股 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e5%85%ab%e8%82%a1&u=https%3a%2f%2fSattiluvcat.github.io%2fen%2fposts%2fnotes%2f%25E5%2585%25AB%25E8%2582%25A1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://www-sattiluvcat-github-io.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><script id=dsq-count-scr src=//www-sattiluvcat-github-io.disqus.com/count.js async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://Sattiluvcat.github.io/en/>Satti's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-551JRG13S2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-551JRG13S2")</script></body></html>